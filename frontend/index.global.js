"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from6, except, desc) => {
    if (from6 && typeof from6 === "object" || typeof from6 === "function") {
      for (let key of __getOwnPropNames(from6))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from6[key], enumerable: !(desc = __getOwnPropDesc(from6, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.production.min.js
  var require_react_production_min = __commonJS({
    "../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.production.min.js"(exports) {
      "use strict";
      var l2 = Symbol.for("react.element");
      var n2 = Symbol.for("react.portal");
      var p2 = Symbol.for("react.fragment");
      var q = Symbol.for("react.strict_mode");
      var r3 = Symbol.for("react.profiler");
      var t2 = Symbol.for("react.provider");
      var u2 = Symbol.for("react.context");
      var v2 = Symbol.for("react.forward_ref");
      var w2 = Symbol.for("react.suspense");
      var x2 = Symbol.for("react.memo");
      var y2 = Symbol.for("react.lazy");
      var z2 = Symbol.iterator;
      function A2(a2) {
        if (null === a2 || "object" !== typeof a2) return null;
        a2 = z2 && a2[z2] || a2["@@iterator"];
        return "function" === typeof a2 ? a2 : null;
      }
      var B = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } };
      var C = Object.assign;
      var D = {};
      function E(a2, b2, e2) {
        this.props = a2;
        this.context = b2;
        this.refs = D;
        this.updater = e2 || B;
      }
      E.prototype.isReactComponent = {};
      E.prototype.setState = function(a2, b2) {
        if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, a2, b2, "setState");
      };
      E.prototype.forceUpdate = function(a2) {
        this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
      };
      function F() {
      }
      F.prototype = E.prototype;
      function G(a2, b2, e2) {
        this.props = a2;
        this.context = b2;
        this.refs = D;
        this.updater = e2 || B;
      }
      var H = G.prototype = new F();
      H.constructor = G;
      C(H, E.prototype);
      H.isPureReactComponent = true;
      var I = Array.isArray;
      var J = Object.prototype.hasOwnProperty;
      var K = { current: null };
      var L = { key: true, ref: true, __self: true, __source: true };
      function M(a2, b2, e2) {
        var d2, c2 = {}, k = null, h2 = null;
        if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k = "" + b2.key), b2) J.call(b2, d2) && !L.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
        var g2 = arguments.length - 2;
        if (1 === g2) c2.children = e2;
        else if (1 < g2) {
          for (var f3 = Array(g2), m2 = 0; m2 < g2; m2++) f3[m2] = arguments[m2 + 2];
          c2.children = f3;
        }
        if (a2 && a2.defaultProps) for (d2 in g2 = a2.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
        return { $$typeof: l2, type: a2, key: k, ref: h2, props: c2, _owner: K.current };
      }
      function N(a2, b2) {
        return { $$typeof: l2, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
      }
      function O2(a2) {
        return "object" === typeof a2 && null !== a2 && a2.$$typeof === l2;
      }
      function escape(a2) {
        var b2 = { "=": "=0", ":": "=2" };
        return "$" + a2.replace(/[=:]/g, function(a3) {
          return b2[a3];
        });
      }
      var P2 = /\/+/g;
      function Q(a2, b2) {
        return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
      }
      function R(a2, b2, e2, d2, c2) {
        var k = typeof a2;
        if ("undefined" === k || "boolean" === k) a2 = null;
        var h2 = false;
        if (null === a2) h2 = true;
        else switch (k) {
          case "string":
          case "number":
            h2 = true;
            break;
          case "object":
            switch (a2.$$typeof) {
              case l2:
              case n2:
                h2 = true;
            }
        }
        if (h2) return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q(h2, 0) : d2, I(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P2, "$&/") + "/"), R(c2, b2, e2, "", function(a3) {
          return a3;
        })) : null != c2 && (O2(c2) && (c2 = N(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P2, "$&/") + "/") + a2)), b2.push(c2)), 1;
        h2 = 0;
        d2 = "" === d2 ? "." : d2 + ":";
        if (I(a2)) for (var g2 = 0; g2 < a2.length; g2++) {
          k = a2[g2];
          var f3 = d2 + Q(k, g2);
          h2 += R(k, b2, e2, f3, c2);
        }
        else if (f3 = A2(a2), "function" === typeof f3) for (a2 = f3.call(a2), g2 = 0; !(k = a2.next()).done; ) k = k.value, f3 = d2 + Q(k, g2++), h2 += R(k, b2, e2, f3, c2);
        else if ("object" === k) throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
        return h2;
      }
      function S2(a2, b2, e2) {
        if (null == a2) return a2;
        var d2 = [], c2 = 0;
        R(a2, d2, "", "", function(a3) {
          return b2.call(e2, a3, c2++);
        });
        return d2;
      }
      function T(a2) {
        if (-1 === a2._status) {
          var b2 = a2._result;
          b2 = b2();
          b2.then(function(b3) {
            if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b3;
          }, function(b3) {
            if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b3;
          });
          -1 === a2._status && (a2._status = 0, a2._result = b2);
        }
        if (1 === a2._status) return a2._result.default;
        throw a2._result;
      }
      var U = { current: null };
      var V = { transition: null };
      var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
      exports.Children = { map: S2, forEach: function(a2, b2, e2) {
        S2(a2, function() {
          b2.apply(this, arguments);
        }, e2);
      }, count: function(a2) {
        var b2 = 0;
        S2(a2, function() {
          b2++;
        });
        return b2;
      }, toArray: function(a2) {
        return S2(a2, function(a3) {
          return a3;
        }) || [];
      }, only: function(a2) {
        if (!O2(a2)) throw Error("React.Children.only expected to receive a single React element child.");
        return a2;
      } };
      exports.Component = E;
      exports.Fragment = p2;
      exports.Profiler = r3;
      exports.PureComponent = G;
      exports.StrictMode = q;
      exports.Suspense = w2;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
      exports.cloneElement = function(a2, b2, e2) {
        if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
        var d2 = C({}, a2.props), c2 = a2.key, k = a2.ref, h2 = a2._owner;
        if (null != b2) {
          void 0 !== b2.ref && (k = b2.ref, h2 = K.current);
          void 0 !== b2.key && (c2 = "" + b2.key);
          if (a2.type && a2.type.defaultProps) var g2 = a2.type.defaultProps;
          for (f3 in b2) J.call(b2, f3) && !L.hasOwnProperty(f3) && (d2[f3] = void 0 === b2[f3] && void 0 !== g2 ? g2[f3] : b2[f3]);
        }
        var f3 = arguments.length - 2;
        if (1 === f3) d2.children = e2;
        else if (1 < f3) {
          g2 = Array(f3);
          for (var m2 = 0; m2 < f3; m2++) g2[m2] = arguments[m2 + 2];
          d2.children = g2;
        }
        return { $$typeof: l2, type: a2.type, key: c2, ref: k, props: d2, _owner: h2 };
      };
      exports.createContext = function(a2) {
        a2 = { $$typeof: u2, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
        a2.Provider = { $$typeof: t2, _context: a2 };
        return a2.Consumer = a2;
      };
      exports.createElement = M;
      exports.createFactory = function(a2) {
        var b2 = M.bind(null, a2);
        b2.type = a2;
        return b2;
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(a2) {
        return { $$typeof: v2, render: a2 };
      };
      exports.isValidElement = O2;
      exports.lazy = function(a2) {
        return { $$typeof: y2, _payload: { _status: -1, _result: a2 }, _init: T };
      };
      exports.memo = function(a2, b2) {
        return { $$typeof: x2, type: a2, compare: void 0 === b2 ? null : b2 };
      };
      exports.startTransition = function(a2) {
        var b2 = V.transition;
        V.transition = {};
        try {
          a2();
        } finally {
          V.transition = b2;
        }
      };
      exports.unstable_act = function() {
        throw Error("act(...) is not supported in production builds of React.");
      };
      exports.useCallback = function(a2, b2) {
        return U.current.useCallback(a2, b2);
      };
      exports.useContext = function(a2) {
        return U.current.useContext(a2);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(a2) {
        return U.current.useDeferredValue(a2);
      };
      exports.useEffect = function(a2, b2) {
        return U.current.useEffect(a2, b2);
      };
      exports.useId = function() {
        return U.current.useId();
      };
      exports.useImperativeHandle = function(a2, b2, e2) {
        return U.current.useImperativeHandle(a2, b2, e2);
      };
      exports.useInsertionEffect = function(a2, b2) {
        return U.current.useInsertionEffect(a2, b2);
      };
      exports.useLayoutEffect = function(a2, b2) {
        return U.current.useLayoutEffect(a2, b2);
      };
      exports.useMemo = function(a2, b2) {
        return U.current.useMemo(a2, b2);
      };
      exports.useReducer = function(a2, b2, e2) {
        return U.current.useReducer(a2, b2, e2);
      };
      exports.useRef = function(a2) {
        return U.current.useRef(a2);
      };
      exports.useState = function(a2) {
        return U.current.useState(a2);
      };
      exports.useSyncExternalStore = function(a2, b2, e2) {
        return U.current.useSyncExternalStore(a2, b2, e2);
      };
      exports.useTransition = function() {
        return U.current.useTransition();
      };
      exports.version = "18.2.0";
    }
  });

  // ../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js
  var require_react = __commonJS({
    "../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min = __commonJS({
    "../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
      "use strict";
      function f3(a2, b2) {
        var c2 = a2.length;
        a2.push(b2);
        a: for (; 0 < c2; ) {
          var d2 = c2 - 1 >>> 1, e2 = a2[d2];
          if (0 < g2(e2, b2)) a2[d2] = b2, a2[c2] = e2, c2 = d2;
          else break a;
        }
      }
      function h2(a2) {
        return 0 === a2.length ? null : a2[0];
      }
      function k(a2) {
        if (0 === a2.length) return null;
        var b2 = a2[0], c2 = a2.pop();
        if (c2 !== b2) {
          a2[0] = c2;
          a: for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
            var m2 = 2 * (d2 + 1) - 1, C = a2[m2], n2 = m2 + 1, x2 = a2[n2];
            if (0 > g2(C, c2)) n2 < e2 && 0 > g2(x2, C) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C, a2[m2] = c2, d2 = m2);
            else if (n2 < e2 && 0 > g2(x2, c2)) a2[d2] = x2, a2[n2] = c2, d2 = n2;
            else break a;
          }
        }
        return b2;
      }
      function g2(a2, b2) {
        var c2 = a2.sortIndex - b2.sortIndex;
        return 0 !== c2 ? c2 : a2.id - b2.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        l2 = performance;
        exports.unstable_now = function() {
          return l2.now();
        };
      } else {
        p2 = Date, q = p2.now();
        exports.unstable_now = function() {
          return p2.now() - q;
        };
      }
      var l2;
      var p2;
      var q;
      var r3 = [];
      var t2 = [];
      var u2 = 1;
      var v2 = null;
      var y2 = 3;
      var z2 = false;
      var A2 = false;
      var B = false;
      var D = "function" === typeof setTimeout ? setTimeout : null;
      var E = "function" === typeof clearTimeout ? clearTimeout : null;
      var F = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a2) {
        for (var b2 = h2(t2); null !== b2; ) {
          if (null === b2.callback) k(t2);
          else if (b2.startTime <= a2) k(t2), b2.sortIndex = b2.expirationTime, f3(r3, b2);
          else break;
          b2 = h2(t2);
        }
      }
      function H(a2) {
        B = false;
        G(a2);
        if (!A2) if (null !== h2(r3)) A2 = true, I(J);
        else {
          var b2 = h2(t2);
          null !== b2 && K(H, b2.startTime - a2);
        }
      }
      function J(a2, b2) {
        A2 = false;
        B && (B = false, E(L), L = -1);
        z2 = true;
        var c2 = y2;
        try {
          G(b2);
          for (v2 = h2(r3); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M()); ) {
            var d2 = v2.callback;
            if ("function" === typeof d2) {
              v2.callback = null;
              y2 = v2.priorityLevel;
              var e2 = d2(v2.expirationTime <= b2);
              b2 = exports.unstable_now();
              "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r3) && k(r3);
              G(b2);
            } else k(r3);
            v2 = h2(r3);
          }
          if (null !== v2) var w2 = true;
          else {
            var m2 = h2(t2);
            null !== m2 && K(H, m2.startTime - b2);
            w2 = false;
          }
          return w2;
        } finally {
          v2 = null, y2 = c2, z2 = false;
        }
      }
      var N = false;
      var O2 = null;
      var L = -1;
      var P2 = 5;
      var Q = -1;
      function M() {
        return exports.unstable_now() - Q < P2 ? false : true;
      }
      function R() {
        if (null !== O2) {
          var a2 = exports.unstable_now();
          Q = a2;
          var b2 = true;
          try {
            b2 = O2(true, a2);
          } finally {
            b2 ? S2() : (N = false, O2 = null);
          }
        } else N = false;
      }
      var S2;
      if ("function" === typeof F) S2 = function() {
        F(R);
      };
      else if ("undefined" !== typeof MessageChannel) {
        T = new MessageChannel(), U = T.port2;
        T.port1.onmessage = R;
        S2 = function() {
          U.postMessage(null);
        };
      } else S2 = function() {
        D(R, 0);
      };
      var T;
      var U;
      function I(a2) {
        O2 = a2;
        N || (N = true, S2());
      }
      function K(a2, b2) {
        L = D(function() {
          a2(exports.unstable_now());
        }, b2);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a2) {
        a2.callback = null;
      };
      exports.unstable_continueExecution = function() {
        A2 || z2 || (A2 = true, I(J));
      };
      exports.unstable_forceFrameRate = function(a2) {
        0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return y2;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return h2(r3);
      };
      exports.unstable_next = function(a2) {
        switch (y2) {
          case 1:
          case 2:
          case 3:
            var b2 = 3;
            break;
          default:
            b2 = y2;
        }
        var c2 = y2;
        y2 = b2;
        try {
          return a2();
        } finally {
          y2 = c2;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(a2, b2) {
        switch (a2) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a2 = 3;
        }
        var c2 = y2;
        y2 = a2;
        try {
          return b2();
        } finally {
          y2 = c2;
        }
      };
      exports.unstable_scheduleCallback = function(a2, b2, c2) {
        var d2 = exports.unstable_now();
        "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
        switch (a2) {
          case 1:
            var e2 = -1;
            break;
          case 2:
            e2 = 250;
            break;
          case 5:
            e2 = 1073741823;
            break;
          case 4:
            e2 = 1e4;
            break;
          default:
            e2 = 5e3;
        }
        e2 = c2 + e2;
        a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
        c2 > d2 ? (a2.sortIndex = c2, f3(t2, a2), null === h2(r3) && a2 === h2(t2) && (B ? (E(L), L = -1) : B = true, K(H, c2 - d2))) : (a2.sortIndex = e2, f3(r3, a2), A2 || z2 || (A2 = true, I(J)));
        return a2;
      };
      exports.unstable_shouldYield = M;
      exports.unstable_wrapCallback = function(a2) {
        var b2 = y2;
        return function() {
          var c2 = y2;
          y2 = b2;
          try {
            return a2.apply(this, arguments);
          } finally {
            y2 = c2;
          }
        };
      };
    }
  });

  // ../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_scheduler_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom.production.min.js
  var require_react_dom_production_min = __commonJS({
    "../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
      "use strict";
      var aa = require_react();
      var ca = require_scheduler();
      function p2(a2) {
        for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
        return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var da = /* @__PURE__ */ new Set();
      var ea = {};
      function fa(a2, b2) {
        ha(a2, b2);
        ha(a2 + "Capture", b2);
      }
      function ha(a2, b2) {
        ea[a2] = b2;
        for (a2 = 0; a2 < b2.length; a2++) da.add(b2[a2]);
      }
      var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var ja = Object.prototype.hasOwnProperty;
      var ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
      var la = {};
      var ma = {};
      function oa(a2) {
        if (ja.call(ma, a2)) return true;
        if (ja.call(la, a2)) return false;
        if (ka.test(a2)) return ma[a2] = true;
        la[a2] = true;
        return false;
      }
      function pa(a2, b2, c2, d2) {
        if (null !== c2 && 0 === c2.type) return false;
        switch (typeof b2) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d2) return false;
            if (null !== c2) return !c2.acceptsBooleans;
            a2 = a2.toLowerCase().slice(0, 5);
            return "data-" !== a2 && "aria-" !== a2;
          default:
            return false;
        }
      }
      function qa(a2, b2, c2, d2) {
        if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2)) return true;
        if (d2) return false;
        if (null !== c2) switch (c2.type) {
          case 3:
            return !b2;
          case 4:
            return false === b2;
          case 5:
            return isNaN(b2);
          case 6:
            return isNaN(b2) || 1 > b2;
        }
        return false;
      }
      function v2(a2, b2, c2, d2, e2, f3, g2) {
        this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
        this.attributeName = d2;
        this.attributeNamespace = e2;
        this.mustUseProperty = c2;
        this.propertyName = a2;
        this.type = b2;
        this.sanitizeURL = f3;
        this.removeEmptyString = g2;
      }
      var z2 = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
        z2[a2] = new v2(a2, 0, false, a2, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
        var b2 = a2[0];
        z2[b2] = new v2(b2, 1, false, a2[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
        z2[a2] = new v2(a2, 2, false, a2.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
        z2[a2] = new v2(a2, 2, false, a2, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
        z2[a2] = new v2(a2, 3, false, a2.toLowerCase(), null, false, false);
      });
      ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
        z2[a2] = new v2(a2, 3, true, a2, null, false, false);
      });
      ["capture", "download"].forEach(function(a2) {
        z2[a2] = new v2(a2, 4, false, a2, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function(a2) {
        z2[a2] = new v2(a2, 6, false, a2, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(a2) {
        z2[a2] = new v2(a2, 5, false, a2.toLowerCase(), null, false, false);
      });
      var ra = /[\-:]([a-z])/g;
      function sa(a2) {
        return a2[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
        var b2 = a2.replace(
          ra,
          sa
        );
        z2[b2] = new v2(b2, 1, false, a2, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
        var b2 = a2.replace(ra, sa);
        z2[b2] = new v2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
      });
      ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
        var b2 = a2.replace(ra, sa);
        z2[b2] = new v2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(a2) {
        z2[a2] = new v2(a2, 1, false, a2.toLowerCase(), null, false, false);
      });
      z2.xlinkHref = new v2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(a2) {
        z2[a2] = new v2(a2, 1, false, a2.toLowerCase(), null, true, true);
      });
      function ta(a2, b2, c2, d2) {
        var e2 = z2.hasOwnProperty(b2) ? z2[b2] : null;
        if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
      }
      var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var va = Symbol.for("react.element");
      var wa = Symbol.for("react.portal");
      var ya = Symbol.for("react.fragment");
      var za = Symbol.for("react.strict_mode");
      var Aa = Symbol.for("react.profiler");
      var Ba = Symbol.for("react.provider");
      var Ca = Symbol.for("react.context");
      var Da = Symbol.for("react.forward_ref");
      var Ea = Symbol.for("react.suspense");
      var Fa = Symbol.for("react.suspense_list");
      var Ga = Symbol.for("react.memo");
      var Ha = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      Symbol.for("react.debug_trace_mode");
      var Ia = Symbol.for("react.offscreen");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.cache");
      Symbol.for("react.tracing_marker");
      var Ja = Symbol.iterator;
      function Ka(a2) {
        if (null === a2 || "object" !== typeof a2) return null;
        a2 = Ja && a2[Ja] || a2["@@iterator"];
        return "function" === typeof a2 ? a2 : null;
      }
      var A2 = Object.assign;
      var La;
      function Ma(a2) {
        if (void 0 === La) try {
          throw Error();
        } catch (c2) {
          var b2 = c2.stack.trim().match(/\n( *(at )?)/);
          La = b2 && b2[1] || "";
        }
        return "\n" + La + a2;
      }
      var Na = false;
      function Oa(a2, b2) {
        if (!a2 || Na) return "";
        Na = true;
        var c2 = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b2) if (b2 = function() {
            throw Error();
          }, Object.defineProperty(b2.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b2, []);
            } catch (l2) {
              var d2 = l2;
            }
            Reflect.construct(a2, [], b2);
          } else {
            try {
              b2.call();
            } catch (l2) {
              d2 = l2;
            }
            a2.call(b2.prototype);
          }
          else {
            try {
              throw Error();
            } catch (l2) {
              d2 = l2;
            }
            a2();
          }
        } catch (l2) {
          if (l2 && d2 && "string" === typeof l2.stack) {
            for (var e2 = l2.stack.split("\n"), f3 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f3.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f3[h2]; ) h2--;
            for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f3[h2]) {
              if (1 !== g2 || 1 !== h2) {
                do
                  if (g2--, h2--, 0 > h2 || e2[g2] !== f3[h2]) {
                    var k = "\n" + e2[g2].replace(" at new ", " at ");
                    a2.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a2.displayName));
                    return k;
                  }
                while (1 <= g2 && 0 <= h2);
              }
              break;
            }
          }
        } finally {
          Na = false, Error.prepareStackTrace = c2;
        }
        return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
      }
      function Pa(a2) {
        switch (a2.tag) {
          case 5:
            return Ma(a2.type);
          case 16:
            return Ma("Lazy");
          case 13:
            return Ma("Suspense");
          case 19:
            return Ma("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a2 = Oa(a2.type, false), a2;
          case 11:
            return a2 = Oa(a2.type.render, false), a2;
          case 1:
            return a2 = Oa(a2.type, true), a2;
          default:
            return "";
        }
      }
      function Qa(a2) {
        if (null == a2) return null;
        if ("function" === typeof a2) return a2.displayName || a2.name || null;
        if ("string" === typeof a2) return a2;
        switch (a2) {
          case ya:
            return "Fragment";
          case wa:
            return "Portal";
          case Aa:
            return "Profiler";
          case za:
            return "StrictMode";
          case Ea:
            return "Suspense";
          case Fa:
            return "SuspenseList";
        }
        if ("object" === typeof a2) switch (a2.$$typeof) {
          case Ca:
            return (a2.displayName || "Context") + ".Consumer";
          case Ba:
            return (a2._context.displayName || "Context") + ".Provider";
          case Da:
            var b2 = a2.render;
            a2 = a2.displayName;
            a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
            return a2;
          case Ga:
            return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
          case Ha:
            b2 = a2._payload;
            a2 = a2._init;
            try {
              return Qa(a2(b2));
            } catch (c2) {
            }
        }
        return null;
      }
      function Ra(a2) {
        var b2 = a2.type;
        switch (a2.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b2.displayName || "Context") + ".Consumer";
          case 10:
            return (b2._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return b2;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return Qa(b2);
          case 8:
            return b2 === za ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if ("function" === typeof b2) return b2.displayName || b2.name || null;
            if ("string" === typeof b2) return b2;
        }
        return null;
      }
      function Sa(a2) {
        switch (typeof a2) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return a2;
          case "object":
            return a2;
          default:
            return "";
        }
      }
      function Ta(a2) {
        var b2 = a2.type;
        return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
      }
      function Ua(a2) {
        var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
        if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
          var e2 = c2.get, f3 = c2.set;
          Object.defineProperty(a2, b2, { configurable: true, get: function() {
            return e2.call(this);
          }, set: function(a3) {
            d2 = "" + a3;
            f3.call(this, a3);
          } });
          Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
          return { getValue: function() {
            return d2;
          }, setValue: function(a3) {
            d2 = "" + a3;
          }, stopTracking: function() {
            a2._valueTracker = null;
            delete a2[b2];
          } };
        }
      }
      function Va(a2) {
        a2._valueTracker || (a2._valueTracker = Ua(a2));
      }
      function Wa(a2) {
        if (!a2) return false;
        var b2 = a2._valueTracker;
        if (!b2) return true;
        var c2 = b2.getValue();
        var d2 = "";
        a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
        a2 = d2;
        return a2 !== c2 ? (b2.setValue(a2), true) : false;
      }
      function Xa(a2) {
        a2 = a2 || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a2) return null;
        try {
          return a2.activeElement || a2.body;
        } catch (b2) {
          return a2.body;
        }
      }
      function Ya(a2, b2) {
        var c2 = b2.checked;
        return A2({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
      }
      function Za(a2, b2) {
        var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
        c2 = Sa(null != b2.value ? b2.value : c2);
        a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
      }
      function ab(a2, b2) {
        b2 = b2.checked;
        null != b2 && ta(a2, "checked", b2, false);
      }
      function bb(a2, b2) {
        ab(a2, b2);
        var c2 = Sa(b2.value), d2 = b2.type;
        if (null != c2) if ("number" === d2) {
          if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
        } else a2.value !== "" + c2 && (a2.value = "" + c2);
        else if ("submit" === d2 || "reset" === d2) {
          a2.removeAttribute("value");
          return;
        }
        b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
        null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
      }
      function db(a2, b2, c2) {
        if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
          var d2 = b2.type;
          if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
          b2 = "" + a2._wrapperState.initialValue;
          c2 || b2 === a2.value || (a2.value = b2);
          a2.defaultValue = b2;
        }
        c2 = a2.name;
        "" !== c2 && (a2.name = "");
        a2.defaultChecked = !!a2._wrapperState.initialChecked;
        "" !== c2 && (a2.name = c2);
      }
      function cb(a2, b2, c2) {
        if ("number" !== b2 || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
      }
      var eb = Array.isArray;
      function fb(a2, b2, c2, d2) {
        a2 = a2.options;
        if (b2) {
          b2 = {};
          for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
          for (c2 = 0; c2 < a2.length; c2++) e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
        } else {
          c2 = "" + Sa(c2);
          b2 = null;
          for (e2 = 0; e2 < a2.length; e2++) {
            if (a2[e2].value === c2) {
              a2[e2].selected = true;
              d2 && (a2[e2].defaultSelected = true);
              return;
            }
            null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
          }
          null !== b2 && (b2.selected = true);
        }
      }
      function gb(a2, b2) {
        if (null != b2.dangerouslySetInnerHTML) throw Error(p2(91));
        return A2({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
      }
      function hb(a2, b2) {
        var c2 = b2.value;
        if (null == c2) {
          c2 = b2.children;
          b2 = b2.defaultValue;
          if (null != c2) {
            if (null != b2) throw Error(p2(92));
            if (eb(c2)) {
              if (1 < c2.length) throw Error(p2(93));
              c2 = c2[0];
            }
            b2 = c2;
          }
          null == b2 && (b2 = "");
          c2 = b2;
        }
        a2._wrapperState = { initialValue: Sa(c2) };
      }
      function ib(a2, b2) {
        var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
        null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
        null != d2 && (a2.defaultValue = "" + d2);
      }
      function jb(a2) {
        var b2 = a2.textContent;
        b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
      }
      function kb(a2) {
        switch (a2) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function lb(a2, b2) {
        return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
      }
      var mb;
      var nb = function(a2) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
          MSApp.execUnsafeLocalFunction(function() {
            return a2(b2, c2, d2, e2);
          });
        } : a2;
      }(function(a2, b2) {
        if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b2;
        else {
          mb = mb || document.createElement("div");
          mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
          for (b2 = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
          for (; b2.firstChild; ) a2.appendChild(b2.firstChild);
        }
      });
      function ob(a2, b2) {
        if (b2) {
          var c2 = a2.firstChild;
          if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
            c2.nodeValue = b2;
            return;
          }
        }
        a2.textContent = b2;
      }
      var pb = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      var qb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(pb).forEach(function(a2) {
        qb.forEach(function(b2) {
          b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
          pb[b2] = pb[a2];
        });
      });
      function rb(a2, b2, c2) {
        return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
      }
      function sb(a2, b2) {
        a2 = a2.style;
        for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
          var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
          "float" === c2 && (c2 = "cssFloat");
          d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
        }
      }
      var tb = A2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
      function ub(a2, b2) {
        if (b2) {
          if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p2(137, a2));
          if (null != b2.dangerouslySetInnerHTML) {
            if (null != b2.children) throw Error(p2(60));
            if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p2(61));
          }
          if (null != b2.style && "object" !== typeof b2.style) throw Error(p2(62));
        }
      }
      function vb(a2, b2) {
        if (-1 === a2.indexOf("-")) return "string" === typeof b2.is;
        switch (a2) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var wb = null;
      function xb(a2) {
        a2 = a2.target || a2.srcElement || window;
        a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
        return 3 === a2.nodeType ? a2.parentNode : a2;
      }
      var yb = null;
      var zb = null;
      var Ab = null;
      function Bb(a2) {
        if (a2 = Cb(a2)) {
          if ("function" !== typeof yb) throw Error(p2(280));
          var b2 = a2.stateNode;
          b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
        }
      }
      function Eb(a2) {
        zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
      }
      function Fb() {
        if (zb) {
          var a2 = zb, b2 = Ab;
          Ab = zb = null;
          Bb(a2);
          if (b2) for (a2 = 0; a2 < b2.length; a2++) Bb(b2[a2]);
        }
      }
      function Gb(a2, b2) {
        return a2(b2);
      }
      function Hb() {
      }
      var Ib = false;
      function Jb(a2, b2, c2) {
        if (Ib) return a2(b2, c2);
        Ib = true;
        try {
          return Gb(a2, b2, c2);
        } finally {
          if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
        }
      }
      function Kb(a2, b2) {
        var c2 = a2.stateNode;
        if (null === c2) return null;
        var d2 = Db(c2);
        if (null === d2) return null;
        c2 = d2[b2];
        a: switch (b2) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
            a2 = !d2;
            break a;
          default:
            a2 = false;
        }
        if (a2) return null;
        if (c2 && "function" !== typeof c2) throw Error(p2(231, b2, typeof c2));
        return c2;
      }
      var Lb = false;
      if (ia) try {
        Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a2) {
        Lb = false;
      }
      var Mb;
      function Nb(a2, b2, c2, d2, e2, f3, g2, h2, k) {
        var l2 = Array.prototype.slice.call(arguments, 3);
        try {
          b2.apply(c2, l2);
        } catch (m2) {
          this.onError(m2);
        }
      }
      var Ob = false;
      var Pb = null;
      var Qb = false;
      var Rb = null;
      var Sb = { onError: function(a2) {
        Ob = true;
        Pb = a2;
      } };
      function Tb(a2, b2, c2, d2, e2, f3, g2, h2, k) {
        Ob = false;
        Pb = null;
        Nb.apply(Sb, arguments);
      }
      function Ub(a2, b2, c2, d2, e2, f3, g2, h2, k) {
        Tb.apply(this, arguments);
        if (Ob) {
          if (Ob) {
            var l2 = Pb;
            Ob = false;
            Pb = null;
          } else throw Error(p2(198));
          Qb || (Qb = true, Rb = l2);
        }
      }
      function Vb(a2) {
        var b2 = a2, c2 = a2;
        if (a2.alternate) for (; b2.return; ) b2 = b2.return;
        else {
          a2 = b2;
          do
            b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
          while (a2);
        }
        return 3 === b2.tag ? c2 : null;
      }
      function Wb(a2) {
        if (13 === a2.tag) {
          var b2 = a2.memoizedState;
          null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
          if (null !== b2) return b2.dehydrated;
        }
        return null;
      }
      function Xb(a2) {
        if (Vb(a2) !== a2) throw Error(p2(188));
      }
      function Yb(a2) {
        var b2 = a2.alternate;
        if (!b2) {
          b2 = Vb(a2);
          if (null === b2) throw Error(p2(188));
          return b2 !== a2 ? null : a2;
        }
        for (var c2 = a2, d2 = b2; ; ) {
          var e2 = c2.return;
          if (null === e2) break;
          var f3 = e2.alternate;
          if (null === f3) {
            d2 = e2.return;
            if (null !== d2) {
              c2 = d2;
              continue;
            }
            break;
          }
          if (e2.child === f3.child) {
            for (f3 = e2.child; f3; ) {
              if (f3 === c2) return Xb(e2), a2;
              if (f3 === d2) return Xb(e2), b2;
              f3 = f3.sibling;
            }
            throw Error(p2(188));
          }
          if (c2.return !== d2.return) c2 = e2, d2 = f3;
          else {
            for (var g2 = false, h2 = e2.child; h2; ) {
              if (h2 === c2) {
                g2 = true;
                c2 = e2;
                d2 = f3;
                break;
              }
              if (h2 === d2) {
                g2 = true;
                d2 = e2;
                c2 = f3;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2) {
              for (h2 = f3.child; h2; ) {
                if (h2 === c2) {
                  g2 = true;
                  c2 = f3;
                  d2 = e2;
                  break;
                }
                if (h2 === d2) {
                  g2 = true;
                  d2 = f3;
                  c2 = e2;
                  break;
                }
                h2 = h2.sibling;
              }
              if (!g2) throw Error(p2(189));
            }
          }
          if (c2.alternate !== d2) throw Error(p2(190));
        }
        if (3 !== c2.tag) throw Error(p2(188));
        return c2.stateNode.current === c2 ? a2 : b2;
      }
      function Zb(a2) {
        a2 = Yb(a2);
        return null !== a2 ? $b(a2) : null;
      }
      function $b(a2) {
        if (5 === a2.tag || 6 === a2.tag) return a2;
        for (a2 = a2.child; null !== a2; ) {
          var b2 = $b(a2);
          if (null !== b2) return b2;
          a2 = a2.sibling;
        }
        return null;
      }
      var ac = ca.unstable_scheduleCallback;
      var bc = ca.unstable_cancelCallback;
      var cc = ca.unstable_shouldYield;
      var dc = ca.unstable_requestPaint;
      var B = ca.unstable_now;
      var ec = ca.unstable_getCurrentPriorityLevel;
      var fc = ca.unstable_ImmediatePriority;
      var gc = ca.unstable_UserBlockingPriority;
      var hc = ca.unstable_NormalPriority;
      var ic = ca.unstable_LowPriority;
      var jc = ca.unstable_IdlePriority;
      var kc = null;
      var lc = null;
      function mc(a2) {
        if (lc && "function" === typeof lc.onCommitFiberRoot) try {
          lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
        } catch (b2) {
        }
      }
      var oc = Math.clz32 ? Math.clz32 : nc;
      var pc = Math.log;
      var qc = Math.LN2;
      function nc(a2) {
        a2 >>>= 0;
        return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
      }
      var rc = 64;
      var sc = 4194304;
      function tc(a2) {
        switch (a2 & -a2) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a2 & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return a2 & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a2;
        }
      }
      function uc(a2, b2) {
        var c2 = a2.pendingLanes;
        if (0 === c2) return 0;
        var d2 = 0, e2 = a2.suspendedLanes, f3 = a2.pingedLanes, g2 = c2 & 268435455;
        if (0 !== g2) {
          var h2 = g2 & ~e2;
          0 !== h2 ? d2 = tc(h2) : (f3 &= g2, 0 !== f3 && (d2 = tc(f3)));
        } else g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f3 && (d2 = tc(f3));
        if (0 === d2) return 0;
        if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f3 = b2 & -b2, e2 >= f3 || 16 === e2 && 0 !== (f3 & 4194240))) return b2;
        0 !== (d2 & 4) && (d2 |= c2 & 16);
        b2 = a2.entangledLanes;
        if (0 !== b2) for (a2 = a2.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
        return d2;
      }
      function vc(a2, b2) {
        switch (a2) {
          case 1:
          case 2:
          case 4:
            return b2 + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return b2 + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function wc(a2, b2) {
        for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f3 = a2.pendingLanes; 0 < f3; ) {
          var g2 = 31 - oc(f3), h2 = 1 << g2, k = e2[g2];
          if (-1 === k) {
            if (0 === (h2 & c2) || 0 !== (h2 & d2)) e2[g2] = vc(h2, b2);
          } else k <= b2 && (a2.expiredLanes |= h2);
          f3 &= ~h2;
        }
      }
      function xc(a2) {
        a2 = a2.pendingLanes & -1073741825;
        return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
      }
      function yc() {
        var a2 = rc;
        rc <<= 1;
        0 === (rc & 4194240) && (rc = 64);
        return a2;
      }
      function zc(a2) {
        for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a2);
        return b2;
      }
      function Ac(a2, b2, c2) {
        a2.pendingLanes |= b2;
        536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
        a2 = a2.eventTimes;
        b2 = 31 - oc(b2);
        a2[b2] = c2;
      }
      function Bc(a2, b2) {
        var c2 = a2.pendingLanes & ~b2;
        a2.pendingLanes = b2;
        a2.suspendedLanes = 0;
        a2.pingedLanes = 0;
        a2.expiredLanes &= b2;
        a2.mutableReadLanes &= b2;
        a2.entangledLanes &= b2;
        b2 = a2.entanglements;
        var d2 = a2.eventTimes;
        for (a2 = a2.expirationTimes; 0 < c2; ) {
          var e2 = 31 - oc(c2), f3 = 1 << e2;
          b2[e2] = 0;
          d2[e2] = -1;
          a2[e2] = -1;
          c2 &= ~f3;
        }
      }
      function Cc(a2, b2) {
        var c2 = a2.entangledLanes |= b2;
        for (a2 = a2.entanglements; c2; ) {
          var d2 = 31 - oc(c2), e2 = 1 << d2;
          e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
          c2 &= ~e2;
        }
      }
      var C = 0;
      function Dc(a2) {
        a2 &= -a2;
        return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
      }
      var Ec;
      var Fc;
      var Gc;
      var Hc;
      var Ic;
      var Jc = false;
      var Kc = [];
      var Lc = null;
      var Mc = null;
      var Nc = null;
      var Oc = /* @__PURE__ */ new Map();
      var Pc = /* @__PURE__ */ new Map();
      var Qc = [];
      var Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function Sc(a2, b2) {
        switch (a2) {
          case "focusin":
          case "focusout":
            Lc = null;
            break;
          case "dragenter":
          case "dragleave":
            Mc = null;
            break;
          case "mouseover":
          case "mouseout":
            Nc = null;
            break;
          case "pointerover":
          case "pointerout":
            Oc.delete(b2.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            Pc.delete(b2.pointerId);
        }
      }
      function Tc(a2, b2, c2, d2, e2, f3) {
        if (null === a2 || a2.nativeEvent !== f3) return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f3, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
        a2.eventSystemFlags |= d2;
        b2 = a2.targetContainers;
        null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
        return a2;
      }
      function Uc(a2, b2, c2, d2, e2) {
        switch (b2) {
          case "focusin":
            return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
          case "dragenter":
            return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
          case "mouseover":
            return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
          case "pointerover":
            var f3 = e2.pointerId;
            Oc.set(f3, Tc(Oc.get(f3) || null, a2, b2, c2, d2, e2));
            return true;
          case "gotpointercapture":
            return f3 = e2.pointerId, Pc.set(f3, Tc(Pc.get(f3) || null, a2, b2, c2, d2, e2)), true;
        }
        return false;
      }
      function Vc(a2) {
        var b2 = Wc(a2.target);
        if (null !== b2) {
          var c2 = Vb(b2);
          if (null !== c2) {
            if (b2 = c2.tag, 13 === b2) {
              if (b2 = Wb(c2), null !== b2) {
                a2.blockedOn = b2;
                Ic(a2.priority, function() {
                  Gc(c2);
                });
                return;
              }
            } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
              a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
              return;
            }
          }
        }
        a2.blockedOn = null;
      }
      function Xc(a2) {
        if (null !== a2.blockedOn) return false;
        for (var b2 = a2.targetContainers; 0 < b2.length; ) {
          var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
          if (null === c2) {
            c2 = a2.nativeEvent;
            var d2 = new c2.constructor(c2.type, c2);
            wb = d2;
            c2.target.dispatchEvent(d2);
            wb = null;
          } else return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
          b2.shift();
        }
        return true;
      }
      function Zc(a2, b2, c2) {
        Xc(a2) && c2.delete(b2);
      }
      function $c() {
        Jc = false;
        null !== Lc && Xc(Lc) && (Lc = null);
        null !== Mc && Xc(Mc) && (Mc = null);
        null !== Nc && Xc(Nc) && (Nc = null);
        Oc.forEach(Zc);
        Pc.forEach(Zc);
      }
      function ad(a2, b2) {
        a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
      }
      function bd(a2) {
        function b2(b3) {
          return ad(b3, a2);
        }
        if (0 < Kc.length) {
          ad(Kc[0], a2);
          for (var c2 = 1; c2 < Kc.length; c2++) {
            var d2 = Kc[c2];
            d2.blockedOn === a2 && (d2.blockedOn = null);
          }
        }
        null !== Lc && ad(Lc, a2);
        null !== Mc && ad(Mc, a2);
        null !== Nc && ad(Nc, a2);
        Oc.forEach(b2);
        Pc.forEach(b2);
        for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
        for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
      }
      var cd = ua.ReactCurrentBatchConfig;
      var dd = true;
      function ed(a2, b2, c2, d2) {
        var e2 = C, f3 = cd.transition;
        cd.transition = null;
        try {
          C = 1, fd(a2, b2, c2, d2);
        } finally {
          C = e2, cd.transition = f3;
        }
      }
      function gd(a2, b2, c2, d2) {
        var e2 = C, f3 = cd.transition;
        cd.transition = null;
        try {
          C = 4, fd(a2, b2, c2, d2);
        } finally {
          C = e2, cd.transition = f3;
        }
      }
      function fd(a2, b2, c2, d2) {
        if (dd) {
          var e2 = Yc(a2, b2, c2, d2);
          if (null === e2) hd(a2, b2, d2, id3, c2), Sc(a2, d2);
          else if (Uc(e2, a2, b2, c2, d2)) d2.stopPropagation();
          else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
            for (; null !== e2; ) {
              var f3 = Cb(e2);
              null !== f3 && Ec(f3);
              f3 = Yc(a2, b2, c2, d2);
              null === f3 && hd(a2, b2, d2, id3, c2);
              if (f3 === e2) break;
              e2 = f3;
            }
            null !== e2 && d2.stopPropagation();
          } else hd(a2, b2, d2, null, c2);
        }
      }
      var id3 = null;
      function Yc(a2, b2, c2, d2) {
        id3 = null;
        a2 = xb(d2);
        a2 = Wc(a2);
        if (null !== a2) if (b2 = Vb(a2), null === b2) a2 = null;
        else if (c2 = b2.tag, 13 === c2) {
          a2 = Wb(b2);
          if (null !== a2) return a2;
          a2 = null;
        } else if (3 === c2) {
          if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
          a2 = null;
        } else b2 !== a2 && (a2 = null);
        id3 = a2;
        return null;
      }
      function jd(a2) {
        switch (a2) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (ec()) {
              case fc:
                return 1;
              case gc:
                return 4;
              case hc:
              case ic:
                return 16;
              case jc:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var kd = null;
      var ld = null;
      var md = null;
      function nd() {
        if (md) return md;
        var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f3 = e2.length;
        for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++) ;
        var g2 = c2 - a2;
        for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f3 - d2]; d2++) ;
        return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
      }
      function od(a2) {
        var b2 = a2.keyCode;
        "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
        10 === a2 && (a2 = 13);
        return 32 <= a2 || 13 === a2 ? a2 : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a2) {
        function b2(b3, d2, e2, f3, g2) {
          this._reactName = b3;
          this._targetInst = e2;
          this.type = d2;
          this.nativeEvent = f3;
          this.target = g2;
          this.currentTarget = null;
          for (var c2 in a2) a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f3) : f3[c2]);
          this.isDefaultPrevented = (null != f3.defaultPrevented ? f3.defaultPrevented : false === f3.returnValue) ? pd : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        A2(b2.prototype, { preventDefault: function() {
          this.defaultPrevented = true;
          var a3 = this.nativeEvent;
          a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
        }, stopPropagation: function() {
          var a3 = this.nativeEvent;
          a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
        }, persist: function() {
        }, isPersistent: pd });
        return b2;
      }
      var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
        return a2.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 };
      var td = rd(sd);
      var ud = A2({}, sd, { view: 0, detail: 0 });
      var vd = rd(ud);
      var wd;
      var xd;
      var yd;
      var Ad = A2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
        return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
      }, movementX: function(a2) {
        if ("movementX" in a2) return a2.movementX;
        a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
        return wd;
      }, movementY: function(a2) {
        return "movementY" in a2 ? a2.movementY : xd;
      } });
      var Bd = rd(Ad);
      var Cd = A2({}, Ad, { dataTransfer: 0 });
      var Dd = rd(Cd);
      var Ed = A2({}, ud, { relatedTarget: 0 });
      var Fd = rd(Ed);
      var Gd = A2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Hd = rd(Gd);
      var Id2 = A2({}, sd, { clipboardData: function(a2) {
        return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
      } });
      var Jd = rd(Id2);
      var Kd = A2({}, sd, { data: 0 });
      var Ld = rd(Kd);
      var Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function Pd(a2) {
        var b2 = this.nativeEvent;
        return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = A2({}, ud, { key: function(a2) {
        if (a2.key) {
          var b2 = Md[a2.key] || a2.key;
          if ("Unidentified" !== b2) return b2;
        }
        return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
        return "keypress" === a2.type ? od(a2) : 0;
      }, keyCode: function(a2) {
        return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
      }, which: function(a2) {
        return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
      } });
      var Rd = rd(Qd);
      var Sd = A2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
      var Td = rd(Sd);
      var Ud = A2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
      var Vd = rd(Ud);
      var Wd = A2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Xd = rd(Wd);
      var Yd = A2({}, Ad, {
        deltaX: function(a2) {
          return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
        },
        deltaY: function(a2) {
          return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var Zd = rd(Yd);
      var $d = [9, 13, 27, 32];
      var ae = ia && "CompositionEvent" in window;
      var be = null;
      ia && "documentMode" in document && (be = document.documentMode);
      var ce = ia && "TextEvent" in window && !be;
      var de = ia && (!ae || be && 8 < be && 11 >= be);
      var ee = String.fromCharCode(32);
      var fe = false;
      function ge(a2, b2) {
        switch (a2) {
          case "keyup":
            return -1 !== $d.indexOf(b2.keyCode);
          case "keydown":
            return 229 !== b2.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he(a2) {
        a2 = a2.detail;
        return "object" === typeof a2 && "data" in a2 ? a2.data : null;
      }
      var ie = false;
      function je(a2, b2) {
        switch (a2) {
          case "compositionend":
            return he(b2);
          case "keypress":
            if (32 !== b2.which) return null;
            fe = true;
            return ee;
          case "textInput":
            return a2 = b2.data, a2 === ee && fe ? null : a2;
          default:
            return null;
        }
      }
      function ke(a2, b2) {
        if (ie) return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
        switch (a2) {
          case "paste":
            return null;
          case "keypress":
            if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
              if (b2.char && 1 < b2.char.length) return b2.char;
              if (b2.which) return String.fromCharCode(b2.which);
            }
            return null;
          case "compositionend":
            return de && "ko" !== b2.locale ? null : b2.data;
          default:
            return null;
        }
      }
      var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
      function me(a2) {
        var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
        return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
      }
      function ne(a2, b2, c2, d2) {
        Eb(d2);
        b2 = oe(b2, "onChange");
        0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
      }
      var pe = null;
      var qe = null;
      function re(a2) {
        se(a2, 0);
      }
      function te(a2) {
        var b2 = ue(a2);
        if (Wa(b2)) return a2;
      }
      function ve(a2, b2) {
        if ("change" === a2) return b2;
      }
      var we = false;
      if (ia) {
        if (ia) {
          ye = "oninput" in document;
          if (!ye) {
            ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye = "function" === typeof ze.oninput;
          }
          xe = ye;
        } else xe = false;
        we = xe && (!document.documentMode || 9 < document.documentMode);
      }
      var xe;
      var ye;
      var ze;
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
      }
      function Be(a2) {
        if ("value" === a2.propertyName && te(qe)) {
          var b2 = [];
          ne(b2, qe, a2, xb(a2));
          Jb(re, b2);
        }
      }
      function Ce(a2, b2, c2) {
        "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
      }
      function De(a2) {
        if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te(qe);
      }
      function Ee(a2, b2) {
        if ("click" === a2) return te(b2);
      }
      function Fe(a2, b2) {
        if ("input" === a2 || "change" === a2) return te(b2);
      }
      function Ge(a2, b2) {
        return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      function Ie(a2, b2) {
        if (He(a2, b2)) return true;
        if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2) return false;
        var c2 = Object.keys(a2), d2 = Object.keys(b2);
        if (c2.length !== d2.length) return false;
        for (d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2];
          if (!ja.call(b2, e2) || !He(a2[e2], b2[e2])) return false;
        }
        return true;
      }
      function Je(a2) {
        for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
        return a2;
      }
      function Ke(a2, b2) {
        var c2 = Je(a2);
        a2 = 0;
        for (var d2; c2; ) {
          if (3 === c2.nodeType) {
            d2 = a2 + c2.textContent.length;
            if (a2 <= b2 && d2 >= b2) return { node: c2, offset: b2 - a2 };
            a2 = d2;
          }
          a: {
            for (; c2; ) {
              if (c2.nextSibling) {
                c2 = c2.nextSibling;
                break a;
              }
              c2 = c2.parentNode;
            }
            c2 = void 0;
          }
          c2 = Je(c2);
        }
      }
      function Le(a2, b2) {
        return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
      }
      function Me() {
        for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
          try {
            var c2 = "string" === typeof b2.contentWindow.location.href;
          } catch (d2) {
            c2 = false;
          }
          if (c2) a2 = b2.contentWindow;
          else break;
          b2 = Xa(a2.document);
        }
        return b2;
      }
      function Ne(a2) {
        var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
        return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
      }
      function Oe(a2) {
        var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
        if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
          if (null !== d2 && Ne(c2)) {
            if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
            else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
              a2 = a2.getSelection();
              var e2 = c2.textContent.length, f3 = Math.min(d2.start, e2);
              d2 = void 0 === d2.end ? f3 : Math.min(d2.end, e2);
              !a2.extend && f3 > d2 && (e2 = d2, d2 = f3, f3 = e2);
              e2 = Ke(c2, f3);
              var g2 = Ke(
                c2,
                d2
              );
              e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f3 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
            }
          }
          b2 = [];
          for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
          "function" === typeof c2.focus && c2.focus();
          for (c2 = 0; c2 < b2.length; c2++) a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
        }
      }
      var Pe = ia && "documentMode" in document && 11 >= document.documentMode;
      var Qe = null;
      var Re = null;
      var Se = null;
      var Te = false;
      function Ue(a2, b2, c2) {
        var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
        Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
      }
      function Ve(a2, b2) {
        var c2 = {};
        c2[a2.toLowerCase()] = b2.toLowerCase();
        c2["Webkit" + a2] = "webkit" + b2;
        c2["Moz" + a2] = "moz" + b2;
        return c2;
      }
      var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") };
      var Xe = {};
      var Ye = {};
      ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
      function Ze(a2) {
        if (Xe[a2]) return Xe[a2];
        if (!We[a2]) return a2;
        var b2 = We[a2], c2;
        for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye) return Xe[a2] = b2[c2];
        return a2;
      }
      var $e = Ze("animationend");
      var af = Ze("animationiteration");
      var bf = Ze("animationstart");
      var cf = Ze("transitionend");
      var df = /* @__PURE__ */ new Map();
      var ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
      function ff(a2, b2) {
        df.set(a2, b2);
        fa(b2, [a2]);
      }
      for (gf = 0; gf < ef.length; gf++) {
        hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf);
      }
      var hf;
      var jf;
      var kf;
      var gf;
      ff($e, "onAnimationEnd");
      ff(af, "onAnimationIteration");
      ff(bf, "onAnimationStart");
      ff("dblclick", "onDoubleClick");
      ff("focusin", "onFocus");
      ff("focusout", "onBlur");
      ff(cf, "onTransitionEnd");
      ha("onMouseEnter", ["mouseout", "mouseover"]);
      ha("onMouseLeave", ["mouseout", "mouseover"]);
      ha("onPointerEnter", ["pointerout", "pointerover"]);
      ha("onPointerLeave", ["pointerout", "pointerover"]);
      fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
      var mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
      function nf(a2, b2, c2) {
        var d2 = a2.type || "unknown-event";
        a2.currentTarget = c2;
        Ub(d2, b2, void 0, a2);
        a2.currentTarget = null;
      }
      function se(a2, b2) {
        b2 = 0 !== (b2 & 4);
        for (var c2 = 0; c2 < a2.length; c2++) {
          var d2 = a2[c2], e2 = d2.event;
          d2 = d2.listeners;
          a: {
            var f3 = void 0;
            if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
              var h2 = d2[g2], k = h2.instance, l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k !== f3 && e2.isPropagationStopped()) break a;
              nf(e2, h2, l2);
              f3 = k;
            }
            else for (g2 = 0; g2 < d2.length; g2++) {
              h2 = d2[g2];
              k = h2.instance;
              l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k !== f3 && e2.isPropagationStopped()) break a;
              nf(e2, h2, l2);
              f3 = k;
            }
          }
        }
        if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
      }
      function D(a2, b2) {
        var c2 = b2[of];
        void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
        var d2 = a2 + "__bubble";
        c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
      }
      function qf(a2, b2, c2) {
        var d2 = 0;
        b2 && (d2 |= 4);
        pf(c2, a2, d2, b2);
      }
      var rf = "_reactListening" + Math.random().toString(36).slice(2);
      function sf(a2) {
        if (!a2[rf]) {
          a2[rf] = true;
          da.forEach(function(b3) {
            "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
          });
          var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
          null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
        }
      }
      function pf(a2, b2, c2, d2) {
        switch (jd(b2)) {
          case 1:
            var e2 = ed;
            break;
          case 4:
            e2 = gd;
            break;
          default:
            e2 = fd;
        }
        c2 = e2.bind(null, b2, c2, a2);
        e2 = void 0;
        !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
        d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
      }
      function hd(a2, b2, c2, d2, e2) {
        var f3 = d2;
        if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
          if (null === d2) return;
          var g2 = d2.tag;
          if (3 === g2 || 4 === g2) {
            var h2 = d2.stateNode.containerInfo;
            if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
            if (4 === g2) for (g2 = d2.return; null !== g2; ) {
              var k = g2.tag;
              if (3 === k || 4 === k) {
                if (k = g2.stateNode.containerInfo, k === e2 || 8 === k.nodeType && k.parentNode === e2) return;
              }
              g2 = g2.return;
            }
            for (; null !== h2; ) {
              g2 = Wc(h2);
              if (null === g2) return;
              k = g2.tag;
              if (5 === k || 6 === k) {
                d2 = f3 = g2;
                continue a;
              }
              h2 = h2.parentNode;
            }
          }
          d2 = d2.return;
        }
        Jb(function() {
          var d3 = f3, e3 = xb(c2), g3 = [];
          a: {
            var h3 = df.get(a2);
            if (void 0 !== h3) {
              var k2 = td, n2 = a2;
              switch (a2) {
                case "keypress":
                  if (0 === od(c2)) break a;
                case "keydown":
                case "keyup":
                  k2 = Rd;
                  break;
                case "focusin":
                  n2 = "focus";
                  k2 = Fd;
                  break;
                case "focusout":
                  n2 = "blur";
                  k2 = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k2 = Fd;
                  break;
                case "click":
                  if (2 === c2.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k2 = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k2 = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k2 = Vd;
                  break;
                case $e:
                case af:
                case bf:
                  k2 = Hd;
                  break;
                case cf:
                  k2 = Xd;
                  break;
                case "scroll":
                  k2 = vd;
                  break;
                case "wheel":
                  k2 = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k2 = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k2 = Td;
              }
              var t2 = 0 !== (b2 & 4), J = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
              t2 = [];
              for (var w2 = d3, u2; null !== w2; ) {
                u2 = w2;
                var F = u2.stateNode;
                5 === u2.tag && null !== F && (u2 = F, null !== x2 && (F = Kb(w2, x2), null != F && t2.push(tf(w2, F, u2))));
                if (J) break;
                w2 = w2.return;
              }
              0 < t2.length && (h3 = new k2(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
            }
          }
          if (0 === (b2 & 7)) {
            a: {
              h3 = "mouseover" === a2 || "pointerover" === a2;
              k2 = "mouseout" === a2 || "pointerout" === a2;
              if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
              if (k2 || h3) {
                h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
                if (k2) {
                  if (n2 = c2.relatedTarget || c2.toElement, k2 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J = Vb(n2), n2 !== J || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
                } else k2 = null, n2 = d3;
                if (k2 !== n2) {
                  t2 = Bd;
                  F = "onMouseLeave";
                  x2 = "onMouseEnter";
                  w2 = "mouse";
                  if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
                  J = null == k2 ? h3 : ue(k2);
                  u2 = null == n2 ? h3 : ue(n2);
                  h3 = new t2(F, w2 + "leave", k2, c2, e3);
                  h3.target = J;
                  h3.relatedTarget = u2;
                  F = null;
                  Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J, F = t2);
                  J = F;
                  if (k2 && n2) b: {
                    t2 = k2;
                    x2 = n2;
                    w2 = 0;
                    for (u2 = t2; u2; u2 = vf(u2)) w2++;
                    u2 = 0;
                    for (F = x2; F; F = vf(F)) u2++;
                    for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
                    for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
                    for (; w2--; ) {
                      if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                      t2 = vf(t2);
                      x2 = vf(x2);
                    }
                    t2 = null;
                  }
                  else t2 = null;
                  null !== k2 && wf(g3, h3, k2, t2, false);
                  null !== n2 && null !== J && wf(g3, J, n2, t2, true);
                }
              }
            }
            a: {
              h3 = d3 ? ue(d3) : window;
              k2 = h3.nodeName && h3.nodeName.toLowerCase();
              if ("select" === k2 || "input" === k2 && "file" === h3.type) var na = ve;
              else if (me(h3)) if (we) na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
              else (k2 = h3.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
              if (na && (na = na(a2, d3))) {
                ne(g3, na, c2, e3);
                break a;
              }
              xa && xa(a2, h3, d3);
              "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
            }
            xa = d3 ? ue(d3) : window;
            switch (a2) {
              case "focusin":
                if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te = false;
                Ue(g3, c2, e3);
                break;
              case "selectionchange":
                if (Pe) break;
              case "keydown":
              case "keyup":
                Ue(g3, c2, e3);
            }
            var $a;
            if (ae) b: {
              switch (a2) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
            else ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
            ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
            if ($a = ce ? je(a2, c2) : ke(a2, c2)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
          }
          se(g3, b2);
        });
      }
      function tf(a2, b2, c2) {
        return { instance: a2, listener: b2, currentTarget: c2 };
      }
      function oe(a2, b2) {
        for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
          var e2 = a2, f3 = e2.stateNode;
          5 === e2.tag && null !== f3 && (e2 = f3, f3 = Kb(a2, c2), null != f3 && d2.unshift(tf(a2, f3, e2)), f3 = Kb(a2, b2), null != f3 && d2.push(tf(a2, f3, e2)));
          a2 = a2.return;
        }
        return d2;
      }
      function vf(a2) {
        if (null === a2) return null;
        do
          a2 = a2.return;
        while (a2 && 5 !== a2.tag);
        return a2 ? a2 : null;
      }
      function wf(a2, b2, c2, d2, e2) {
        for (var f3 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
          var h2 = c2, k = h2.alternate, l2 = h2.stateNode;
          if (null !== k && k === d2) break;
          5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k = Kb(c2, f3), null != k && g2.unshift(tf(c2, k, h2))) : e2 || (k = Kb(c2, f3), null != k && g2.push(tf(c2, k, h2))));
          c2 = c2.return;
        }
        0 !== g2.length && a2.push({ event: b2, listeners: g2 });
      }
      var xf = /\r\n?/g;
      var yf = /\u0000|\uFFFD/g;
      function zf(a2) {
        return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
      }
      function Af(a2, b2, c2) {
        b2 = zf(b2);
        if (zf(a2) !== b2 && c2) throw Error(p2(425));
      }
      function Bf() {
      }
      var Cf = null;
      var Df = null;
      function Ef(a2, b2) {
        return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
      }
      var Ff = "function" === typeof setTimeout ? setTimeout : void 0;
      var Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var Hf = "function" === typeof Promise ? Promise : void 0;
      var Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
        return Hf.resolve(null).then(a2).catch(If);
      } : Ff;
      function If(a2) {
        setTimeout(function() {
          throw a2;
        });
      }
      function Kf(a2, b2) {
        var c2 = b2, d2 = 0;
        do {
          var e2 = c2.nextSibling;
          a2.removeChild(c2);
          if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
            if (0 === d2) {
              a2.removeChild(e2);
              bd(b2);
              return;
            }
            d2--;
          } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
          c2 = e2;
        } while (c2);
        bd(b2);
      }
      function Lf(a2) {
        for (; null != a2; a2 = a2.nextSibling) {
          var b2 = a2.nodeType;
          if (1 === b2 || 3 === b2) break;
          if (8 === b2) {
            b2 = a2.data;
            if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
            if ("/$" === b2) return null;
          }
        }
        return a2;
      }
      function Mf(a2) {
        a2 = a2.previousSibling;
        for (var b2 = 0; a2; ) {
          if (8 === a2.nodeType) {
            var c2 = a2.data;
            if ("$" === c2 || "$!" === c2 || "$?" === c2) {
              if (0 === b2) return a2;
              b2--;
            } else "/$" === c2 && b2++;
          }
          a2 = a2.previousSibling;
        }
        return null;
      }
      var Nf = Math.random().toString(36).slice(2);
      var Of = "__reactFiber$" + Nf;
      var Pf = "__reactProps$" + Nf;
      var uf = "__reactContainer$" + Nf;
      var of = "__reactEvents$" + Nf;
      var Qf = "__reactListeners$" + Nf;
      var Rf = "__reactHandles$" + Nf;
      function Wc(a2) {
        var b2 = a2[Of];
        if (b2) return b2;
        for (var c2 = a2.parentNode; c2; ) {
          if (b2 = c2[uf] || c2[Of]) {
            c2 = b2.alternate;
            if (null !== b2.child || null !== c2 && null !== c2.child) for (a2 = Mf(a2); null !== a2; ) {
              if (c2 = a2[Of]) return c2;
              a2 = Mf(a2);
            }
            return b2;
          }
          a2 = c2;
          c2 = a2.parentNode;
        }
        return null;
      }
      function Cb(a2) {
        a2 = a2[Of] || a2[uf];
        return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
      }
      function ue(a2) {
        if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
        throw Error(p2(33));
      }
      function Db(a2) {
        return a2[Pf] || null;
      }
      var Sf = [];
      var Tf = -1;
      function Uf(a2) {
        return { current: a2 };
      }
      function E(a2) {
        0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
      }
      function G(a2, b2) {
        Tf++;
        Sf[Tf] = a2.current;
        a2.current = b2;
      }
      var Vf = {};
      var H = Uf(Vf);
      var Wf = Uf(false);
      var Xf = Vf;
      function Yf(a2, b2) {
        var c2 = a2.type.contextTypes;
        if (!c2) return Vf;
        var d2 = a2.stateNode;
        if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
        var e2 = {}, f3;
        for (f3 in c2) e2[f3] = b2[f3];
        d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
        return e2;
      }
      function Zf(a2) {
        a2 = a2.childContextTypes;
        return null !== a2 && void 0 !== a2;
      }
      function $f() {
        E(Wf);
        E(H);
      }
      function ag(a2, b2, c2) {
        if (H.current !== Vf) throw Error(p2(168));
        G(H, b2);
        G(Wf, c2);
      }
      function bg(a2, b2, c2) {
        var d2 = a2.stateNode;
        b2 = b2.childContextTypes;
        if ("function" !== typeof d2.getChildContext) return c2;
        d2 = d2.getChildContext();
        for (var e2 in d2) if (!(e2 in b2)) throw Error(p2(108, Ra(a2) || "Unknown", e2));
        return A2({}, c2, d2);
      }
      function cg(a2) {
        a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
        Xf = H.current;
        G(H, a2);
        G(Wf, Wf.current);
        return true;
      }
      function dg(a2, b2, c2) {
        var d2 = a2.stateNode;
        if (!d2) throw Error(p2(169));
        c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H), G(H, a2)) : E(Wf);
        G(Wf, c2);
      }
      var eg = null;
      var fg = false;
      var gg = false;
      function hg(a2) {
        null === eg ? eg = [a2] : eg.push(a2);
      }
      function ig(a2) {
        fg = true;
        hg(a2);
      }
      function jg() {
        if (!gg && null !== eg) {
          gg = true;
          var a2 = 0, b2 = C;
          try {
            var c2 = eg;
            for (C = 1; a2 < c2.length; a2++) {
              var d2 = c2[a2];
              do
                d2 = d2(true);
              while (null !== d2);
            }
            eg = null;
            fg = false;
          } catch (e2) {
            throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
          } finally {
            C = b2, gg = false;
          }
        }
        return null;
      }
      var kg = [];
      var lg = 0;
      var mg = null;
      var ng = 0;
      var og = [];
      var pg = 0;
      var qg = null;
      var rg = 1;
      var sg = "";
      function tg(a2, b2) {
        kg[lg++] = ng;
        kg[lg++] = mg;
        mg = a2;
        ng = b2;
      }
      function ug(a2, b2, c2) {
        og[pg++] = rg;
        og[pg++] = sg;
        og[pg++] = qg;
        qg = a2;
        var d2 = rg;
        a2 = sg;
        var e2 = 32 - oc(d2) - 1;
        d2 &= ~(1 << e2);
        c2 += 1;
        var f3 = 32 - oc(b2) + e2;
        if (30 < f3) {
          var g2 = e2 - e2 % 5;
          f3 = (d2 & (1 << g2) - 1).toString(32);
          d2 >>= g2;
          e2 -= g2;
          rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
          sg = f3 + a2;
        } else rg = 1 << f3 | c2 << e2 | d2, sg = a2;
      }
      function vg(a2) {
        null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
      }
      function wg(a2) {
        for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
        for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
      }
      var xg = null;
      var yg = null;
      var I = false;
      var zg = null;
      function Ag(a2, b2) {
        var c2 = Bg(5, null, null, 0);
        c2.elementType = "DELETED";
        c2.stateNode = b2;
        c2.return = a2;
        b2 = a2.deletions;
        null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
      }
      function Cg(a2, b2) {
        switch (a2.tag) {
          case 5:
            var c2 = a2.type;
            b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
            return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
          case 6:
            return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
          case 13:
            return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
          default:
            return false;
        }
      }
      function Dg(a2) {
        return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
      }
      function Eg(a2) {
        if (I) {
          var b2 = yg;
          if (b2) {
            var c2 = b2;
            if (!Cg(a2, b2)) {
              if (Dg(a2)) throw Error(p2(418));
              b2 = Lf(c2.nextSibling);
              var d2 = xg;
              b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
            }
          } else {
            if (Dg(a2)) throw Error(p2(418));
            a2.flags = a2.flags & -4097 | 2;
            I = false;
            xg = a2;
          }
        }
      }
      function Fg(a2) {
        for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
        xg = a2;
      }
      function Gg(a2) {
        if (a2 !== xg) return false;
        if (!I) return Fg(a2), I = true, false;
        var b2;
        (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
        if (b2 && (b2 = yg)) {
          if (Dg(a2)) throw Hg(), Error(p2(418));
          for (; b2; ) Ag(a2, b2), b2 = Lf(b2.nextSibling);
        }
        Fg(a2);
        if (13 === a2.tag) {
          a2 = a2.memoizedState;
          a2 = null !== a2 ? a2.dehydrated : null;
          if (!a2) throw Error(p2(317));
          a: {
            a2 = a2.nextSibling;
            for (b2 = 0; a2; ) {
              if (8 === a2.nodeType) {
                var c2 = a2.data;
                if ("/$" === c2) {
                  if (0 === b2) {
                    yg = Lf(a2.nextSibling);
                    break a;
                  }
                  b2--;
                } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
              }
              a2 = a2.nextSibling;
            }
            yg = null;
          }
        } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
        return true;
      }
      function Hg() {
        for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
      }
      function Ig() {
        yg = xg = null;
        I = false;
      }
      function Jg(a2) {
        null === zg ? zg = [a2] : zg.push(a2);
      }
      var Kg = ua.ReactCurrentBatchConfig;
      function Lg(a2, b2) {
        if (a2 && a2.defaultProps) {
          b2 = A2({}, b2);
          a2 = a2.defaultProps;
          for (var c2 in a2) void 0 === b2[c2] && (b2[c2] = a2[c2]);
          return b2;
        }
        return b2;
      }
      var Mg = Uf(null);
      var Ng = null;
      var Og = null;
      var Pg = null;
      function Qg() {
        Pg = Og = Ng = null;
      }
      function Rg(a2) {
        var b2 = Mg.current;
        E(Mg);
        a2._currentValue = b2;
      }
      function Sg(a2, b2, c2) {
        for (; null !== a2; ) {
          var d2 = a2.alternate;
          (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
          if (a2 === c2) break;
          a2 = a2.return;
        }
      }
      function Tg(a2, b2) {
        Ng = a2;
        Pg = Og = null;
        a2 = a2.dependencies;
        null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
      }
      function Vg(a2) {
        var b2 = a2._currentValue;
        if (Pg !== a2) if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
          if (null === Ng) throw Error(p2(308));
          Og = a2;
          Ng.dependencies = { lanes: 0, firstContext: a2 };
        } else Og = Og.next = a2;
        return b2;
      }
      var Wg = null;
      function Xg(a2) {
        null === Wg ? Wg = [a2] : Wg.push(a2);
      }
      function Yg(a2, b2, c2, d2) {
        var e2 = b2.interleaved;
        null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
        b2.interleaved = c2;
        return Zg(a2, d2);
      }
      function Zg(a2, b2) {
        a2.lanes |= b2;
        var c2 = a2.alternate;
        null !== c2 && (c2.lanes |= b2);
        c2 = a2;
        for (a2 = a2.return; null !== a2; ) a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
        return 3 === c2.tag ? c2.stateNode : null;
      }
      var $g = false;
      function ah(a2) {
        a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
      }
      function bh(a2, b2) {
        a2 = a2.updateQueue;
        b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
      }
      function ch(a2, b2) {
        return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
      }
      function dh(a2, b2, c2) {
        var d2 = a2.updateQueue;
        if (null === d2) return null;
        d2 = d2.shared;
        if (0 !== (K & 2)) {
          var e2 = d2.pending;
          null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
          d2.pending = b2;
          return Zg(a2, c2);
        }
        e2 = d2.interleaved;
        null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
        d2.interleaved = b2;
        return Zg(a2, c2);
      }
      function eh(a2, b2, c2) {
        b2 = b2.updateQueue;
        if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
          var d2 = b2.lanes;
          d2 &= a2.pendingLanes;
          c2 |= d2;
          b2.lanes = c2;
          Cc(a2, c2);
        }
      }
      function fh(a2, b2) {
        var c2 = a2.updateQueue, d2 = a2.alternate;
        if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
          var e2 = null, f3 = null;
          c2 = c2.firstBaseUpdate;
          if (null !== c2) {
            do {
              var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
              null === f3 ? e2 = f3 = g2 : f3 = f3.next = g2;
              c2 = c2.next;
            } while (null !== c2);
            null === f3 ? e2 = f3 = b2 : f3 = f3.next = b2;
          } else e2 = f3 = b2;
          c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f3, shared: d2.shared, effects: d2.effects };
          a2.updateQueue = c2;
          return;
        }
        a2 = c2.lastBaseUpdate;
        null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
        c2.lastBaseUpdate = b2;
      }
      function gh(a2, b2, c2, d2) {
        var e2 = a2.updateQueue;
        $g = false;
        var f3 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
        if (null !== h2) {
          e2.shared.pending = null;
          var k = h2, l2 = k.next;
          k.next = null;
          null === g2 ? f3 = l2 : g2.next = l2;
          g2 = k;
          var m2 = a2.alternate;
          null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k));
        }
        if (null !== f3) {
          var q = e2.baseState;
          g2 = 0;
          m2 = l2 = k = null;
          h2 = f3;
          do {
            var r3 = h2.lane, y2 = h2.eventTime;
            if ((d2 & r3) === r3) {
              null !== m2 && (m2 = m2.next = {
                eventTime: y2,
                lane: 0,
                tag: h2.tag,
                payload: h2.payload,
                callback: h2.callback,
                next: null
              });
              a: {
                var n2 = a2, t2 = h2;
                r3 = b2;
                y2 = c2;
                switch (t2.tag) {
                  case 1:
                    n2 = t2.payload;
                    if ("function" === typeof n2) {
                      q = n2.call(y2, q, r3);
                      break a;
                    }
                    q = n2;
                    break a;
                  case 3:
                    n2.flags = n2.flags & -65537 | 128;
                  case 0:
                    n2 = t2.payload;
                    r3 = "function" === typeof n2 ? n2.call(y2, q, r3) : n2;
                    if (null === r3 || void 0 === r3) break a;
                    q = A2({}, q, r3);
                    break a;
                  case 2:
                    $g = true;
                }
              }
              null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r3 = e2.effects, null === r3 ? e2.effects = [h2] : r3.push(h2));
            } else y2 = { eventTime: y2, lane: r3, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k = q) : m2 = m2.next = y2, g2 |= r3;
            h2 = h2.next;
            if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
            else r3 = h2, h2 = r3.next, r3.next = null, e2.lastBaseUpdate = r3, e2.shared.pending = null;
          } while (1);
          null === m2 && (k = q);
          e2.baseState = k;
          e2.firstBaseUpdate = l2;
          e2.lastBaseUpdate = m2;
          b2 = e2.shared.interleaved;
          if (null !== b2) {
            e2 = b2;
            do
              g2 |= e2.lane, e2 = e2.next;
            while (e2 !== b2);
          } else null === f3 && (e2.shared.lanes = 0);
          hh |= g2;
          a2.lanes = g2;
          a2.memoizedState = q;
        }
      }
      function ih(a2, b2, c2) {
        a2 = b2.effects;
        b2.effects = null;
        if (null !== a2) for (b2 = 0; b2 < a2.length; b2++) {
          var d2 = a2[b2], e2 = d2.callback;
          if (null !== e2) {
            d2.callback = null;
            d2 = c2;
            if ("function" !== typeof e2) throw Error(p2(191, e2));
            e2.call(d2);
          }
        }
      }
      var jh = new aa.Component().refs;
      function kh(a2, b2, c2, d2) {
        b2 = a2.memoizedState;
        c2 = c2(d2, b2);
        c2 = null === c2 || void 0 === c2 ? b2 : A2({}, b2, c2);
        a2.memoizedState = c2;
        0 === a2.lanes && (a2.updateQueue.baseState = c2);
      }
      var nh = { isMounted: function(a2) {
        return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
      }, enqueueSetState: function(a2, b2, c2) {
        a2 = a2._reactInternals;
        var d2 = L(), e2 = lh(a2), f3 = ch(d2, e2);
        f3.payload = b2;
        void 0 !== c2 && null !== c2 && (f3.callback = c2);
        b2 = dh(a2, f3, e2);
        null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
      }, enqueueReplaceState: function(a2, b2, c2) {
        a2 = a2._reactInternals;
        var d2 = L(), e2 = lh(a2), f3 = ch(d2, e2);
        f3.tag = 1;
        f3.payload = b2;
        void 0 !== c2 && null !== c2 && (f3.callback = c2);
        b2 = dh(a2, f3, e2);
        null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
      }, enqueueForceUpdate: function(a2, b2) {
        a2 = a2._reactInternals;
        var c2 = L(), d2 = lh(a2), e2 = ch(c2, d2);
        e2.tag = 2;
        void 0 !== b2 && null !== b2 && (e2.callback = b2);
        b2 = dh(a2, e2, d2);
        null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
      } };
      function oh(a2, b2, c2, d2, e2, f3, g2) {
        a2 = a2.stateNode;
        return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f3, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f3) : true;
      }
      function ph(a2, b2, c2) {
        var d2 = false, e2 = Vf;
        var f3 = b2.contextType;
        "object" === typeof f3 && null !== f3 ? f3 = Vg(f3) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f3 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
        b2 = new b2(c2, f3);
        a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
        b2.updater = nh;
        a2.stateNode = b2;
        b2._reactInternals = a2;
        d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f3);
        return b2;
      }
      function qh(a2, b2, c2, d2) {
        a2 = b2.state;
        "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
        "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
        b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
      }
      function rh(a2, b2, c2, d2) {
        var e2 = a2.stateNode;
        e2.props = c2;
        e2.state = a2.memoizedState;
        e2.refs = jh;
        ah(a2);
        var f3 = b2.contextType;
        "object" === typeof f3 && null !== f3 ? e2.context = Vg(f3) : (f3 = Zf(b2) ? Xf : H.current, e2.context = Yf(a2, f3));
        e2.state = a2.memoizedState;
        f3 = b2.getDerivedStateFromProps;
        "function" === typeof f3 && (kh(a2, b2, f3, c2), e2.state = a2.memoizedState);
        "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
        "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
      }
      function sh(a2, b2, c2) {
        a2 = c2.ref;
        if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
          if (c2._owner) {
            c2 = c2._owner;
            if (c2) {
              if (1 !== c2.tag) throw Error(p2(309));
              var d2 = c2.stateNode;
            }
            if (!d2) throw Error(p2(147, a2));
            var e2 = d2, f3 = "" + a2;
            if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f3) return b2.ref;
            b2 = function(a3) {
              var b3 = e2.refs;
              b3 === jh && (b3 = e2.refs = {});
              null === a3 ? delete b3[f3] : b3[f3] = a3;
            };
            b2._stringRef = f3;
            return b2;
          }
          if ("string" !== typeof a2) throw Error(p2(284));
          if (!c2._owner) throw Error(p2(290, a2));
        }
        return a2;
      }
      function th(a2, b2) {
        a2 = Object.prototype.toString.call(b2);
        throw Error(p2(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
      }
      function uh(a2) {
        var b2 = a2._init;
        return b2(a2._payload);
      }
      function vh2(a2) {
        function b2(b3, c3) {
          if (a2) {
            var d3 = b3.deletions;
            null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
          }
        }
        function c2(c3, d3) {
          if (!a2) return null;
          for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
          return null;
        }
        function d2(a3, b3) {
          for (a3 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
          return a3;
        }
        function e2(a3, b3) {
          a3 = wh(a3, b3);
          a3.index = 0;
          a3.sibling = null;
          return a3;
        }
        function f3(b3, c3, d3) {
          b3.index = d3;
          if (!a2) return b3.flags |= 1048576, c3;
          d3 = b3.alternate;
          if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
          b3.flags |= 2;
          return c3;
        }
        function g2(b3) {
          a2 && null === b3.alternate && (b3.flags |= 2);
          return b3;
        }
        function h2(a3, b3, c3, d3) {
          if (null === b3 || 6 !== b3.tag) return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
          b3 = e2(b3, c3);
          b3.return = a3;
          return b3;
        }
        function k(a3, b3, c3, d3) {
          var f4 = c3.type;
          if (f4 === ya) return m2(a3, b3, c3.props.children, d3, c3.key);
          if (null !== b3 && (b3.elementType === f4 || "object" === typeof f4 && null !== f4 && f4.$$typeof === Ha && uh(f4) === b3.type)) return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
          d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
          d3.ref = sh(a3, b3, c3);
          d3.return = a3;
          return d3;
        }
        function l2(a3, b3, c3, d3) {
          if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
          b3 = e2(b3, c3.children || []);
          b3.return = a3;
          return b3;
        }
        function m2(a3, b3, c3, d3, f4) {
          if (null === b3 || 7 !== b3.tag) return b3 = Ah(c3, a3.mode, d3, f4), b3.return = a3, b3;
          b3 = e2(b3, c3);
          b3.return = a3;
          return b3;
        }
        function q(a3, b3, c3) {
          if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
          if ("object" === typeof b3 && null !== b3) {
            switch (b3.$$typeof) {
              case va:
                return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
              case wa:
                return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
              case Ha:
                var d3 = b3._init;
                return q(a3, d3(b3._payload), c3);
            }
            if (eb(b3) || Ka(b3)) return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
            th(a3, b3);
          }
          return null;
        }
        function r3(a3, b3, c3, d3) {
          var e3 = null !== b3 ? b3.key : null;
          if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
          if ("object" === typeof c3 && null !== c3) {
            switch (c3.$$typeof) {
              case va:
                return c3.key === e3 ? k(a3, b3, c3, d3) : null;
              case wa:
                return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
              case Ha:
                return e3 = c3._init, r3(
                  a3,
                  b3,
                  e3(c3._payload),
                  d3
                );
            }
            if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a3, b3, c3, d3, null);
            th(a3, c3);
          }
          return null;
        }
        function y2(a3, b3, c3, d3, e3) {
          if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
          if ("object" === typeof d3 && null !== d3) {
            switch (d3.$$typeof) {
              case va:
                return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k(b3, a3, d3, e3);
              case wa:
                return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
              case Ha:
                var f4 = d3._init;
                return y2(a3, b3, c3, f4(d3._payload), e3);
            }
            if (eb(d3) || Ka(d3)) return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
            th(b3, d3);
          }
          return null;
        }
        function n2(e3, g3, h3, k2) {
          for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
            u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
            var n3 = r3(e3, u2, h3[w2], k2);
            if (null === n3) {
              null === u2 && (u2 = x2);
              break;
            }
            a2 && u2 && null === n3.alternate && b2(e3, u2);
            g3 = f3(n3, g3, w2);
            null === m3 ? l3 = n3 : m3.sibling = n3;
            m3 = n3;
            u2 = x2;
          }
          if (w2 === h3.length) return c2(e3, u2), I && tg(e3, w2), l3;
          if (null === u2) {
            for (; w2 < h3.length; w2++) u2 = q(e3, h3[w2], k2), null !== u2 && (g3 = f3(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
            I && tg(e3, w2);
            return l3;
          }
          for (u2 = d2(e3, u2); w2 < h3.length; w2++) x2 = y2(u2, e3, w2, h3[w2], k2), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f3(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
          a2 && u2.forEach(function(a3) {
            return b2(e3, a3);
          });
          I && tg(e3, w2);
          return l3;
        }
        function t2(e3, g3, h3, k2) {
          var l3 = Ka(h3);
          if ("function" !== typeof l3) throw Error(p2(150));
          h3 = l3.call(h3);
          if (null == h3) throw Error(p2(151));
          for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
            m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
            var t3 = r3(e3, m3, n3.value, k2);
            if (null === t3) {
              null === m3 && (m3 = x2);
              break;
            }
            a2 && m3 && null === t3.alternate && b2(e3, m3);
            g3 = f3(t3, g3, w2);
            null === u2 ? l3 = t3 : u2.sibling = t3;
            u2 = t3;
            m3 = x2;
          }
          if (n3.done) return c2(
            e3,
            m3
          ), I && tg(e3, w2), l3;
          if (null === m3) {
            for (; !n3.done; w2++, n3 = h3.next()) n3 = q(e3, n3.value, k2), null !== n3 && (g3 = f3(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
            I && tg(e3, w2);
            return l3;
          }
          for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e3, w2, n3.value, k2), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f3(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
          a2 && m3.forEach(function(a3) {
            return b2(e3, a3);
          });
          I && tg(e3, w2);
          return l3;
        }
        function J(a3, d3, f4, h3) {
          "object" === typeof f4 && null !== f4 && f4.type === ya && null === f4.key && (f4 = f4.props.children);
          if ("object" === typeof f4 && null !== f4) {
            switch (f4.$$typeof) {
              case va:
                a: {
                  for (var k2 = f4.key, l3 = d3; null !== l3; ) {
                    if (l3.key === k2) {
                      k2 = f4.type;
                      if (k2 === ya) {
                        if (7 === l3.tag) {
                          c2(a3, l3.sibling);
                          d3 = e2(l3, f4.props.children);
                          d3.return = a3;
                          a3 = d3;
                          break a;
                        }
                      } else if (l3.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && uh(k2) === l3.type) {
                        c2(a3, l3.sibling);
                        d3 = e2(l3, f4.props);
                        d3.ref = sh(a3, l3, f4);
                        d3.return = a3;
                        a3 = d3;
                        break a;
                      }
                      c2(a3, l3);
                      break;
                    } else b2(a3, l3);
                    l3 = l3.sibling;
                  }
                  f4.type === ya ? (d3 = Ah(f4.props.children, a3.mode, h3, f4.key), d3.return = a3, a3 = d3) : (h3 = yh(f4.type, f4.key, f4.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f4), h3.return = a3, a3 = h3);
                }
                return g2(a3);
              case wa:
                a: {
                  for (l3 = f4.key; null !== d3; ) {
                    if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f4.containerInfo && d3.stateNode.implementation === f4.implementation) {
                      c2(a3, d3.sibling);
                      d3 = e2(d3, f4.children || []);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    } else {
                      c2(a3, d3);
                      break;
                    }
                    else b2(a3, d3);
                    d3 = d3.sibling;
                  }
                  d3 = zh(f4, a3.mode, h3);
                  d3.return = a3;
                  a3 = d3;
                }
                return g2(a3);
              case Ha:
                return l3 = f4._init, J(a3, d3, l3(f4._payload), h3);
            }
            if (eb(f4)) return n2(a3, d3, f4, h3);
            if (Ka(f4)) return t2(a3, d3, f4, h3);
            th(a3, f4);
          }
          return "string" === typeof f4 && "" !== f4 || "number" === typeof f4 ? (f4 = "" + f4, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f4), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f4, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
        }
        return J;
      }
      var Bh = vh2(true);
      var Ch = vh2(false);
      var Dh = {};
      var Eh = Uf(Dh);
      var Fh = Uf(Dh);
      var Gh = Uf(Dh);
      function Hh(a2) {
        if (a2 === Dh) throw Error(p2(174));
        return a2;
      }
      function Ih(a2, b2) {
        G(Gh, b2);
        G(Fh, a2);
        G(Eh, Dh);
        a2 = b2.nodeType;
        switch (a2) {
          case 9:
          case 11:
            b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
            break;
          default:
            a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
        }
        E(Eh);
        G(Eh, b2);
      }
      function Jh() {
        E(Eh);
        E(Fh);
        E(Gh);
      }
      function Kh(a2) {
        Hh(Gh.current);
        var b2 = Hh(Eh.current);
        var c2 = lb(b2, a2.type);
        b2 !== c2 && (G(Fh, a2), G(Eh, c2));
      }
      function Lh(a2) {
        Fh.current === a2 && (E(Eh), E(Fh));
      }
      var M = Uf(0);
      function Mh(a2) {
        for (var b2 = a2; null !== b2; ) {
          if (13 === b2.tag) {
            var c2 = b2.memoizedState;
            if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
          } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
            if (0 !== (b2.flags & 128)) return b2;
          } else if (null !== b2.child) {
            b2.child.return = b2;
            b2 = b2.child;
            continue;
          }
          if (b2 === a2) break;
          for (; null === b2.sibling; ) {
            if (null === b2.return || b2.return === a2) return null;
            b2 = b2.return;
          }
          b2.sibling.return = b2.return;
          b2 = b2.sibling;
        }
        return null;
      }
      var Nh = [];
      function Oh() {
        for (var a2 = 0; a2 < Nh.length; a2++) Nh[a2]._workInProgressVersionPrimary = null;
        Nh.length = 0;
      }
      var Ph = ua.ReactCurrentDispatcher;
      var Qh = ua.ReactCurrentBatchConfig;
      var Rh = 0;
      var N = null;
      var O2 = null;
      var P2 = null;
      var Sh = false;
      var Th = false;
      var Uh = 0;
      var Vh = 0;
      function Q() {
        throw Error(p2(321));
      }
      function Wh(a2, b2) {
        if (null === b2) return false;
        for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++) if (!He(a2[c2], b2[c2])) return false;
        return true;
      }
      function Xh(a2, b2, c2, d2, e2, f3) {
        Rh = f3;
        N = b2;
        b2.memoizedState = null;
        b2.updateQueue = null;
        b2.lanes = 0;
        Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
        a2 = c2(d2, e2);
        if (Th) {
          f3 = 0;
          do {
            Th = false;
            Uh = 0;
            if (25 <= f3) throw Error(p2(301));
            f3 += 1;
            P2 = O2 = null;
            b2.updateQueue = null;
            Ph.current = $h;
            a2 = c2(d2, e2);
          } while (Th);
        }
        Ph.current = ai;
        b2 = null !== O2 && null !== O2.next;
        Rh = 0;
        P2 = O2 = N = null;
        Sh = false;
        if (b2) throw Error(p2(300));
        return a2;
      }
      function bi() {
        var a2 = 0 !== Uh;
        Uh = 0;
        return a2;
      }
      function ci() {
        var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        null === P2 ? N.memoizedState = P2 = a2 : P2 = P2.next = a2;
        return P2;
      }
      function di() {
        if (null === O2) {
          var a2 = N.alternate;
          a2 = null !== a2 ? a2.memoizedState : null;
        } else a2 = O2.next;
        var b2 = null === P2 ? N.memoizedState : P2.next;
        if (null !== b2) P2 = b2, O2 = a2;
        else {
          if (null === a2) throw Error(p2(310));
          O2 = a2;
          a2 = { memoizedState: O2.memoizedState, baseState: O2.baseState, baseQueue: O2.baseQueue, queue: O2.queue, next: null };
          null === P2 ? N.memoizedState = P2 = a2 : P2 = P2.next = a2;
        }
        return P2;
      }
      function ei(a2, b2) {
        return "function" === typeof b2 ? b2(a2) : b2;
      }
      function fi(a2) {
        var b2 = di(), c2 = b2.queue;
        if (null === c2) throw Error(p2(311));
        c2.lastRenderedReducer = a2;
        var d2 = O2, e2 = d2.baseQueue, f3 = c2.pending;
        if (null !== f3) {
          if (null !== e2) {
            var g2 = e2.next;
            e2.next = f3.next;
            f3.next = g2;
          }
          d2.baseQueue = e2 = f3;
          c2.pending = null;
        }
        if (null !== e2) {
          f3 = e2.next;
          d2 = d2.baseState;
          var h2 = g2 = null, k = null, l2 = f3;
          do {
            var m2 = l2.lane;
            if ((Rh & m2) === m2) null !== k && (k = k.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
            else {
              var q = {
                lane: m2,
                action: l2.action,
                hasEagerState: l2.hasEagerState,
                eagerState: l2.eagerState,
                next: null
              };
              null === k ? (h2 = k = q, g2 = d2) : k = k.next = q;
              N.lanes |= m2;
              hh |= m2;
            }
            l2 = l2.next;
          } while (null !== l2 && l2 !== f3);
          null === k ? g2 = d2 : k.next = h2;
          He(d2, b2.memoizedState) || (Ug = true);
          b2.memoizedState = d2;
          b2.baseState = g2;
          b2.baseQueue = k;
          c2.lastRenderedState = d2;
        }
        a2 = c2.interleaved;
        if (null !== a2) {
          e2 = a2;
          do
            f3 = e2.lane, N.lanes |= f3, hh |= f3, e2 = e2.next;
          while (e2 !== a2);
        } else null === e2 && (c2.lanes = 0);
        return [b2.memoizedState, c2.dispatch];
      }
      function gi(a2) {
        var b2 = di(), c2 = b2.queue;
        if (null === c2) throw Error(p2(311));
        c2.lastRenderedReducer = a2;
        var d2 = c2.dispatch, e2 = c2.pending, f3 = b2.memoizedState;
        if (null !== e2) {
          c2.pending = null;
          var g2 = e2 = e2.next;
          do
            f3 = a2(f3, g2.action), g2 = g2.next;
          while (g2 !== e2);
          He(f3, b2.memoizedState) || (Ug = true);
          b2.memoizedState = f3;
          null === b2.baseQueue && (b2.baseState = f3);
          c2.lastRenderedState = f3;
        }
        return [f3, d2];
      }
      function hi() {
      }
      function ii(a2, b2) {
        var c2 = N, d2 = di(), e2 = b2(), f3 = !He(d2.memoizedState, e2);
        f3 && (d2.memoizedState = e2, Ug = true);
        d2 = d2.queue;
        ji(ki.bind(null, c2, d2, a2), [a2]);
        if (d2.getSnapshot !== b2 || f3 || null !== P2 && P2.memoizedState.tag & 1) {
          c2.flags |= 2048;
          li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
          if (null === R) throw Error(p2(349));
          0 !== (Rh & 30) || ni(c2, b2, e2);
        }
        return e2;
      }
      function ni(a2, b2, c2) {
        a2.flags |= 16384;
        a2 = { getSnapshot: b2, value: c2 };
        b2 = N.updateQueue;
        null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
      }
      function mi(a2, b2, c2, d2) {
        b2.value = c2;
        b2.getSnapshot = d2;
        oi(b2) && pi(a2);
      }
      function ki(a2, b2, c2) {
        return c2(function() {
          oi(b2) && pi(a2);
        });
      }
      function oi(a2) {
        var b2 = a2.getSnapshot;
        a2 = a2.value;
        try {
          var c2 = b2();
          return !He(a2, c2);
        } catch (d2) {
          return true;
        }
      }
      function pi(a2) {
        var b2 = Zg(a2, 1);
        null !== b2 && mh(b2, a2, 1, -1);
      }
      function qi(a2) {
        var b2 = ci();
        "function" === typeof a2 && (a2 = a2());
        b2.memoizedState = b2.baseState = a2;
        a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
        b2.queue = a2;
        a2 = a2.dispatch = ri.bind(null, N, a2);
        return [b2.memoizedState, a2];
      }
      function li(a2, b2, c2, d2) {
        a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
        b2 = N.updateQueue;
        null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
        return a2;
      }
      function si() {
        return di().memoizedState;
      }
      function ti(a2, b2, c2, d2) {
        var e2 = ci();
        N.flags |= a2;
        e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
      }
      function ui(a2, b2, c2, d2) {
        var e2 = di();
        d2 = void 0 === d2 ? null : d2;
        var f3 = void 0;
        if (null !== O2) {
          var g2 = O2.memoizedState;
          f3 = g2.destroy;
          if (null !== d2 && Wh(d2, g2.deps)) {
            e2.memoizedState = li(b2, c2, f3, d2);
            return;
          }
        }
        N.flags |= a2;
        e2.memoizedState = li(1 | b2, c2, f3, d2);
      }
      function vi(a2, b2) {
        return ti(8390656, 8, a2, b2);
      }
      function ji(a2, b2) {
        return ui(2048, 8, a2, b2);
      }
      function wi(a2, b2) {
        return ui(4, 2, a2, b2);
      }
      function xi(a2, b2) {
        return ui(4, 4, a2, b2);
      }
      function yi(a2, b2) {
        if ("function" === typeof b2) return a2 = a2(), b2(a2), function() {
          b2(null);
        };
        if (null !== b2 && void 0 !== b2) return a2 = a2(), b2.current = a2, function() {
          b2.current = null;
        };
      }
      function zi(a2, b2, c2) {
        c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
        return ui(4, 4, yi.bind(null, b2, a2), c2);
      }
      function Ai() {
      }
      function Bi(a2, b2) {
        var c2 = di();
        b2 = void 0 === b2 ? null : b2;
        var d2 = c2.memoizedState;
        if (null !== d2 && null !== b2 && Wh(b2, d2[1])) return d2[0];
        c2.memoizedState = [a2, b2];
        return a2;
      }
      function Ci(a2, b2) {
        var c2 = di();
        b2 = void 0 === b2 ? null : b2;
        var d2 = c2.memoizedState;
        if (null !== d2 && null !== b2 && Wh(b2, d2[1])) return d2[0];
        a2 = a2();
        c2.memoizedState = [a2, b2];
        return a2;
      }
      function Di(a2, b2, c2) {
        if (0 === (Rh & 21)) return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
        He(c2, b2) || (c2 = yc(), N.lanes |= c2, hh |= c2, a2.baseState = true);
        return b2;
      }
      function Ei(a2, b2) {
        var c2 = C;
        C = 0 !== c2 && 4 > c2 ? c2 : 4;
        a2(true);
        var d2 = Qh.transition;
        Qh.transition = {};
        try {
          a2(false), b2();
        } finally {
          C = c2, Qh.transition = d2;
        }
      }
      function Fi() {
        return di().memoizedState;
      }
      function Gi(a2, b2, c2) {
        var d2 = lh(a2);
        c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
        if (Hi(a2)) Ii(b2, c2);
        else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
          var e2 = L();
          mh(c2, a2, d2, e2);
          Ji(c2, b2, d2);
        }
      }
      function ri(a2, b2, c2) {
        var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
        if (Hi(a2)) Ii(b2, e2);
        else {
          var f3 = a2.alternate;
          if (0 === a2.lanes && (null === f3 || 0 === f3.lanes) && (f3 = b2.lastRenderedReducer, null !== f3)) try {
            var g2 = b2.lastRenderedState, h2 = f3(g2, c2);
            e2.hasEagerState = true;
            e2.eagerState = h2;
            if (He(h2, g2)) {
              var k = b2.interleaved;
              null === k ? (e2.next = e2, Xg(b2)) : (e2.next = k.next, k.next = e2);
              b2.interleaved = e2;
              return;
            }
          } catch (l2) {
          } finally {
          }
          c2 = Yg(a2, b2, e2, d2);
          null !== c2 && (e2 = L(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
        }
      }
      function Hi(a2) {
        var b2 = a2.alternate;
        return a2 === N || null !== b2 && b2 === N;
      }
      function Ii(a2, b2) {
        Th = Sh = true;
        var c2 = a2.pending;
        null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
        a2.pending = b2;
      }
      function Ji(a2, b2, c2) {
        if (0 !== (c2 & 4194240)) {
          var d2 = b2.lanes;
          d2 &= a2.pendingLanes;
          c2 |= d2;
          b2.lanes = c2;
          Cc(a2, c2);
        }
      }
      var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false };
      var Yh = { readContext: Vg, useCallback: function(a2, b2) {
        ci().memoizedState = [a2, void 0 === b2 ? null : b2];
        return a2;
      }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
        c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
        return ti(
          4194308,
          4,
          yi.bind(null, b2, a2),
          c2
        );
      }, useLayoutEffect: function(a2, b2) {
        return ti(4194308, 4, a2, b2);
      }, useInsertionEffect: function(a2, b2) {
        return ti(4, 2, a2, b2);
      }, useMemo: function(a2, b2) {
        var c2 = ci();
        b2 = void 0 === b2 ? null : b2;
        a2 = a2();
        c2.memoizedState = [a2, b2];
        return a2;
      }, useReducer: function(a2, b2, c2) {
        var d2 = ci();
        b2 = void 0 !== c2 ? c2(b2) : b2;
        d2.memoizedState = d2.baseState = b2;
        a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
        d2.queue = a2;
        a2 = a2.dispatch = Gi.bind(null, N, a2);
        return [d2.memoizedState, a2];
      }, useRef: function(a2) {
        var b2 = ci();
        a2 = { current: a2 };
        return b2.memoizedState = a2;
      }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
        return ci().memoizedState = a2;
      }, useTransition: function() {
        var a2 = qi(false), b2 = a2[0];
        a2 = Ei.bind(null, a2[1]);
        ci().memoizedState = a2;
        return [b2, a2];
      }, useMutableSource: function() {
      }, useSyncExternalStore: function(a2, b2, c2) {
        var d2 = N, e2 = ci();
        if (I) {
          if (void 0 === c2) throw Error(p2(407));
          c2 = c2();
        } else {
          c2 = b2();
          if (null === R) throw Error(p2(349));
          0 !== (Rh & 30) || ni(d2, b2, c2);
        }
        e2.memoizedState = c2;
        var f3 = { value: c2, getSnapshot: b2 };
        e2.queue = f3;
        vi(ki.bind(
          null,
          d2,
          f3,
          a2
        ), [a2]);
        d2.flags |= 2048;
        li(9, mi.bind(null, d2, f3, c2, b2), void 0, null);
        return c2;
      }, useId: function() {
        var a2 = ci(), b2 = R.identifierPrefix;
        if (I) {
          var c2 = sg;
          var d2 = rg;
          c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
          b2 = ":" + b2 + "R" + c2;
          c2 = Uh++;
          0 < c2 && (b2 += "H" + c2.toString(32));
          b2 += ":";
        } else c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
        return a2.memoizedState = b2;
      }, unstable_isNewReconciler: false };
      var Zh = {
        readContext: Vg,
        useCallback: Bi,
        useContext: Vg,
        useEffect: ji,
        useImperativeHandle: zi,
        useInsertionEffect: wi,
        useLayoutEffect: xi,
        useMemo: Ci,
        useReducer: fi,
        useRef: si,
        useState: function() {
          return fi(ei);
        },
        useDebugValue: Ai,
        useDeferredValue: function(a2) {
          var b2 = di();
          return Di(b2, O2.memoizedState, a2);
        },
        useTransition: function() {
          var a2 = fi(ei)[0], b2 = di().memoizedState;
          return [a2, b2];
        },
        useMutableSource: hi,
        useSyncExternalStore: ii,
        useId: Fi,
        unstable_isNewReconciler: false
      };
      var $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
        return gi(ei);
      }, useDebugValue: Ai, useDeferredValue: function(a2) {
        var b2 = di();
        return null === O2 ? b2.memoizedState = a2 : Di(b2, O2.memoizedState, a2);
      }, useTransition: function() {
        var a2 = gi(ei)[0], b2 = di().memoizedState;
        return [a2, b2];
      }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
      function Ki(a2, b2) {
        try {
          var c2 = "", d2 = b2;
          do
            c2 += Pa(d2), d2 = d2.return;
          while (d2);
          var e2 = c2;
        } catch (f3) {
          e2 = "\nError generating stack: " + f3.message + "\n" + f3.stack;
        }
        return { value: a2, source: b2, stack: e2, digest: null };
      }
      function Li(a2, b2, c2) {
        return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
      }
      function Mi(a2, b2) {
        try {
          console.error(b2.value);
        } catch (c2) {
          setTimeout(function() {
            throw c2;
          });
        }
      }
      var Ni = "function" === typeof WeakMap ? WeakMap : Map;
      function Oi(a2, b2, c2) {
        c2 = ch(-1, c2);
        c2.tag = 3;
        c2.payload = { element: null };
        var d2 = b2.value;
        c2.callback = function() {
          Pi2 || (Pi2 = true, Qi = d2);
          Mi(a2, b2);
        };
        return c2;
      }
      function Ri(a2, b2, c2) {
        c2 = ch(-1, c2);
        c2.tag = 3;
        var d2 = a2.type.getDerivedStateFromError;
        if ("function" === typeof d2) {
          var e2 = b2.value;
          c2.payload = function() {
            return d2(e2);
          };
          c2.callback = function() {
            Mi(a2, b2);
          };
        }
        var f3 = a2.stateNode;
        null !== f3 && "function" === typeof f3.componentDidCatch && (c2.callback = function() {
          Mi(a2, b2);
          "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
          var c3 = b2.stack;
          this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
        });
        return c2;
      }
      function Ti(a2, b2, c2) {
        var d2 = a2.pingCache;
        if (null === d2) {
          d2 = a2.pingCache = new Ni();
          var e2 = /* @__PURE__ */ new Set();
          d2.set(b2, e2);
        } else e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
        e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
      }
      function Vi(a2) {
        do {
          var b2;
          if (b2 = 13 === a2.tag) b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
          if (b2) return a2;
          a2 = a2.return;
        } while (null !== a2);
        return null;
      }
      function Wi(a2, b2, c2, d2, e2) {
        if (0 === (a2.mode & 1)) return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
        a2.flags |= 65536;
        a2.lanes = e2;
        return a2;
      }
      var Xi = ua.ReactCurrentOwner;
      var Ug = false;
      function Yi(a2, b2, c2, d2) {
        b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
      }
      function Zi(a2, b2, c2, d2, e2) {
        c2 = c2.render;
        var f3 = b2.ref;
        Tg(b2, e2);
        d2 = Xh(a2, b2, c2, d2, f3, e2);
        c2 = bi();
        if (null !== a2 && !Ug) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
        I && c2 && vg(b2);
        b2.flags |= 1;
        Yi(a2, b2, d2, e2);
        return b2.child;
      }
      function aj(a2, b2, c2, d2, e2) {
        if (null === a2) {
          var f3 = c2.type;
          if ("function" === typeof f3 && !bj(f3) && void 0 === f3.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f3, cj(a2, b2, f3, d2, e2);
          a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
          a2.ref = b2.ref;
          a2.return = b2;
          return b2.child = a2;
        }
        f3 = a2.child;
        if (0 === (a2.lanes & e2)) {
          var g2 = f3.memoizedProps;
          c2 = c2.compare;
          c2 = null !== c2 ? c2 : Ie;
          if (c2(g2, d2) && a2.ref === b2.ref) return $i(a2, b2, e2);
        }
        b2.flags |= 1;
        a2 = wh(f3, d2);
        a2.ref = b2.ref;
        a2.return = b2;
        return b2.child = a2;
      }
      function cj(a2, b2, c2, d2, e2) {
        if (null !== a2) {
          var f3 = a2.memoizedProps;
          if (Ie(f3, d2) && a2.ref === b2.ref) if (Ug = false, b2.pendingProps = d2 = f3, 0 !== (a2.lanes & e2)) 0 !== (a2.flags & 131072) && (Ug = true);
          else return b2.lanes = a2.lanes, $i(a2, b2, e2);
        }
        return dj(a2, b2, c2, d2, e2);
      }
      function ej(a2, b2, c2) {
        var d2 = b2.pendingProps, e2 = d2.children, f3 = null !== a2 ? a2.memoizedState : null;
        if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c2;
        else {
          if (0 === (c2 & 1073741824)) return a2 = null !== f3 ? f3.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G(fj, gj), gj |= a2, null;
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d2 = null !== f3 ? f3.baseLanes : c2;
          G(fj, gj);
          gj |= d2;
        }
        else null !== f3 ? (d2 = f3.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(fj, gj), gj |= d2;
        Yi(a2, b2, e2, c2);
        return b2.child;
      }
      function hj(a2, b2) {
        var c2 = b2.ref;
        if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
      }
      function dj(a2, b2, c2, d2, e2) {
        var f3 = Zf(c2) ? Xf : H.current;
        f3 = Yf(b2, f3);
        Tg(b2, e2);
        c2 = Xh(a2, b2, c2, d2, f3, e2);
        d2 = bi();
        if (null !== a2 && !Ug) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
        I && d2 && vg(b2);
        b2.flags |= 1;
        Yi(a2, b2, c2, e2);
        return b2.child;
      }
      function ij(a2, b2, c2, d2, e2) {
        if (Zf(c2)) {
          var f3 = true;
          cg(b2);
        } else f3 = false;
        Tg(b2, e2);
        if (null === b2.stateNode) jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
        else if (null === a2) {
          var g2 = b2.stateNode, h2 = b2.memoizedProps;
          g2.props = h2;
          var k = g2.context, l2 = c2.contextType;
          "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
          var m2 = c2.getDerivedStateFromProps, q = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
          q || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k !== l2) && qh(b2, g2, d2, l2);
          $g = false;
          var r3 = b2.memoizedState;
          g2.state = r3;
          gh(b2, d2, g2, e2);
          k = b2.memoizedState;
          h2 !== d2 || r3 !== k || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r3, k, l2)) ? (q || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k), g2.props = d2, g2.state = k, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
        } else {
          g2 = b2.stateNode;
          bh(a2, b2);
          h2 = b2.memoizedProps;
          l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
          g2.props = l2;
          q = b2.pendingProps;
          r3 = g2.context;
          k = c2.contextType;
          "object" === typeof k && null !== k ? k = Vg(k) : (k = Zf(c2) ? Xf : H.current, k = Yf(b2, k));
          var y2 = c2.getDerivedStateFromProps;
          (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q || r3 !== k) && qh(b2, g2, d2, k);
          $g = false;
          r3 = b2.memoizedState;
          g2.state = r3;
          gh(b2, d2, g2, e2);
          var n2 = b2.memoizedState;
          h2 !== q || r3 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r3, n2, k) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r3 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r3 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r3 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r3 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
        }
        return kj(a2, b2, c2, d2, f3, e2);
      }
      function kj(a2, b2, c2, d2, e2, f3) {
        hj(a2, b2);
        var g2 = 0 !== (b2.flags & 128);
        if (!d2 && !g2) return e2 && dg(b2, c2, false), $i(a2, b2, f3);
        d2 = b2.stateNode;
        Xi.current = b2;
        var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
        b2.flags |= 1;
        null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f3), b2.child = Bh(b2, null, h2, f3)) : Yi(a2, b2, h2, f3);
        b2.memoizedState = d2.state;
        e2 && dg(b2, c2, true);
        return b2.child;
      }
      function lj(a2) {
        var b2 = a2.stateNode;
        b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
        Ih(a2, b2.containerInfo);
      }
      function mj(a2, b2, c2, d2, e2) {
        Ig();
        Jg(e2);
        b2.flags |= 256;
        Yi(a2, b2, c2, d2);
        return b2.child;
      }
      var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
      function oj(a2) {
        return { baseLanes: a2, cachePool: null, transitions: null };
      }
      function pj(a2, b2, c2) {
        var d2 = b2.pendingProps, e2 = M.current, f3 = false, g2 = 0 !== (b2.flags & 128), h2;
        (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
        if (h2) f3 = true, b2.flags &= -129;
        else if (null === a2 || null !== a2.memoizedState) e2 |= 1;
        G(M, e2 & 1);
        if (null === a2) {
          Eg(b2);
          a2 = b2.memoizedState;
          if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
          g2 = d2.children;
          a2 = d2.fallback;
          return f3 ? (d2 = b2.mode, f3 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f3 ? (f3.childLanes = 0, f3.pendingProps = g2) : f3 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f3.return = b2, a2.return = b2, f3.sibling = a2, b2.child = f3, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
        }
        e2 = a2.memoizedState;
        if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return sj(a2, b2, g2, d2, h2, e2, c2);
        if (f3) {
          f3 = d2.fallback;
          g2 = b2.mode;
          e2 = a2.child;
          h2 = e2.sibling;
          var k = { mode: "hidden", children: d2.children };
          0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k, b2.deletions = null) : (d2 = wh(e2, k), d2.subtreeFlags = e2.subtreeFlags & 14680064);
          null !== h2 ? f3 = wh(h2, f3) : (f3 = Ah(f3, g2, c2, null), f3.flags |= 2);
          f3.return = b2;
          d2.return = b2;
          d2.sibling = f3;
          b2.child = d2;
          d2 = f3;
          f3 = b2.child;
          g2 = a2.child.memoizedState;
          g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
          f3.memoizedState = g2;
          f3.childLanes = a2.childLanes & ~c2;
          b2.memoizedState = nj;
          return d2;
        }
        f3 = a2.child;
        a2 = f3.sibling;
        d2 = wh(f3, { mode: "visible", children: d2.children });
        0 === (b2.mode & 1) && (d2.lanes = c2);
        d2.return = b2;
        d2.sibling = null;
        null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
        b2.child = d2;
        b2.memoizedState = null;
        return d2;
      }
      function rj(a2, b2) {
        b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
        b2.return = a2;
        return a2.child = b2;
      }
      function tj(a2, b2, c2, d2) {
        null !== d2 && Jg(d2);
        Bh(b2, a2.child, null, c2);
        a2 = rj(b2, b2.pendingProps.children);
        a2.flags |= 2;
        b2.memoizedState = null;
        return a2;
      }
      function sj(a2, b2, c2, d2, e2, f3, g2) {
        if (c2) {
          if (b2.flags & 256) return b2.flags &= -257, d2 = Li(Error(p2(422))), tj(a2, b2, g2, d2);
          if (null !== b2.memoizedState) return b2.child = a2.child, b2.flags |= 128, null;
          f3 = d2.fallback;
          e2 = b2.mode;
          d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
          f3 = Ah(f3, e2, g2, null);
          f3.flags |= 2;
          d2.return = b2;
          f3.return = b2;
          d2.sibling = f3;
          b2.child = d2;
          0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
          b2.child.memoizedState = oj(g2);
          b2.memoizedState = nj;
          return f3;
        }
        if (0 === (b2.mode & 1)) return tj(a2, b2, g2, null);
        if ("$!" === e2.data) {
          d2 = e2.nextSibling && e2.nextSibling.dataset;
          if (d2) var h2 = d2.dgst;
          d2 = h2;
          f3 = Error(p2(419));
          d2 = Li(f3, d2, void 0);
          return tj(a2, b2, g2, d2);
        }
        h2 = 0 !== (g2 & a2.childLanes);
        if (Ug || h2) {
          d2 = R;
          if (null !== d2) {
            switch (g2 & -g2) {
              case 4:
                e2 = 2;
                break;
              case 16:
                e2 = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e2 = 32;
                break;
              case 536870912:
                e2 = 268435456;
                break;
              default:
                e2 = 0;
            }
            e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
            0 !== e2 && e2 !== f3.retryLane && (f3.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
          }
          uj();
          d2 = Li(Error(p2(421)));
          return tj(a2, b2, g2, d2);
        }
        if ("$?" === e2.data) return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
        a2 = f3.treeContext;
        yg = Lf(e2.nextSibling);
        xg = b2;
        I = true;
        zg = null;
        null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
        b2 = rj(b2, d2.children);
        b2.flags |= 4096;
        return b2;
      }
      function wj(a2, b2, c2) {
        a2.lanes |= b2;
        var d2 = a2.alternate;
        null !== d2 && (d2.lanes |= b2);
        Sg(a2.return, b2, c2);
      }
      function xj(a2, b2, c2, d2, e2) {
        var f3 = a2.memoizedState;
        null === f3 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f3.isBackwards = b2, f3.rendering = null, f3.renderingStartTime = 0, f3.last = d2, f3.tail = c2, f3.tailMode = e2);
      }
      function yj(a2, b2, c2) {
        var d2 = b2.pendingProps, e2 = d2.revealOrder, f3 = d2.tail;
        Yi(a2, b2, d2.children, c2);
        d2 = M.current;
        if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
        else {
          if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b2.child; null !== a2; ) {
            if (13 === a2.tag) null !== a2.memoizedState && wj(a2, c2, b2);
            else if (19 === a2.tag) wj(a2, c2, b2);
            else if (null !== a2.child) {
              a2.child.return = a2;
              a2 = a2.child;
              continue;
            }
            if (a2 === b2) break a;
            for (; null === a2.sibling; ) {
              if (null === a2.return || a2.return === b2) break a;
              a2 = a2.return;
            }
            a2.sibling.return = a2.return;
            a2 = a2.sibling;
          }
          d2 &= 1;
        }
        G(M, d2);
        if (0 === (b2.mode & 1)) b2.memoizedState = null;
        else switch (e2) {
          case "forwards":
            c2 = b2.child;
            for (e2 = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
            c2 = e2;
            null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
            xj(b2, false, e2, c2, f3);
            break;
          case "backwards":
            c2 = null;
            e2 = b2.child;
            for (b2.child = null; null !== e2; ) {
              a2 = e2.alternate;
              if (null !== a2 && null === Mh(a2)) {
                b2.child = e2;
                break;
              }
              a2 = e2.sibling;
              e2.sibling = c2;
              c2 = e2;
              e2 = a2;
            }
            xj(b2, true, c2, null, f3);
            break;
          case "together":
            xj(b2, false, null, null, void 0);
            break;
          default:
            b2.memoizedState = null;
        }
        return b2.child;
      }
      function jj(a2, b2) {
        0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
      }
      function $i(a2, b2, c2) {
        null !== a2 && (b2.dependencies = a2.dependencies);
        hh |= b2.lanes;
        if (0 === (c2 & b2.childLanes)) return null;
        if (null !== a2 && b2.child !== a2.child) throw Error(p2(153));
        if (null !== b2.child) {
          a2 = b2.child;
          c2 = wh(a2, a2.pendingProps);
          b2.child = c2;
          for (c2.return = b2; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
          c2.sibling = null;
        }
        return b2.child;
      }
      function zj(a2, b2, c2) {
        switch (b2.tag) {
          case 3:
            lj(b2);
            Ig();
            break;
          case 5:
            Kh(b2);
            break;
          case 1:
            Zf(b2.type) && cg(b2);
            break;
          case 4:
            Ih(b2, b2.stateNode.containerInfo);
            break;
          case 10:
            var d2 = b2.type._context, e2 = b2.memoizedProps.value;
            G(Mg, d2._currentValue);
            d2._currentValue = e2;
            break;
          case 13:
            d2 = b2.memoizedState;
            if (null !== d2) {
              if (null !== d2.dehydrated) return G(M, M.current & 1), b2.flags |= 128, null;
              if (0 !== (c2 & b2.child.childLanes)) return pj(a2, b2, c2);
              G(M, M.current & 1);
              a2 = $i(a2, b2, c2);
              return null !== a2 ? a2.sibling : null;
            }
            G(M, M.current & 1);
            break;
          case 19:
            d2 = 0 !== (c2 & b2.childLanes);
            if (0 !== (a2.flags & 128)) {
              if (d2) return yj(a2, b2, c2);
              b2.flags |= 128;
            }
            e2 = b2.memoizedState;
            null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
            G(M, M.current);
            if (d2) break;
            else return null;
          case 22:
          case 23:
            return b2.lanes = 0, ej(a2, b2, c2);
        }
        return $i(a2, b2, c2);
      }
      var Aj;
      var Bj;
      var Cj;
      var Dj;
      Aj = function(a2, b2) {
        for (var c2 = b2.child; null !== c2; ) {
          if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
          else if (4 !== c2.tag && null !== c2.child) {
            c2.child.return = c2;
            c2 = c2.child;
            continue;
          }
          if (c2 === b2) break;
          for (; null === c2.sibling; ) {
            if (null === c2.return || c2.return === b2) return;
            c2 = c2.return;
          }
          c2.sibling.return = c2.return;
          c2 = c2.sibling;
        }
      };
      Bj = function() {
      };
      Cj = function(a2, b2, c2, d2) {
        var e2 = a2.memoizedProps;
        if (e2 !== d2) {
          a2 = b2.stateNode;
          Hh(Eh.current);
          var f3 = null;
          switch (c2) {
            case "input":
              e2 = Ya(a2, e2);
              d2 = Ya(a2, d2);
              f3 = [];
              break;
            case "select":
              e2 = A2({}, e2, { value: void 0 });
              d2 = A2({}, d2, { value: void 0 });
              f3 = [];
              break;
            case "textarea":
              e2 = gb(a2, e2);
              d2 = gb(a2, d2);
              f3 = [];
              break;
            default:
              "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
          }
          ub(c2, d2);
          var g2;
          c2 = null;
          for (l2 in e2) if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
            var h2 = e2[l2];
            for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
          } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f3 || (f3 = []) : (f3 = f3 || []).push(l2, null));
          for (l2 in d2) {
            var k = d2[l2];
            h2 = null != e2 ? e2[l2] : void 0;
            if (d2.hasOwnProperty(l2) && k !== h2 && (null != k || null != h2)) if ("style" === l2) if (h2) {
              for (g2 in h2) !h2.hasOwnProperty(g2) || k && k.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
              for (g2 in k) k.hasOwnProperty(g2) && h2[g2] !== k[g2] && (c2 || (c2 = {}), c2[g2] = k[g2]);
            } else c2 || (f3 || (f3 = []), f3.push(
              l2,
              c2
            )), c2 = k;
            else "dangerouslySetInnerHTML" === l2 ? (k = k ? k.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k && h2 !== k && (f3 = f3 || []).push(l2, k)) : "children" === l2 ? "string" !== typeof k && "number" !== typeof k || (f3 = f3 || []).push(l2, "" + k) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k && "onScroll" === l2 && D("scroll", a2), f3 || h2 === k || (f3 = [])) : (f3 = f3 || []).push(l2, k));
          }
          c2 && (f3 = f3 || []).push("style", c2);
          var l2 = f3;
          if (b2.updateQueue = l2) b2.flags |= 4;
        }
      };
      Dj = function(a2, b2, c2, d2) {
        c2 !== d2 && (b2.flags |= 4);
      };
      function Ej(a2, b2) {
        if (!I) switch (a2.tailMode) {
          case "hidden":
            b2 = a2.tail;
            for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
            null === c2 ? a2.tail = null : c2.sibling = null;
            break;
          case "collapsed":
            c2 = a2.tail;
            for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
            null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
        }
      }
      function S2(a2) {
        var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
        if (b2) for (var e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
        else for (e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
        a2.subtreeFlags |= d2;
        a2.childLanes = c2;
        return b2;
      }
      function Fj(a2, b2, c2) {
        var d2 = b2.pendingProps;
        wg(b2);
        switch (b2.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return S2(b2), null;
          case 1:
            return Zf(b2.type) && $f(), S2(b2), null;
          case 3:
            d2 = b2.stateNode;
            Jh();
            E(Wf);
            E(H);
            Oh();
            d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
            if (null === a2 || null === a2.child) Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
            Bj(a2, b2);
            S2(b2);
            return null;
          case 5:
            Lh(b2);
            var e2 = Hh(Gh.current);
            c2 = b2.type;
            if (null !== a2 && null != b2.stateNode) Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
            else {
              if (!d2) {
                if (null === b2.stateNode) throw Error(p2(166));
                S2(b2);
                return null;
              }
              a2 = Hh(Eh.current);
              if (Gg(b2)) {
                d2 = b2.stateNode;
                c2 = b2.type;
                var f3 = b2.memoizedProps;
                d2[Of] = b2;
                d2[Pf] = f3;
                a2 = 0 !== (b2.mode & 1);
                switch (c2) {
                  case "dialog":
                    D("cancel", d2);
                    D("close", d2);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", d2);
                    break;
                  case "video":
                  case "audio":
                    for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], d2);
                    break;
                  case "source":
                    D("error", d2);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      d2
                    );
                    D("load", d2);
                    break;
                  case "details":
                    D("toggle", d2);
                    break;
                  case "input":
                    Za(d2, f3);
                    D("invalid", d2);
                    break;
                  case "select":
                    d2._wrapperState = { wasMultiple: !!f3.multiple };
                    D("invalid", d2);
                    break;
                  case "textarea":
                    hb(d2, f3), D("invalid", d2);
                }
                ub(c2, f3);
                e2 = null;
                for (var g2 in f3) if (f3.hasOwnProperty(g2)) {
                  var h2 = f3[g2];
                  "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f3.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f3.suppressHydrationWarning && Af(
                    d2.textContent,
                    h2,
                    a2
                  ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
                }
                switch (c2) {
                  case "input":
                    Va(d2);
                    db(d2, f3, true);
                    break;
                  case "textarea":
                    Va(d2);
                    jb(d2);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f3.onClick && (d2.onclick = Bf);
                }
                d2 = e2;
                b2.updateQueue = d2;
                null !== d2 && (b2.flags |= 4);
              } else {
                g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
                "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
                "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script></script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
                a2[Of] = b2;
                a2[Pf] = d2;
                Aj(a2, b2, false, false);
                b2.stateNode = a2;
                a: {
                  g2 = vb(c2, d2);
                  switch (c2) {
                    case "dialog":
                      D("cancel", a2);
                      D("close", a2);
                      e2 = d2;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D("load", a2);
                      e2 = d2;
                      break;
                    case "video":
                    case "audio":
                      for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], a2);
                      e2 = d2;
                      break;
                    case "source":
                      D("error", a2);
                      e2 = d2;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D(
                        "error",
                        a2
                      );
                      D("load", a2);
                      e2 = d2;
                      break;
                    case "details":
                      D("toggle", a2);
                      e2 = d2;
                      break;
                    case "input":
                      Za(a2, d2);
                      e2 = Ya(a2, d2);
                      D("invalid", a2);
                      break;
                    case "option":
                      e2 = d2;
                      break;
                    case "select":
                      a2._wrapperState = { wasMultiple: !!d2.multiple };
                      e2 = A2({}, d2, { value: void 0 });
                      D("invalid", a2);
                      break;
                    case "textarea":
                      hb(a2, d2);
                      e2 = gb(a2, d2);
                      D("invalid", a2);
                      break;
                    default:
                      e2 = d2;
                  }
                  ub(c2, e2);
                  h2 = e2;
                  for (f3 in h2) if (h2.hasOwnProperty(f3)) {
                    var k = h2[f3];
                    "style" === f3 ? sb(a2, k) : "dangerouslySetInnerHTML" === f3 ? (k = k ? k.__html : void 0, null != k && nb(a2, k)) : "children" === f3 ? "string" === typeof k ? ("textarea" !== c2 || "" !== k) && ob(a2, k) : "number" === typeof k && ob(a2, "" + k) : "suppressContentEditableWarning" !== f3 && "suppressHydrationWarning" !== f3 && "autoFocus" !== f3 && (ea.hasOwnProperty(f3) ? null != k && "onScroll" === f3 && D("scroll", a2) : null != k && ta(a2, f3, k, g2));
                  }
                  switch (c2) {
                    case "input":
                      Va(a2);
                      db(a2, d2, false);
                      break;
                    case "textarea":
                      Va(a2);
                      jb(a2);
                      break;
                    case "option":
                      null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                      break;
                    case "select":
                      a2.multiple = !!d2.multiple;
                      f3 = d2.value;
                      null != f3 ? fb(a2, !!d2.multiple, f3, false) : null != d2.defaultValue && fb(
                        a2,
                        !!d2.multiple,
                        d2.defaultValue,
                        true
                      );
                      break;
                    default:
                      "function" === typeof e2.onClick && (a2.onclick = Bf);
                  }
                  switch (c2) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      d2 = !!d2.autoFocus;
                      break a;
                    case "img":
                      d2 = true;
                      break a;
                    default:
                      d2 = false;
                  }
                }
                d2 && (b2.flags |= 4);
              }
              null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
            }
            S2(b2);
            return null;
          case 6:
            if (a2 && null != b2.stateNode) Dj(a2, b2, a2.memoizedProps, d2);
            else {
              if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p2(166));
              c2 = Hh(Gh.current);
              Hh(Eh.current);
              if (Gg(b2)) {
                d2 = b2.stateNode;
                c2 = b2.memoizedProps;
                d2[Of] = b2;
                if (f3 = d2.nodeValue !== c2) {
                  if (a2 = xg, null !== a2) switch (a2.tag) {
                    case 3:
                      Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                      break;
                    case 5:
                      true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  }
                }
                f3 && (b2.flags |= 4);
              } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
            }
            S2(b2);
            return null;
          case 13:
            E(M);
            d2 = b2.memoizedState;
            if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
              if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f3 = false;
              else if (f3 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
                if (null === a2) {
                  if (!f3) throw Error(p2(318));
                  f3 = b2.memoizedState;
                  f3 = null !== f3 ? f3.dehydrated : null;
                  if (!f3) throw Error(p2(317));
                  f3[Of] = b2;
                } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
                S2(b2);
                f3 = false;
              } else null !== zg && (Gj(zg), zg = null), f3 = true;
              if (!f3) return b2.flags & 65536 ? b2 : null;
            }
            if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
            d2 = null !== d2;
            d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
            null !== b2.updateQueue && (b2.flags |= 4);
            S2(b2);
            return null;
          case 4:
            return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S2(b2), null;
          case 10:
            return Rg(b2.type._context), S2(b2), null;
          case 17:
            return Zf(b2.type) && $f(), S2(b2), null;
          case 19:
            E(M);
            f3 = b2.memoizedState;
            if (null === f3) return S2(b2), null;
            d2 = 0 !== (b2.flags & 128);
            g2 = f3.rendering;
            if (null === g2) if (d2) Ej(f3, false);
            else {
              if (0 !== T || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b2.child; null !== a2; ) {
                g2 = Mh(a2);
                if (null !== g2) {
                  b2.flags |= 128;
                  Ej(f3, false);
                  d2 = g2.updateQueue;
                  null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                  b2.subtreeFlags = 0;
                  d2 = c2;
                  for (c2 = b2.child; null !== c2; ) f3 = c2, a2 = d2, f3.flags &= 14680066, g2 = f3.alternate, null === g2 ? (f3.childLanes = 0, f3.lanes = a2, f3.child = null, f3.subtreeFlags = 0, f3.memoizedProps = null, f3.memoizedState = null, f3.updateQueue = null, f3.dependencies = null, f3.stateNode = null) : (f3.childLanes = g2.childLanes, f3.lanes = g2.lanes, f3.child = g2.child, f3.subtreeFlags = 0, f3.deletions = null, f3.memoizedProps = g2.memoizedProps, f3.memoizedState = g2.memoizedState, f3.updateQueue = g2.updateQueue, f3.type = g2.type, a2 = g2.dependencies, f3.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                  G(M, M.current & 1 | 2);
                  return b2.child;
                }
                a2 = a2.sibling;
              }
              null !== f3.tail && B() > Hj && (b2.flags |= 128, d2 = true, Ej(f3, false), b2.lanes = 4194304);
            }
            else {
              if (!d2) if (a2 = Mh(g2), null !== a2) {
                if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f3, true), null === f3.tail && "hidden" === f3.tailMode && !g2.alternate && !I) return S2(b2), null;
              } else 2 * B() - f3.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f3, false), b2.lanes = 4194304);
              f3.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f3.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f3.last = g2);
            }
            if (null !== f3.tail) return b2 = f3.tail, f3.rendering = b2, f3.tail = b2.sibling, f3.renderingStartTime = B(), b2.sibling = null, c2 = M.current, G(M, d2 ? c2 & 1 | 2 : c2 & 1), b2;
            S2(b2);
            return null;
          case 22:
          case 23:
            return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S2(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S2(b2), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(p2(156, b2.tag));
      }
      function Jj(a2, b2) {
        wg(b2);
        switch (b2.tag) {
          case 1:
            return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
          case 3:
            return Jh(), E(Wf), E(H), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
          case 5:
            return Lh(b2), null;
          case 13:
            E(M);
            a2 = b2.memoizedState;
            if (null !== a2 && null !== a2.dehydrated) {
              if (null === b2.alternate) throw Error(p2(340));
              Ig();
            }
            a2 = b2.flags;
            return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
          case 19:
            return E(M), null;
          case 4:
            return Jh(), null;
          case 10:
            return Rg(b2.type._context), null;
          case 22:
          case 23:
            return Ij(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Kj = false;
      var U = false;
      var Lj = "function" === typeof WeakSet ? WeakSet : Set;
      var V = null;
      function Mj(a2, b2) {
        var c2 = a2.ref;
        if (null !== c2) if ("function" === typeof c2) try {
          c2(null);
        } catch (d2) {
          W(a2, b2, d2);
        }
        else c2.current = null;
      }
      function Nj(a2, b2, c2) {
        try {
          c2();
        } catch (d2) {
          W(a2, b2, d2);
        }
      }
      var Oj = false;
      function Pj(a2, b2) {
        Cf = dd;
        a2 = Me();
        if (Ne(a2)) {
          if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
          else a: {
            c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
            var d2 = c2.getSelection && c2.getSelection();
            if (d2 && 0 !== d2.rangeCount) {
              c2 = d2.anchorNode;
              var e2 = d2.anchorOffset, f3 = d2.focusNode;
              d2 = d2.focusOffset;
              try {
                c2.nodeType, f3.nodeType;
              } catch (F) {
                c2 = null;
                break a;
              }
              var g2 = 0, h2 = -1, k = -1, l2 = 0, m2 = 0, q = a2, r3 = null;
              b: for (; ; ) {
                for (var y2; ; ) {
                  q !== c2 || 0 !== e2 && 3 !== q.nodeType || (h2 = g2 + e2);
                  q !== f3 || 0 !== d2 && 3 !== q.nodeType || (k = g2 + d2);
                  3 === q.nodeType && (g2 += q.nodeValue.length);
                  if (null === (y2 = q.firstChild)) break;
                  r3 = q;
                  q = y2;
                }
                for (; ; ) {
                  if (q === a2) break b;
                  r3 === c2 && ++l2 === e2 && (h2 = g2);
                  r3 === f3 && ++m2 === d2 && (k = g2);
                  if (null !== (y2 = q.nextSibling)) break;
                  q = r3;
                  r3 = q.parentNode;
                }
                q = y2;
              }
              c2 = -1 === h2 || -1 === k ? null : { start: h2, end: k };
            } else c2 = null;
          }
          c2 = c2 || { start: 0, end: 0 };
        } else c2 = null;
        Df = { focusedElem: a2, selectionRange: c2 };
        dd = false;
        for (V = b2; null !== V; ) if (b2 = V, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2) a2.return = b2, V = a2;
        else for (; null !== V; ) {
          b2 = V;
          try {
            var n2 = b2.alternate;
            if (0 !== (b2.flags & 1024)) switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p2(163));
            }
          } catch (F) {
            W(b2, b2.return, F);
          }
          a2 = b2.sibling;
          if (null !== a2) {
            a2.return = b2.return;
            V = a2;
            break;
          }
          V = b2.return;
        }
        n2 = Oj;
        Oj = false;
        return n2;
      }
      function Qj(a2, b2, c2) {
        var d2 = b2.updateQueue;
        d2 = null !== d2 ? d2.lastEffect : null;
        if (null !== d2) {
          var e2 = d2 = d2.next;
          do {
            if ((e2.tag & a2) === a2) {
              var f3 = e2.destroy;
              e2.destroy = void 0;
              void 0 !== f3 && Nj(b2, c2, f3);
            }
            e2 = e2.next;
          } while (e2 !== d2);
        }
      }
      function Rj(a2, b2) {
        b2 = b2.updateQueue;
        b2 = null !== b2 ? b2.lastEffect : null;
        if (null !== b2) {
          var c2 = b2 = b2.next;
          do {
            if ((c2.tag & a2) === a2) {
              var d2 = c2.create;
              c2.destroy = d2();
            }
            c2 = c2.next;
          } while (c2 !== b2);
        }
      }
      function Sj(a2) {
        var b2 = a2.ref;
        if (null !== b2) {
          var c2 = a2.stateNode;
          switch (a2.tag) {
            case 5:
              a2 = c2;
              break;
            default:
              a2 = c2;
          }
          "function" === typeof b2 ? b2(a2) : b2.current = a2;
        }
      }
      function Tj(a2) {
        var b2 = a2.alternate;
        null !== b2 && (a2.alternate = null, Tj(b2));
        a2.child = null;
        a2.deletions = null;
        a2.sibling = null;
        5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
        a2.stateNode = null;
        a2.return = null;
        a2.dependencies = null;
        a2.memoizedProps = null;
        a2.memoizedState = null;
        a2.pendingProps = null;
        a2.stateNode = null;
        a2.updateQueue = null;
      }
      function Uj(a2) {
        return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
      }
      function Vj(a2) {
        a: for (; ; ) {
          for (; null === a2.sibling; ) {
            if (null === a2.return || Uj(a2.return)) return null;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
            if (a2.flags & 2) continue a;
            if (null === a2.child || 4 === a2.tag) continue a;
            else a2.child.return = a2, a2 = a2.child;
          }
          if (!(a2.flags & 2)) return a2.stateNode;
        }
      }
      function Wj(a2, b2, c2) {
        var d2 = a2.tag;
        if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
        else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b2, c2), a2 = a2.sibling;
      }
      function Xj(a2, b2, c2) {
        var d2 = a2.tag;
        if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
        else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Xj(a2, b2, c2), a2 = a2.sibling;
      }
      var X = null;
      var Yj = false;
      function Zj(a2, b2, c2) {
        for (c2 = c2.child; null !== c2; ) ak(a2, b2, c2), c2 = c2.sibling;
      }
      function ak(a2, b2, c2) {
        if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
          lc.onCommitFiberUnmount(kc, c2);
        } catch (h2) {
        }
        switch (c2.tag) {
          case 5:
            U || Mj(c2, b2);
          case 6:
            var d2 = X, e2 = Yj;
            X = null;
            Zj(a2, b2, c2);
            X = d2;
            Yj = e2;
            null !== X && (Yj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X.removeChild(c2.stateNode));
            break;
          case 18:
            null !== X && (Yj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X, c2.stateNode));
            break;
          case 4:
            d2 = X;
            e2 = Yj;
            X = c2.stateNode.containerInfo;
            Yj = true;
            Zj(a2, b2, c2);
            X = d2;
            Yj = e2;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
              e2 = d2 = d2.next;
              do {
                var f3 = e2, g2 = f3.destroy;
                f3 = f3.tag;
                void 0 !== g2 && (0 !== (f3 & 2) ? Nj(c2, b2, g2) : 0 !== (f3 & 4) && Nj(c2, b2, g2));
                e2 = e2.next;
              } while (e2 !== d2);
            }
            Zj(a2, b2, c2);
            break;
          case 1:
            if (!U && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
              d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
            } catch (h2) {
              W(c2, b2, h2);
            }
            Zj(a2, b2, c2);
            break;
          case 21:
            Zj(a2, b2, c2);
            break;
          case 22:
            c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Zj(a2, b2, c2), U = d2) : Zj(a2, b2, c2);
            break;
          default:
            Zj(a2, b2, c2);
        }
      }
      function bk(a2) {
        var b2 = a2.updateQueue;
        if (null !== b2) {
          a2.updateQueue = null;
          var c2 = a2.stateNode;
          null === c2 && (c2 = a2.stateNode = new Lj());
          b2.forEach(function(b3) {
            var d2 = ck.bind(null, a2, b3);
            c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
          });
        }
      }
      function dk(a2, b2) {
        var c2 = b2.deletions;
        if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2];
          try {
            var f3 = a2, g2 = b2, h2 = g2;
            a: for (; null !== h2; ) {
              switch (h2.tag) {
                case 5:
                  X = h2.stateNode;
                  Yj = false;
                  break a;
                case 3:
                  X = h2.stateNode.containerInfo;
                  Yj = true;
                  break a;
                case 4:
                  X = h2.stateNode.containerInfo;
                  Yj = true;
                  break a;
              }
              h2 = h2.return;
            }
            if (null === X) throw Error(p2(160));
            ak(f3, g2, e2);
            X = null;
            Yj = false;
            var k = e2.alternate;
            null !== k && (k.return = null);
            e2.return = null;
          } catch (l2) {
            W(e2, b2, l2);
          }
        }
        if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) ek(b2, a2), b2 = b2.sibling;
      }
      function ek(a2, b2) {
        var c2 = a2.alternate, d2 = a2.flags;
        switch (a2.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            dk(b2, a2);
            fk(a2);
            if (d2 & 4) {
              try {
                Qj(3, a2, a2.return), Rj(3, a2);
              } catch (t2) {
                W(a2, a2.return, t2);
              }
              try {
                Qj(5, a2, a2.return);
              } catch (t2) {
                W(a2, a2.return, t2);
              }
            }
            break;
          case 1:
            dk(b2, a2);
            fk(a2);
            d2 & 512 && null !== c2 && Mj(c2, c2.return);
            break;
          case 5:
            dk(b2, a2);
            fk(a2);
            d2 & 512 && null !== c2 && Mj(c2, c2.return);
            if (a2.flags & 32) {
              var e2 = a2.stateNode;
              try {
                ob(e2, "");
              } catch (t2) {
                W(a2, a2.return, t2);
              }
            }
            if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
              var f3 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f3, h2 = a2.type, k = a2.updateQueue;
              a2.updateQueue = null;
              if (null !== k) try {
                "input" === h2 && "radio" === f3.type && null != f3.name && ab(e2, f3);
                vb(h2, g2);
                var l2 = vb(h2, f3);
                for (g2 = 0; g2 < k.length; g2 += 2) {
                  var m2 = k[g2], q = k[g2 + 1];
                  "style" === m2 ? sb(e2, q) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q) : "children" === m2 ? ob(e2, q) : ta(e2, m2, q, l2);
                }
                switch (h2) {
                  case "input":
                    bb(e2, f3);
                    break;
                  case "textarea":
                    ib(e2, f3);
                    break;
                  case "select":
                    var r3 = e2._wrapperState.wasMultiple;
                    e2._wrapperState.wasMultiple = !!f3.multiple;
                    var y2 = f3.value;
                    null != y2 ? fb(e2, !!f3.multiple, y2, false) : r3 !== !!f3.multiple && (null != f3.defaultValue ? fb(
                      e2,
                      !!f3.multiple,
                      f3.defaultValue,
                      true
                    ) : fb(e2, !!f3.multiple, f3.multiple ? [] : "", false));
                }
                e2[Pf] = f3;
              } catch (t2) {
                W(a2, a2.return, t2);
              }
            }
            break;
          case 6:
            dk(b2, a2);
            fk(a2);
            if (d2 & 4) {
              if (null === a2.stateNode) throw Error(p2(162));
              e2 = a2.stateNode;
              f3 = a2.memoizedProps;
              try {
                e2.nodeValue = f3;
              } catch (t2) {
                W(a2, a2.return, t2);
              }
            }
            break;
          case 3:
            dk(b2, a2);
            fk(a2);
            if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
              bd(b2.containerInfo);
            } catch (t2) {
              W(a2, a2.return, t2);
            }
            break;
          case 4:
            dk(b2, a2);
            fk(a2);
            break;
          case 13:
            dk(b2, a2);
            fk(a2);
            e2 = a2.child;
            e2.flags & 8192 && (f3 = null !== e2.memoizedState, e2.stateNode.isHidden = f3, !f3 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
            d2 & 4 && bk(a2);
            break;
          case 22:
            m2 = null !== c2 && null !== c2.memoizedState;
            a2.mode & 1 ? (U = (l2 = U) || m2, dk(b2, a2), U = l2) : dk(b2, a2);
            fk(a2);
            if (d2 & 8192) {
              l2 = null !== a2.memoizedState;
              if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1)) for (V = a2, m2 = a2.child; null !== m2; ) {
                for (q = V = m2; null !== V; ) {
                  r3 = V;
                  y2 = r3.child;
                  switch (r3.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Qj(4, r3, r3.return);
                      break;
                    case 1:
                      Mj(r3, r3.return);
                      var n2 = r3.stateNode;
                      if ("function" === typeof n2.componentWillUnmount) {
                        d2 = r3;
                        c2 = r3.return;
                        try {
                          b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                        } catch (t2) {
                          W(d2, c2, t2);
                        }
                      }
                      break;
                    case 5:
                      Mj(r3, r3.return);
                      break;
                    case 22:
                      if (null !== r3.memoizedState) {
                        hk(q);
                        continue;
                      }
                  }
                  null !== y2 ? (y2.return = r3, V = y2) : hk(q);
                }
                m2 = m2.sibling;
              }
              a: for (m2 = null, q = a2; ; ) {
                if (5 === q.tag) {
                  if (null === m2) {
                    m2 = q;
                    try {
                      e2 = q.stateNode, l2 ? (f3 = e2.style, "function" === typeof f3.setProperty ? f3.setProperty("display", "none", "important") : f3.display = "none") : (h2 = q.stateNode, k = q.memoizedProps.style, g2 = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h2.style.display = rb("display", g2));
                    } catch (t2) {
                      W(a2, a2.return, t2);
                    }
                  }
                } else if (6 === q.tag) {
                  if (null === m2) try {
                    q.stateNode.nodeValue = l2 ? "" : q.memoizedProps;
                  } catch (t2) {
                    W(a2, a2.return, t2);
                  }
                } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a2) && null !== q.child) {
                  q.child.return = q;
                  q = q.child;
                  continue;
                }
                if (q === a2) break a;
                for (; null === q.sibling; ) {
                  if (null === q.return || q.return === a2) break a;
                  m2 === q && (m2 = null);
                  q = q.return;
                }
                m2 === q && (m2 = null);
                q.sibling.return = q.return;
                q = q.sibling;
              }
            }
            break;
          case 19:
            dk(b2, a2);
            fk(a2);
            d2 & 4 && bk(a2);
            break;
          case 21:
            break;
          default:
            dk(
              b2,
              a2
            ), fk(a2);
        }
      }
      function fk(a2) {
        var b2 = a2.flags;
        if (b2 & 2) {
          try {
            a: {
              for (var c2 = a2.return; null !== c2; ) {
                if (Uj(c2)) {
                  var d2 = c2;
                  break a;
                }
                c2 = c2.return;
              }
              throw Error(p2(160));
            }
            switch (d2.tag) {
              case 5:
                var e2 = d2.stateNode;
                d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
                var f3 = Vj(a2);
                Xj(a2, f3, e2);
                break;
              case 3:
              case 4:
                var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
                Wj(a2, h2, g2);
                break;
              default:
                throw Error(p2(161));
            }
          } catch (k) {
            W(a2, a2.return, k);
          }
          a2.flags &= -3;
        }
        b2 & 4096 && (a2.flags &= -4097);
      }
      function ik(a2, b2, c2) {
        V = a2;
        jk(a2, b2, c2);
      }
      function jk(a2, b2, c2) {
        for (var d2 = 0 !== (a2.mode & 1); null !== V; ) {
          var e2 = V, f3 = e2.child;
          if (22 === e2.tag && d2) {
            var g2 = null !== e2.memoizedState || Kj;
            if (!g2) {
              var h2 = e2.alternate, k = null !== h2 && null !== h2.memoizedState || U;
              h2 = Kj;
              var l2 = U;
              Kj = g2;
              if ((U = k) && !l2) for (V = e2; null !== V; ) g2 = V, k = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k ? (k.return = g2, V = k) : kk(e2);
              for (; null !== f3; ) V = f3, jk(f3, b2, c2), f3 = f3.sibling;
              V = e2;
              Kj = h2;
              U = l2;
            }
            lk(a2, b2, c2);
          } else 0 !== (e2.subtreeFlags & 8772) && null !== f3 ? (f3.return = e2, V = f3) : lk(a2, b2, c2);
        }
      }
      function lk(a2) {
        for (; null !== V; ) {
          var b2 = V;
          if (0 !== (b2.flags & 8772)) {
            var c2 = b2.alternate;
            try {
              if (0 !== (b2.flags & 8772)) switch (b2.tag) {
                case 0:
                case 11:
                case 15:
                  U || Rj(5, b2);
                  break;
                case 1:
                  var d2 = b2.stateNode;
                  if (b2.flags & 4 && !U) if (null === c2) d2.componentDidMount();
                  else {
                    var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                    d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                  }
                  var f3 = b2.updateQueue;
                  null !== f3 && ih(b2, f3, d2);
                  break;
                case 3:
                  var g2 = b2.updateQueue;
                  if (null !== g2) {
                    c2 = null;
                    if (null !== b2.child) switch (b2.child.tag) {
                      case 5:
                        c2 = b2.child.stateNode;
                        break;
                      case 1:
                        c2 = b2.child.stateNode;
                    }
                    ih(b2, g2, c2);
                  }
                  break;
                case 5:
                  var h2 = b2.stateNode;
                  if (null === c2 && b2.flags & 4) {
                    c2 = h2;
                    var k = b2.memoizedProps;
                    switch (b2.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k.autoFocus && c2.focus();
                        break;
                      case "img":
                        k.src && (c2.src = k.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b2.memoizedState) {
                    var l2 = b2.alternate;
                    if (null !== l2) {
                      var m2 = l2.memoizedState;
                      if (null !== m2) {
                        var q = m2.dehydrated;
                        null !== q && bd(q);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p2(163));
              }
              U || b2.flags & 512 && Sj(b2);
            } catch (r3) {
              W(b2, b2.return, r3);
            }
          }
          if (b2 === a2) {
            V = null;
            break;
          }
          c2 = b2.sibling;
          if (null !== c2) {
            c2.return = b2.return;
            V = c2;
            break;
          }
          V = b2.return;
        }
      }
      function hk(a2) {
        for (; null !== V; ) {
          var b2 = V;
          if (b2 === a2) {
            V = null;
            break;
          }
          var c2 = b2.sibling;
          if (null !== c2) {
            c2.return = b2.return;
            V = c2;
            break;
          }
          V = b2.return;
        }
      }
      function kk(a2) {
        for (; null !== V; ) {
          var b2 = V;
          try {
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                var c2 = b2.return;
                try {
                  Rj(4, b2);
                } catch (k) {
                  W(b2, c2, k);
                }
                break;
              case 1:
                var d2 = b2.stateNode;
                if ("function" === typeof d2.componentDidMount) {
                  var e2 = b2.return;
                  try {
                    d2.componentDidMount();
                  } catch (k) {
                    W(b2, e2, k);
                  }
                }
                var f3 = b2.return;
                try {
                  Sj(b2);
                } catch (k) {
                  W(b2, f3, k);
                }
                break;
              case 5:
                var g2 = b2.return;
                try {
                  Sj(b2);
                } catch (k) {
                  W(b2, g2, k);
                }
            }
          } catch (k) {
            W(b2, b2.return, k);
          }
          if (b2 === a2) {
            V = null;
            break;
          }
          var h2 = b2.sibling;
          if (null !== h2) {
            h2.return = b2.return;
            V = h2;
            break;
          }
          V = b2.return;
        }
      }
      var mk = Math.ceil;
      var nk = ua.ReactCurrentDispatcher;
      var ok = ua.ReactCurrentOwner;
      var pk = ua.ReactCurrentBatchConfig;
      var K = 0;
      var R = null;
      var Y = null;
      var Z = 0;
      var gj = 0;
      var fj = Uf(0);
      var T = 0;
      var qk = null;
      var hh = 0;
      var rk = 0;
      var sk = 0;
      var tk = null;
      var uk = null;
      var gk = 0;
      var Hj = Infinity;
      var vk = null;
      var Pi2 = false;
      var Qi = null;
      var Si = null;
      var wk = false;
      var xk = null;
      var yk = 0;
      var zk = 0;
      var Ak = null;
      var Bk = -1;
      var Ck = 0;
      function L() {
        return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
      }
      function lh(a2) {
        if (0 === (a2.mode & 1)) return 1;
        if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
        if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
        a2 = C;
        if (0 !== a2) return a2;
        a2 = window.event;
        a2 = void 0 === a2 ? 16 : jd(a2.type);
        return a2;
      }
      function mh(a2, b2, c2, d2) {
        if (50 < zk) throw zk = 0, Ak = null, Error(p2(185));
        Ac(a2, c2, d2);
        if (0 === (K & 2) || a2 !== R) a2 === R && (0 === (K & 2) && (rk |= c2), 4 === T && Dk(a2, Z)), Ek(a2, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B() + 500, fg && jg());
      }
      function Ek(a2, b2) {
        var c2 = a2.callbackNode;
        wc(a2, b2);
        var d2 = uc(a2, a2 === R ? Z : 0);
        if (0 === d2) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
        else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
          null != c2 && bc(c2);
          if (1 === b2) 0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
            0 === (K & 6) && jg();
          }), c2 = null;
          else {
            switch (Dc(d2)) {
              case 1:
                c2 = fc;
                break;
              case 4:
                c2 = gc;
                break;
              case 16:
                c2 = hc;
                break;
              case 536870912:
                c2 = jc;
                break;
              default:
                c2 = hc;
            }
            c2 = Gk(c2, Hk.bind(null, a2));
          }
          a2.callbackPriority = b2;
          a2.callbackNode = c2;
        }
      }
      function Hk(a2, b2) {
        Bk = -1;
        Ck = 0;
        if (0 !== (K & 6)) throw Error(p2(327));
        var c2 = a2.callbackNode;
        if (Ik() && a2.callbackNode !== c2) return null;
        var d2 = uc(a2, a2 === R ? Z : 0);
        if (0 === d2) return null;
        if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2) b2 = Jk(a2, d2);
        else {
          b2 = d2;
          var e2 = K;
          K |= 2;
          var f3 = Kk();
          if (R !== a2 || Z !== b2) vk = null, Hj = B() + 500, Lk(a2, b2);
          do
            try {
              Mk();
              break;
            } catch (h2) {
              Nk(a2, h2);
            }
          while (1);
          Qg();
          nk.current = f3;
          K = e2;
          null !== Y ? b2 = 0 : (R = null, Z = 0, b2 = T);
        }
        if (0 !== b2) {
          2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
          if (1 === b2) throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B()), c2;
          if (6 === b2) Dk(a2, d2);
          else {
            e2 = a2.current.alternate;
            if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f3 = xc(a2), 0 !== f3 && (d2 = f3, b2 = Ok(a2, f3))), 1 === b2)) throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B()), c2;
            a2.finishedWork = e2;
            a2.finishedLanes = d2;
            switch (b2) {
              case 0:
              case 1:
                throw Error(p2(345));
              case 2:
                Qk(a2, uk, vk);
                break;
              case 3:
                Dk(a2, d2);
                if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B(), 10 < b2)) {
                  if (0 !== uc(a2, 0)) break;
                  e2 = a2.suspendedLanes;
                  if ((e2 & d2) !== d2) {
                    L();
                    a2.pingedLanes |= a2.suspendedLanes & e2;
                    break;
                  }
                  a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
                  break;
                }
                Qk(a2, uk, vk);
                break;
              case 4:
                Dk(a2, d2);
                if ((d2 & 4194240) === d2) break;
                b2 = a2.eventTimes;
                for (e2 = -1; 0 < d2; ) {
                  var g2 = 31 - oc(d2);
                  f3 = 1 << g2;
                  g2 = b2[g2];
                  g2 > e2 && (e2 = g2);
                  d2 &= ~f3;
                }
                d2 = e2;
                d2 = B() - d2;
                d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
                if (10 < d2) {
                  a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
                  break;
                }
                Qk(a2, uk, vk);
                break;
              case 5:
                Qk(a2, uk, vk);
                break;
              default:
                throw Error(p2(329));
            }
          }
        }
        Ek(a2, B());
        return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
      }
      function Ok(a2, b2) {
        var c2 = tk;
        a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
        a2 = Jk(a2, b2);
        2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
        return a2;
      }
      function Gj(a2) {
        null === uk ? uk = a2 : uk.push.apply(uk, a2);
      }
      function Pk(a2) {
        for (var b2 = a2; ; ) {
          if (b2.flags & 16384) {
            var c2 = b2.updateQueue;
            if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
              var e2 = c2[d2], f3 = e2.getSnapshot;
              e2 = e2.value;
              try {
                if (!He(f3(), e2)) return false;
              } catch (g2) {
                return false;
              }
            }
          }
          c2 = b2.child;
          if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
          else {
            if (b2 === a2) break;
            for (; null === b2.sibling; ) {
              if (null === b2.return || b2.return === a2) return true;
              b2 = b2.return;
            }
            b2.sibling.return = b2.return;
            b2 = b2.sibling;
          }
        }
        return true;
      }
      function Dk(a2, b2) {
        b2 &= ~sk;
        b2 &= ~rk;
        a2.suspendedLanes |= b2;
        a2.pingedLanes &= ~b2;
        for (a2 = a2.expirationTimes; 0 < b2; ) {
          var c2 = 31 - oc(b2), d2 = 1 << c2;
          a2[c2] = -1;
          b2 &= ~d2;
        }
      }
      function Fk(a2) {
        if (0 !== (K & 6)) throw Error(p2(327));
        Ik();
        var b2 = uc(a2, 0);
        if (0 === (b2 & 1)) return Ek(a2, B()), null;
        var c2 = Jk(a2, b2);
        if (0 !== a2.tag && 2 === c2) {
          var d2 = xc(a2);
          0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
        }
        if (1 === c2) throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B()), c2;
        if (6 === c2) throw Error(p2(345));
        a2.finishedWork = a2.current.alternate;
        a2.finishedLanes = b2;
        Qk(a2, uk, vk);
        Ek(a2, B());
        return null;
      }
      function Rk(a2, b2) {
        var c2 = K;
        K |= 1;
        try {
          return a2(b2);
        } finally {
          K = c2, 0 === K && (Hj = B() + 500, fg && jg());
        }
      }
      function Sk(a2) {
        null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
        var b2 = K;
        K |= 1;
        var c2 = pk.transition, d2 = C;
        try {
          if (pk.transition = null, C = 1, a2) return a2();
        } finally {
          C = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
        }
      }
      function Ij() {
        gj = fj.current;
        E(fj);
      }
      function Lk(a2, b2) {
        a2.finishedWork = null;
        a2.finishedLanes = 0;
        var c2 = a2.timeoutHandle;
        -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
        if (null !== Y) for (c2 = Y.return; null !== c2; ) {
          var d2 = c2;
          wg(d2);
          switch (d2.tag) {
            case 1:
              d2 = d2.type.childContextTypes;
              null !== d2 && void 0 !== d2 && $f();
              break;
            case 3:
              Jh();
              E(Wf);
              E(H);
              Oh();
              break;
            case 5:
              Lh(d2);
              break;
            case 4:
              Jh();
              break;
            case 13:
              E(M);
              break;
            case 19:
              E(M);
              break;
            case 10:
              Rg(d2.type._context);
              break;
            case 22:
            case 23:
              Ij();
          }
          c2 = c2.return;
        }
        R = a2;
        Y = a2 = wh(a2.current, null);
        Z = gj = b2;
        T = 0;
        qk = null;
        sk = rk = hh = 0;
        uk = tk = null;
        if (null !== Wg) {
          for (b2 = 0; b2 < Wg.length; b2++) if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
            c2.interleaved = null;
            var e2 = d2.next, f3 = c2.pending;
            if (null !== f3) {
              var g2 = f3.next;
              f3.next = e2;
              d2.next = g2;
            }
            c2.pending = d2;
          }
          Wg = null;
        }
        return a2;
      }
      function Nk(a2, b2) {
        do {
          var c2 = Y;
          try {
            Qg();
            Ph.current = ai;
            if (Sh) {
              for (var d2 = N.memoizedState; null !== d2; ) {
                var e2 = d2.queue;
                null !== e2 && (e2.pending = null);
                d2 = d2.next;
              }
              Sh = false;
            }
            Rh = 0;
            P2 = O2 = N = null;
            Th = false;
            Uh = 0;
            ok.current = null;
            if (null === c2 || null === c2.return) {
              T = 1;
              qk = b2;
              Y = null;
              break;
            }
            a: {
              var f3 = a2, g2 = c2.return, h2 = c2, k = b2;
              b2 = Z;
              h2.flags |= 32768;
              if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                var l2 = k, m2 = h2, q = m2.tag;
                if (0 === (m2.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                  var r3 = m2.alternate;
                  r3 ? (m2.updateQueue = r3.updateQueue, m2.memoizedState = r3.memoizedState, m2.lanes = r3.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
                }
                var y2 = Vi(g2);
                if (null !== y2) {
                  y2.flags &= -257;
                  Wi(y2, g2, h2, f3, b2);
                  y2.mode & 1 && Ti(f3, l2, b2);
                  b2 = y2;
                  k = l2;
                  var n2 = b2.updateQueue;
                  if (null === n2) {
                    var t2 = /* @__PURE__ */ new Set();
                    t2.add(k);
                    b2.updateQueue = t2;
                  } else n2.add(k);
                  break a;
                } else {
                  if (0 === (b2 & 1)) {
                    Ti(f3, l2, b2);
                    uj();
                    break a;
                  }
                  k = Error(p2(426));
                }
              } else if (I && h2.mode & 1) {
                var J = Vi(g2);
                if (null !== J) {
                  0 === (J.flags & 65536) && (J.flags |= 256);
                  Wi(J, g2, h2, f3, b2);
                  Jg(Ki(k, h2));
                  break a;
                }
              }
              f3 = k = Ki(k, h2);
              4 !== T && (T = 2);
              null === tk ? tk = [f3] : tk.push(f3);
              f3 = g2;
              do {
                switch (f3.tag) {
                  case 3:
                    f3.flags |= 65536;
                    b2 &= -b2;
                    f3.lanes |= b2;
                    var x2 = Oi(f3, k, b2);
                    fh(f3, x2);
                    break a;
                  case 1:
                    h2 = k;
                    var w2 = f3.type, u2 = f3.stateNode;
                    if (0 === (f3.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                      f3.flags |= 65536;
                      b2 &= -b2;
                      f3.lanes |= b2;
                      var F = Ri(f3, h2, b2);
                      fh(f3, F);
                      break a;
                    }
                }
                f3 = f3.return;
              } while (null !== f3);
            }
            Tk(c2);
          } catch (na) {
            b2 = na;
            Y === c2 && null !== c2 && (Y = c2 = c2.return);
            continue;
          }
          break;
        } while (1);
      }
      function Kk() {
        var a2 = nk.current;
        nk.current = ai;
        return null === a2 ? ai : a2;
      }
      function uj() {
        if (0 === T || 3 === T || 2 === T) T = 4;
        null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
      }
      function Jk(a2, b2) {
        var c2 = K;
        K |= 2;
        var d2 = Kk();
        if (R !== a2 || Z !== b2) vk = null, Lk(a2, b2);
        do
          try {
            Uk();
            break;
          } catch (e2) {
            Nk(a2, e2);
          }
        while (1);
        Qg();
        K = c2;
        nk.current = d2;
        if (null !== Y) throw Error(p2(261));
        R = null;
        Z = 0;
        return T;
      }
      function Uk() {
        for (; null !== Y; ) Vk(Y);
      }
      function Mk() {
        for (; null !== Y && !cc(); ) Vk(Y);
      }
      function Vk(a2) {
        var b2 = Wk(a2.alternate, a2, gj);
        a2.memoizedProps = a2.pendingProps;
        null === b2 ? Tk(a2) : Y = b2;
        ok.current = null;
      }
      function Tk(a2) {
        var b2 = a2;
        do {
          var c2 = b2.alternate;
          a2 = b2.return;
          if (0 === (b2.flags & 32768)) {
            if (c2 = Fj(c2, b2, gj), null !== c2) {
              Y = c2;
              return;
            }
          } else {
            c2 = Jj(c2, b2);
            if (null !== c2) {
              c2.flags &= 32767;
              Y = c2;
              return;
            }
            if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
            else {
              T = 6;
              Y = null;
              return;
            }
          }
          b2 = b2.sibling;
          if (null !== b2) {
            Y = b2;
            return;
          }
          Y = b2 = a2;
        } while (null !== b2);
        0 === T && (T = 5);
      }
      function Qk(a2, b2, c2) {
        var d2 = C, e2 = pk.transition;
        try {
          pk.transition = null, C = 1, Xk(a2, b2, c2, d2);
        } finally {
          pk.transition = e2, C = d2;
        }
        return null;
      }
      function Xk(a2, b2, c2, d2) {
        do
          Ik();
        while (null !== xk);
        if (0 !== (K & 6)) throw Error(p2(327));
        c2 = a2.finishedWork;
        var e2 = a2.finishedLanes;
        if (null === c2) return null;
        a2.finishedWork = null;
        a2.finishedLanes = 0;
        if (c2 === a2.current) throw Error(p2(177));
        a2.callbackNode = null;
        a2.callbackPriority = 0;
        var f3 = c2.lanes | c2.childLanes;
        Bc(a2, f3);
        a2 === R && (Y = R = null, Z = 0);
        0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
          Ik();
          return null;
        }));
        f3 = 0 !== (c2.flags & 15990);
        if (0 !== (c2.subtreeFlags & 15990) || f3) {
          f3 = pk.transition;
          pk.transition = null;
          var g2 = C;
          C = 1;
          var h2 = K;
          K |= 4;
          ok.current = null;
          Pj(a2, c2);
          ek(c2, a2);
          Oe(Df);
          dd = !!Cf;
          Df = Cf = null;
          a2.current = c2;
          ik(c2, a2, e2);
          dc();
          K = h2;
          C = g2;
          pk.transition = f3;
        } else a2.current = c2;
        wk && (wk = false, xk = a2, yk = e2);
        f3 = a2.pendingLanes;
        0 === f3 && (Si = null);
        mc(c2.stateNode, d2);
        Ek(a2, B());
        if (null !== b2) for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
        if (Pi2) throw Pi2 = false, a2 = Qi, Qi = null, a2;
        0 !== (yk & 1) && 0 !== a2.tag && Ik();
        f3 = a2.pendingLanes;
        0 !== (f3 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
        jg();
        return null;
      }
      function Ik() {
        if (null !== xk) {
          var a2 = Dc(yk), b2 = pk.transition, c2 = C;
          try {
            pk.transition = null;
            C = 16 > a2 ? 16 : a2;
            if (null === xk) var d2 = false;
            else {
              a2 = xk;
              xk = null;
              yk = 0;
              if (0 !== (K & 6)) throw Error(p2(331));
              var e2 = K;
              K |= 4;
              for (V = a2.current; null !== V; ) {
                var f3 = V, g2 = f3.child;
                if (0 !== (V.flags & 16)) {
                  var h2 = f3.deletions;
                  if (null !== h2) {
                    for (var k = 0; k < h2.length; k++) {
                      var l2 = h2[k];
                      for (V = l2; null !== V; ) {
                        var m2 = V;
                        switch (m2.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Qj(8, m2, f3);
                        }
                        var q = m2.child;
                        if (null !== q) q.return = m2, V = q;
                        else for (; null !== V; ) {
                          m2 = V;
                          var r3 = m2.sibling, y2 = m2.return;
                          Tj(m2);
                          if (m2 === l2) {
                            V = null;
                            break;
                          }
                          if (null !== r3) {
                            r3.return = y2;
                            V = r3;
                            break;
                          }
                          V = y2;
                        }
                      }
                    }
                    var n2 = f3.alternate;
                    if (null !== n2) {
                      var t2 = n2.child;
                      if (null !== t2) {
                        n2.child = null;
                        do {
                          var J = t2.sibling;
                          t2.sibling = null;
                          t2 = J;
                        } while (null !== t2);
                      }
                    }
                    V = f3;
                  }
                }
                if (0 !== (f3.subtreeFlags & 2064) && null !== g2) g2.return = f3, V = g2;
                else b: for (; null !== V; ) {
                  f3 = V;
                  if (0 !== (f3.flags & 2048)) switch (f3.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f3, f3.return);
                  }
                  var x2 = f3.sibling;
                  if (null !== x2) {
                    x2.return = f3.return;
                    V = x2;
                    break b;
                  }
                  V = f3.return;
                }
              }
              var w2 = a2.current;
              for (V = w2; null !== V; ) {
                g2 = V;
                var u2 = g2.child;
                if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V = u2;
                else b: for (g2 = w2; null !== V; ) {
                  h2 = V;
                  if (0 !== (h2.flags & 2048)) try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W(h2, h2.return, na);
                  }
                  if (h2 === g2) {
                    V = null;
                    break b;
                  }
                  var F = h2.sibling;
                  if (null !== F) {
                    F.return = h2.return;
                    V = F;
                    break b;
                  }
                  V = h2.return;
                }
              }
              K = e2;
              jg();
              if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                lc.onPostCommitFiberRoot(kc, a2);
              } catch (na) {
              }
              d2 = true;
            }
            return d2;
          } finally {
            C = c2, pk.transition = b2;
          }
        }
        return false;
      }
      function Yk(a2, b2, c2) {
        b2 = Ki(c2, b2);
        b2 = Oi(a2, b2, 1);
        a2 = dh(a2, b2, 1);
        b2 = L();
        null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
      }
      function W(a2, b2, c2) {
        if (3 === a2.tag) Yk(a2, a2, c2);
        else for (; null !== b2; ) {
          if (3 === b2.tag) {
            Yk(b2, a2, c2);
            break;
          } else if (1 === b2.tag) {
            var d2 = b2.stateNode;
            if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
              a2 = Ki(c2, a2);
              a2 = Ri(b2, a2, 1);
              b2 = dh(b2, a2, 1);
              a2 = L();
              null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
              break;
            }
          }
          b2 = b2.return;
        }
      }
      function Ui(a2, b2, c2) {
        var d2 = a2.pingCache;
        null !== d2 && d2.delete(b2);
        b2 = L();
        a2.pingedLanes |= a2.suspendedLanes & c2;
        R === a2 && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a2, 0) : sk |= c2);
        Ek(a2, b2);
      }
      function Zk(a2, b2) {
        0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
        var c2 = L();
        a2 = Zg(a2, b2);
        null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
      }
      function vj(a2) {
        var b2 = a2.memoizedState, c2 = 0;
        null !== b2 && (c2 = b2.retryLane);
        Zk(a2, c2);
      }
      function ck(a2, b2) {
        var c2 = 0;
        switch (a2.tag) {
          case 13:
            var d2 = a2.stateNode;
            var e2 = a2.memoizedState;
            null !== e2 && (c2 = e2.retryLane);
            break;
          case 19:
            d2 = a2.stateNode;
            break;
          default:
            throw Error(p2(314));
        }
        null !== d2 && d2.delete(b2);
        Zk(a2, c2);
      }
      var Wk;
      Wk = function(a2, b2, c2) {
        if (null !== a2) if (a2.memoizedProps !== b2.pendingProps || Wf.current) Ug = true;
        else {
          if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128)) return Ug = false, zj(a2, b2, c2);
          Ug = 0 !== (a2.flags & 131072) ? true : false;
        }
        else Ug = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
        b2.lanes = 0;
        switch (b2.tag) {
          case 2:
            var d2 = b2.type;
            jj(a2, b2);
            a2 = b2.pendingProps;
            var e2 = Yf(b2, H.current);
            Tg(b2, c2);
            e2 = Xh(null, b2, d2, a2, e2, c2);
            var f3 = bi();
            b2.flags |= 1;
            "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f3 = true, cg(b2)) : f3 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f3, c2)) : (b2.tag = 0, I && f3 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
            return b2;
          case 16:
            d2 = b2.elementType;
            a: {
              jj(a2, b2);
              a2 = b2.pendingProps;
              e2 = d2._init;
              d2 = e2(d2._payload);
              b2.type = d2;
              e2 = b2.tag = $k(d2);
              a2 = Lg(d2, a2);
              switch (e2) {
                case 0:
                  b2 = dj(null, b2, d2, a2, c2);
                  break a;
                case 1:
                  b2 = ij(null, b2, d2, a2, c2);
                  break a;
                case 11:
                  b2 = Zi(null, b2, d2, a2, c2);
                  break a;
                case 14:
                  b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
                  break a;
              }
              throw Error(p2(
                306,
                d2,
                ""
              ));
            }
            return b2;
          case 0:
            return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
          case 1:
            return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
          case 3:
            a: {
              lj(b2);
              if (null === a2) throw Error(p2(387));
              d2 = b2.pendingProps;
              f3 = b2.memoizedState;
              e2 = f3.element;
              bh(a2, b2);
              gh(b2, d2, null, c2);
              var g2 = b2.memoizedState;
              d2 = g2.element;
              if (f3.isDehydrated) if (f3 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f3, b2.memoizedState = f3, b2.flags & 256) {
                e2 = Ki(Error(p2(423)), b2);
                b2 = mj(a2, b2, d2, c2, e2);
                break a;
              } else if (d2 !== e2) {
                e2 = Ki(Error(p2(424)), b2);
                b2 = mj(a2, b2, d2, c2, e2);
                break a;
              } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
              else {
                Ig();
                if (d2 === e2) {
                  b2 = $i(a2, b2, c2);
                  break a;
                }
                Yi(a2, b2, d2, c2);
              }
              b2 = b2.child;
            }
            return b2;
          case 5:
            return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f3 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f3 && Ef(d2, f3) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
          case 6:
            return null === a2 && Eg(b2), null;
          case 13:
            return pj(a2, b2, c2);
          case 4:
            return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
          case 11:
            return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
          case 7:
            return Yi(a2, b2, b2.pendingProps, c2), b2.child;
          case 8:
            return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
          case 12:
            return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
          case 10:
            a: {
              d2 = b2.type._context;
              e2 = b2.pendingProps;
              f3 = b2.memoizedProps;
              g2 = e2.value;
              G(Mg, d2._currentValue);
              d2._currentValue = g2;
              if (null !== f3) if (He(f3.value, g2)) {
                if (f3.children === e2.children && !Wf.current) {
                  b2 = $i(a2, b2, c2);
                  break a;
                }
              } else for (f3 = b2.child, null !== f3 && (f3.return = b2); null !== f3; ) {
                var h2 = f3.dependencies;
                if (null !== h2) {
                  g2 = f3.child;
                  for (var k = h2.firstContext; null !== k; ) {
                    if (k.context === d2) {
                      if (1 === f3.tag) {
                        k = ch(-1, c2 & -c2);
                        k.tag = 2;
                        var l2 = f3.updateQueue;
                        if (null !== l2) {
                          l2 = l2.shared;
                          var m2 = l2.pending;
                          null === m2 ? k.next = k : (k.next = m2.next, m2.next = k);
                          l2.pending = k;
                        }
                      }
                      f3.lanes |= c2;
                      k = f3.alternate;
                      null !== k && (k.lanes |= c2);
                      Sg(
                        f3.return,
                        c2,
                        b2
                      );
                      h2.lanes |= c2;
                      break;
                    }
                    k = k.next;
                  }
                } else if (10 === f3.tag) g2 = f3.type === b2.type ? null : f3.child;
                else if (18 === f3.tag) {
                  g2 = f3.return;
                  if (null === g2) throw Error(p2(341));
                  g2.lanes |= c2;
                  h2 = g2.alternate;
                  null !== h2 && (h2.lanes |= c2);
                  Sg(g2, c2, b2);
                  g2 = f3.sibling;
                } else g2 = f3.child;
                if (null !== g2) g2.return = f3;
                else for (g2 = f3; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f3 = g2.sibling;
                  if (null !== f3) {
                    f3.return = g2.return;
                    g2 = f3;
                    break;
                  }
                  g2 = g2.return;
                }
                f3 = g2;
              }
              Yi(a2, b2, e2.children, c2);
              b2 = b2.child;
            }
            return b2;
          case 9:
            return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
          case 14:
            return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
          case 15:
            return cj(a2, b2, b2.type, b2.pendingProps, c2);
          case 17:
            return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
          case 19:
            return yj(a2, b2, c2);
          case 22:
            return ej(a2, b2, c2);
        }
        throw Error(p2(156, b2.tag));
      };
      function Gk(a2, b2) {
        return ac(a2, b2);
      }
      function al(a2, b2, c2, d2) {
        this.tag = a2;
        this.key = c2;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b2;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d2;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function Bg(a2, b2, c2, d2) {
        return new al(a2, b2, c2, d2);
      }
      function bj(a2) {
        a2 = a2.prototype;
        return !(!a2 || !a2.isReactComponent);
      }
      function $k(a2) {
        if ("function" === typeof a2) return bj(a2) ? 1 : 0;
        if (void 0 !== a2 && null !== a2) {
          a2 = a2.$$typeof;
          if (a2 === Da) return 11;
          if (a2 === Ga) return 14;
        }
        return 2;
      }
      function wh(a2, b2) {
        var c2 = a2.alternate;
        null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
        c2.flags = a2.flags & 14680064;
        c2.childLanes = a2.childLanes;
        c2.lanes = a2.lanes;
        c2.child = a2.child;
        c2.memoizedProps = a2.memoizedProps;
        c2.memoizedState = a2.memoizedState;
        c2.updateQueue = a2.updateQueue;
        b2 = a2.dependencies;
        c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
        c2.sibling = a2.sibling;
        c2.index = a2.index;
        c2.ref = a2.ref;
        return c2;
      }
      function yh(a2, b2, c2, d2, e2, f3) {
        var g2 = 2;
        d2 = a2;
        if ("function" === typeof a2) bj(a2) && (g2 = 1);
        else if ("string" === typeof a2) g2 = 5;
        else a: switch (a2) {
          case ya:
            return Ah(c2.children, e2, f3, b2);
          case za:
            g2 = 8;
            e2 |= 8;
            break;
          case Aa:
            return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f3, a2;
          case Ea:
            return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f3, a2;
          case Fa:
            return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f3, a2;
          case Ia:
            return qj(c2, e2, f3, b2);
          default:
            if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
            throw Error(p2(130, null == a2 ? a2 : typeof a2, ""));
        }
        b2 = Bg(g2, c2, b2, e2);
        b2.elementType = a2;
        b2.type = d2;
        b2.lanes = f3;
        return b2;
      }
      function Ah(a2, b2, c2, d2) {
        a2 = Bg(7, a2, d2, b2);
        a2.lanes = c2;
        return a2;
      }
      function qj(a2, b2, c2, d2) {
        a2 = Bg(22, a2, d2, b2);
        a2.elementType = Ia;
        a2.lanes = c2;
        a2.stateNode = { isHidden: false };
        return a2;
      }
      function xh(a2, b2, c2) {
        a2 = Bg(6, a2, null, b2);
        a2.lanes = c2;
        return a2;
      }
      function zh(a2, b2, c2) {
        b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
        b2.lanes = c2;
        b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
        return b2;
      }
      function bl(a2, b2, c2, d2, e2) {
        this.tag = b2;
        this.containerInfo = a2;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.pendingContext = this.context = null;
        this.callbackPriority = 0;
        this.eventTimes = zc(0);
        this.expirationTimes = zc(-1);
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = zc(0);
        this.identifierPrefix = d2;
        this.onRecoverableError = e2;
        this.mutableSourceEagerHydrationData = null;
      }
      function cl(a2, b2, c2, d2, e2, f3, g2, h2, k) {
        a2 = new bl(a2, b2, c2, h2, k);
        1 === b2 ? (b2 = 1, true === f3 && (b2 |= 8)) : b2 = 0;
        f3 = Bg(3, null, null, b2);
        a2.current = f3;
        f3.stateNode = a2;
        f3.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        ah(f3);
        return a2;
      }
      function dl(a2, b2, c2) {
        var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
      }
      function el(a2) {
        if (!a2) return Vf;
        a2 = a2._reactInternals;
        a: {
          if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p2(170));
          var b2 = a2;
          do {
            switch (b2.tag) {
              case 3:
                b2 = b2.stateNode.context;
                break a;
              case 1:
                if (Zf(b2.type)) {
                  b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
            b2 = b2.return;
          } while (null !== b2);
          throw Error(p2(171));
        }
        if (1 === a2.tag) {
          var c2 = a2.type;
          if (Zf(c2)) return bg(a2, c2, b2);
        }
        return b2;
      }
      function fl(a2, b2, c2, d2, e2, f3, g2, h2, k) {
        a2 = cl(c2, d2, true, a2, e2, f3, g2, h2, k);
        a2.context = el(null);
        c2 = a2.current;
        d2 = L();
        e2 = lh(c2);
        f3 = ch(d2, e2);
        f3.callback = void 0 !== b2 && null !== b2 ? b2 : null;
        dh(c2, f3, e2);
        a2.current.lanes = e2;
        Ac(a2, e2, d2);
        Ek(a2, d2);
        return a2;
      }
      function gl(a2, b2, c2, d2) {
        var e2 = b2.current, f3 = L(), g2 = lh(e2);
        c2 = el(c2);
        null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
        b2 = ch(f3, g2);
        b2.payload = { element: a2 };
        d2 = void 0 === d2 ? null : d2;
        null !== d2 && (b2.callback = d2);
        a2 = dh(e2, b2, g2);
        null !== a2 && (mh(a2, e2, g2, f3), eh(a2, e2, g2));
        return g2;
      }
      function hl(a2) {
        a2 = a2.current;
        if (!a2.child) return null;
        switch (a2.child.tag) {
          case 5:
            return a2.child.stateNode;
          default:
            return a2.child.stateNode;
        }
      }
      function il(a2, b2) {
        a2 = a2.memoizedState;
        if (null !== a2 && null !== a2.dehydrated) {
          var c2 = a2.retryLane;
          a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
        }
      }
      function jl(a2, b2) {
        il(a2, b2);
        (a2 = a2.alternate) && il(a2, b2);
      }
      function kl() {
        return null;
      }
      var ll = "function" === typeof reportError ? reportError : function(a2) {
        console.error(a2);
      };
      function ml(a2) {
        this._internalRoot = a2;
      }
      nl.prototype.render = ml.prototype.render = function(a2) {
        var b2 = this._internalRoot;
        if (null === b2) throw Error(p2(409));
        gl(a2, b2, null, null);
      };
      nl.prototype.unmount = ml.prototype.unmount = function() {
        var a2 = this._internalRoot;
        if (null !== a2) {
          this._internalRoot = null;
          var b2 = a2.containerInfo;
          Sk(function() {
            gl(null, a2, null, null);
          });
          b2[uf] = null;
        }
      };
      function nl(a2) {
        this._internalRoot = a2;
      }
      nl.prototype.unstable_scheduleHydration = function(a2) {
        if (a2) {
          var b2 = Hc();
          a2 = { blockedOn: null, target: a2, priority: b2 };
          for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
          Qc.splice(c2, 0, a2);
          0 === c2 && Vc(a2);
        }
      };
      function ol(a2) {
        return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
      }
      function pl(a2) {
        return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
      }
      function ql() {
      }
      function rl(a2, b2, c2, d2, e2) {
        if (e2) {
          if ("function" === typeof d2) {
            var f3 = d2;
            d2 = function() {
              var a3 = hl(g2);
              f3.call(a3);
            };
          }
          var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
          a2._reactRootContainer = g2;
          a2[uf] = g2.current;
          sf(8 === a2.nodeType ? a2.parentNode : a2);
          Sk();
          return g2;
        }
        for (; e2 = a2.lastChild; ) a2.removeChild(e2);
        if ("function" === typeof d2) {
          var h2 = d2;
          d2 = function() {
            var a3 = hl(k);
            h2.call(a3);
          };
        }
        var k = cl(a2, 0, false, null, null, false, false, "", ql);
        a2._reactRootContainer = k;
        a2[uf] = k.current;
        sf(8 === a2.nodeType ? a2.parentNode : a2);
        Sk(function() {
          gl(b2, k, c2, d2);
        });
        return k;
      }
      function sl(a2, b2, c2, d2, e2) {
        var f3 = c2._reactRootContainer;
        if (f3) {
          var g2 = f3;
          if ("function" === typeof e2) {
            var h2 = e2;
            e2 = function() {
              var a3 = hl(g2);
              h2.call(a3);
            };
          }
          gl(b2, g2, a2, e2);
        } else g2 = rl(c2, b2, a2, e2, d2);
        return hl(g2);
      }
      Ec = function(a2) {
        switch (a2.tag) {
          case 3:
            var b2 = a2.stateNode;
            if (b2.current.memoizedState.isDehydrated) {
              var c2 = tc(b2.pendingLanes);
              0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
            }
            break;
          case 13:
            Sk(function() {
              var b3 = Zg(a2, 1);
              if (null !== b3) {
                var c3 = L();
                mh(b3, a2, 1, c3);
              }
            }), jl(a2, 1);
        }
      };
      Fc = function(a2) {
        if (13 === a2.tag) {
          var b2 = Zg(a2, 134217728);
          if (null !== b2) {
            var c2 = L();
            mh(b2, a2, 134217728, c2);
          }
          jl(a2, 134217728);
        }
      };
      Gc = function(a2) {
        if (13 === a2.tag) {
          var b2 = lh(a2), c2 = Zg(a2, b2);
          if (null !== c2) {
            var d2 = L();
            mh(c2, a2, b2, d2);
          }
          jl(a2, b2);
        }
      };
      Hc = function() {
        return C;
      };
      Ic = function(a2, b2) {
        var c2 = C;
        try {
          return C = a2, b2();
        } finally {
          C = c2;
        }
      };
      yb = function(a2, b2, c2) {
        switch (b2) {
          case "input":
            bb(a2, c2);
            b2 = c2.name;
            if ("radio" === c2.type && null != b2) {
              for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
              c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
              for (b2 = 0; b2 < c2.length; b2++) {
                var d2 = c2[b2];
                if (d2 !== a2 && d2.form === a2.form) {
                  var e2 = Db(d2);
                  if (!e2) throw Error(p2(90));
                  Wa(d2);
                  bb(d2, e2);
                }
              }
            }
            break;
          case "textarea":
            ib(a2, c2);
            break;
          case "select":
            b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
        }
      };
      Gb = Rk;
      Hb = Sk;
      var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] };
      var ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
      var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
        a2 = Zb(a2);
        return null === a2 ? null : a2.stateNode;
      }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!wl.isDisabled && wl.supportsFiber) try {
          kc = wl.inject(vl), lc = wl;
        } catch (a2) {
        }
      }
      var wl;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
      exports.createPortal = function(a2, b2) {
        var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!ol(b2)) throw Error(p2(200));
        return dl(a2, b2, null, c2);
      };
      exports.createRoot = function(a2, b2) {
        if (!ol(a2)) throw Error(p2(299));
        var c2 = false, d2 = "", e2 = ll;
        null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
        b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
        a2[uf] = b2.current;
        sf(8 === a2.nodeType ? a2.parentNode : a2);
        return new ml(b2);
      };
      exports.findDOMNode = function(a2) {
        if (null == a2) return null;
        if (1 === a2.nodeType) return a2;
        var b2 = a2._reactInternals;
        if (void 0 === b2) {
          if ("function" === typeof a2.render) throw Error(p2(188));
          a2 = Object.keys(a2).join(",");
          throw Error(p2(268, a2));
        }
        a2 = Zb(b2);
        a2 = null === a2 ? null : a2.stateNode;
        return a2;
      };
      exports.flushSync = function(a2) {
        return Sk(a2);
      };
      exports.hydrate = function(a2, b2, c2) {
        if (!pl(b2)) throw Error(p2(200));
        return sl(null, a2, b2, true, c2);
      };
      exports.hydrateRoot = function(a2, b2, c2) {
        if (!ol(a2)) throw Error(p2(405));
        var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f3 = "", g2 = ll;
        null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f3 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
        b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f3, g2);
        a2[uf] = b2.current;
        sf(a2);
        if (d2) for (a2 = 0; a2 < d2.length; a2++) c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
          c2,
          e2
        );
        return new nl(b2);
      };
      exports.render = function(a2, b2, c2) {
        if (!pl(b2)) throw Error(p2(200));
        return sl(null, a2, b2, false, c2);
      };
      exports.unmountComponentAtNode = function(a2) {
        if (!pl(a2)) throw Error(p2(40));
        return a2._reactRootContainer ? (Sk(function() {
          sl(null, null, a2, false, function() {
            a2._reactRootContainer = null;
            a2[uf] = null;
          });
        }), true) : false;
      };
      exports.unstable_batchedUpdates = Rk;
      exports.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
        if (!pl(c2)) throw Error(p2(200));
        if (null == a2 || void 0 === a2._reactInternals) throw Error(p2(38));
        return sl(a2, b2, c2, false, d2);
      };
      exports.version = "18.2.0-next-9e3b772b8-20220608";
    }
  });

  // ../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/client.js
  var require_client = __commonJS({
    "../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/client.js"(exports) {
      "use strict";
      var m2 = require_react_dom();
      if (true) {
        exports.createRoot = m2.createRoot;
        exports.hydrateRoot = m2.hydrateRoot;
      } else {
        i2 = m2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports.createRoot = function(c2, o2) {
          i2.usingClientEntryPoint = true;
          try {
            return m2.createRoot(c2, o2);
          } finally {
            i2.usingClientEntryPoint = false;
          }
        };
        exports.hydrateRoot = function(c2, h2, o2) {
          i2.usingClientEntryPoint = true;
          try {
            return m2.hydrateRoot(c2, h2, o2);
          } finally {
            i2.usingClientEntryPoint = false;
          }
        };
      }
      var i2;
    }
  });

  // ../../node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js
  var require_use_sync_external_store_shim_production_min = __commonJS({
    "../../node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js"(exports) {
      "use strict";
      var e2 = require_react();
      function h2(a2, b2) {
        return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
      }
      var k = "function" === typeof Object.is ? Object.is : h2;
      var l2 = e2.useState;
      var m2 = e2.useEffect;
      var n2 = e2.useLayoutEffect;
      var p2 = e2.useDebugValue;
      function q(a2, b2) {
        var d2 = b2(), f3 = l2({ inst: { value: d2, getSnapshot: b2 } }), c2 = f3[0].inst, g2 = f3[1];
        n2(function() {
          c2.value = d2;
          c2.getSnapshot = b2;
          r3(c2) && g2({ inst: c2 });
        }, [a2, d2, b2]);
        m2(function() {
          r3(c2) && g2({ inst: c2 });
          return a2(function() {
            r3(c2) && g2({ inst: c2 });
          });
        }, [a2]);
        p2(d2);
        return d2;
      }
      function r3(a2) {
        var b2 = a2.getSnapshot;
        a2 = a2.value;
        try {
          var d2 = b2();
          return !k(a2, d2);
        } catch (f3) {
          return true;
        }
      }
      function t2(a2, b2) {
        return b2();
      }
      var u2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t2 : q;
      exports.useSyncExternalStore = void 0 !== e2.useSyncExternalStore ? e2.useSyncExternalStore : u2;
    }
  });

  // ../../node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "../../node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_use_sync_external_store_shim_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js
  var require_with_selector_production_min = __commonJS({
    "../../node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js"(exports) {
      "use strict";
      var h2 = require_react();
      var n2 = require_shim();
      function p2(a2, b2) {
        return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
      }
      var q = "function" === typeof Object.is ? Object.is : p2;
      var r3 = n2.useSyncExternalStore;
      var t2 = h2.useRef;
      var u2 = h2.useEffect;
      var v2 = h2.useMemo;
      var w2 = h2.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
        var c2 = t2(null);
        if (null === c2.current) {
          var f3 = { hasValue: false, value: null };
          c2.current = f3;
        } else f3 = c2.current;
        c2 = v2(function() {
          function a3(a4) {
            if (!c3) {
              c3 = true;
              d3 = a4;
              a4 = l2(a4);
              if (void 0 !== g2 && f3.hasValue) {
                var b3 = f3.value;
                if (g2(b3, a4)) return k = b3;
              }
              return k = a4;
            }
            b3 = k;
            if (q(d3, a4)) return b3;
            var e3 = l2(a4);
            if (void 0 !== g2 && g2(b3, e3)) return b3;
            d3 = a4;
            return k = e3;
          }
          var c3 = false, d3, k, m2 = void 0 === e2 ? null : e2;
          return [function() {
            return a3(b2());
          }, null === m2 ? void 0 : function() {
            return a3(m2());
          }];
        }, [b2, e2, l2, g2]);
        var d2 = r3(a2, c2[0], c2[1]);
        u2(function() {
          f3.hasValue = true;
          f3.value = d2;
        }, [d2]);
        w2(d2);
        return d2;
      };
    }
  });

  // ../../node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js
  var require_with_selector = __commonJS({
    "../../node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_with_selector_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i2 = 0, len = code.length; i2 < len; ++i2) {
        lookup[i2] = code[i2];
        revLookup[code.charCodeAt(i2)] = i2;
      }
      var i2;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i3;
        for (i3 = 0; i3 < len2; i3 += 4) {
          tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output2 = [];
        for (var i3 = start; i3 < end; i3 += 3) {
          tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
          output2.push(tripletToBase64(tmp));
        }
        return output2.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // ../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      "use strict";
      exports.read = function(buffer, offset, isLE2, mLen, nBytes) {
        var e2, m2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i2 = isLE2 ? nBytes - 1 : 0;
        var d2 = isLE2 ? -1 : 1;
        var s2 = buffer[offset + i2];
        i2 += d2;
        e2 = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
        }
        m2 = e2 & (1 << -nBits) - 1;
        e2 >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
        }
        if (e2 === 0) {
          e2 = 1 - eBias;
        } else if (e2 === eMax) {
          return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m2 = m2 + Math.pow(2, mLen);
          e2 = e2 - eBias;
        }
        return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
      };
      exports.write = function(buffer, value, offset, isLE2, mLen, nBytes) {
        var e2, m2, c2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i2 = isLE2 ? 0 : nBytes - 1;
        var d2 = isLE2 ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m2 = isNaN(value) ? 1 : 0;
          e2 = eMax;
        } else {
          e2 = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c2 = Math.pow(2, -e2)) < 1) {
            e2--;
            c2 *= 2;
          }
          if (e2 + eBias >= 1) {
            value += rt / c2;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c2 >= 2) {
            e2++;
            c2 /= 2;
          }
          if (e2 + eBias >= eMax) {
            m2 = 0;
            e2 = eMax;
          } else if (e2 + eBias >= 1) {
            m2 = (value * c2 - 1) * Math.pow(2, mLen);
            e2 = e2 + eBias;
          } else {
            m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e2 = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
        }
        e2 = e2 << mLen | m2;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
        }
        buffer[offset + i2 - d2] |= s2 * 128;
      };
    }
  });

  // ../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer4;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e2) {
          return false;
        }
      }
      Object.defineProperty(Buffer4.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer4.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer4.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer4.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer4.prototype);
        return buf;
      }
      function Buffer4(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from6(arg, encodingOrOffset, length);
      }
      Buffer4.poolSize = 8192;
      function from6(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString3(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer4.from(valueOf, encodingOrOffset, length);
        }
        const b2 = fromObject(value);
        if (b2) return b2;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer4.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer4.from = function(value, encodingOrOffset, length) {
        return from6(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer4, Uint8Array);
      function assertSize3(size3) {
        if (typeof size3 !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size3 < 0) {
          throw new RangeError('The value "' + size3 + '" is invalid for option "size"');
        }
      }
      function alloc(size3, fill, encoding) {
        assertSize3(size3);
        if (size3 <= 0) {
          return createBuffer(size3);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size3).fill(fill, encoding) : createBuffer(size3).fill(fill);
        }
        return createBuffer(size3);
      }
      Buffer4.alloc = function(size3, fill, encoding) {
        return alloc(size3, fill, encoding);
      };
      function allocUnsafe(size3) {
        assertSize3(size3);
        return createBuffer(size3 < 0 ? 0 : checked(size3) | 0);
      }
      Buffer4.allocUnsafe = function(size3) {
        return allocUnsafe(size3);
      };
      Buffer4.allocUnsafeSlow = function(size3) {
        return allocUnsafe(size3);
      };
      function fromString3(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer4.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i2 = 0; i2 < length; i2 += 1) {
          buf[i2] = array[i2] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy2 = new Uint8Array(arrayView);
          return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer4.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer4.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer4.alloc(+length);
      }
      Buffer4.isBuffer = function isBuffer(b2) {
        return b2 != null && b2._isBuffer === true && b2 !== Buffer4.prototype;
      };
      Buffer4.compare = function compare(a2, b2) {
        if (isInstance(a2, Uint8Array)) a2 = Buffer4.from(a2, a2.offset, a2.byteLength);
        if (isInstance(b2, Uint8Array)) b2 = Buffer4.from(b2, b2.offset, b2.byteLength);
        if (!Buffer4.isBuffer(a2) || !Buffer4.isBuffer(b2)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a2 === b2) return 0;
        let x2 = a2.length;
        let y2 = b2.length;
        for (let i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
          if (a2[i2] !== b2[i2]) {
            x2 = a2[i2];
            y2 = b2[i2];
            break;
          }
        }
        if (x2 < y2) return -1;
        if (y2 < x2) return 1;
        return 0;
      };
      Buffer4.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer4.concat = function concat3(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer4.alloc(0);
        }
        let i2;
        if (length === void 0) {
          length = 0;
          for (i2 = 0; i2 < list.length; ++i2) {
            length += list[i2].length;
          }
        }
        const buffer = Buffer4.allocUnsafe(length);
        let pos = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          let buf = list[i2];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer4.isBuffer(buf)) buf = Buffer4.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer4.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer4.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes2(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes2(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer4.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer4.prototype._isBuffer = true;
      function swap(b2, n2, m2) {
        const i2 = b2[n2];
        b2[n2] = b2[m2];
        b2[m2] = i2;
      }
      Buffer4.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i2 = 0; i2 < len; i2 += 2) {
          swap(this, i2, i2 + 1);
        }
        return this;
      };
      Buffer4.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i2 = 0; i2 < len; i2 += 4) {
          swap(this, i2, i2 + 3);
          swap(this, i2 + 1, i2 + 2);
        }
        return this;
      };
      Buffer4.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i2 = 0; i2 < len; i2 += 8) {
          swap(this, i2, i2 + 7);
          swap(this, i2 + 1, i2 + 6);
          swap(this, i2 + 2, i2 + 5);
          swap(this, i2 + 3, i2 + 4);
        }
        return this;
      };
      Buffer4.prototype.toString = function toString3() {
        const length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
      Buffer4.prototype.equals = function equals(b2) {
        if (!Buffer4.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
        if (this === b2) return true;
        return Buffer4.compare(this, b2) === 0;
      };
      Buffer4.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max) str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
      }
      Buffer4.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer4.from(target, target.offset, target.byteLength);
        }
        if (!Buffer4.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x2 = thisEnd - thisStart;
        let y2 = end - start;
        const len = Math.min(x2, y2);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i2 = 0; i2 < len; ++i2) {
          if (thisCopy[i2] !== targetCopy[i2]) {
            x2 = thisCopy[i2];
            y2 = targetCopy[i2];
            break;
          }
        }
        if (x2 < y2) return -1;
        if (y2 < x2) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir) return -1;
          else byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer4.from(val, encoding);
        }
        if (Buffer4.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i3) {
          if (indexSize === 1) {
            return buf[i3];
          } else {
            return buf.readUInt16BE(i3 * indexSize);
          }
        }
        let i2;
        if (dir) {
          let foundIndex = -1;
          for (i2 = byteOffset; i2 < arrLength; i2++) {
            if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
              if (foundIndex === -1) foundIndex = i2;
              if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i2 -= i2 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i2 = byteOffset; i2 >= 0; i2--) {
            let found = true;
            for (let j2 = 0; j2 < valLength; j2++) {
              if (read(arr, i2 + j2) !== read(val, j2)) {
                found = false;
                break;
              }
            }
            if (found) return i2;
          }
        }
        return -1;
      }
      Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i2;
        for (i2 = 0; i2 < length; ++i2) {
          const parsed = parseInt(string.substr(i2 * 2, 2), 16);
          if (numberIsNaN(parsed)) return i2;
          buf[offset + i2] = parsed;
        }
        return i2;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes2(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer4.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer4.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i2 = start;
        while (i2 < end) {
          const firstByte = buf[i2];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i2 + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i2 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                fourthByte = buf[i2 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i2 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i2 = 0;
        while (i2 < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        let out = "";
        for (let i2 = start; i2 < end; ++i2) {
          out += hexSliceLookupTable[buf[i2]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes2 = buf.slice(start, end);
        let res = "";
        for (let i2 = 0; i2 < bytes2.length - 1; i2 += 2) {
          res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
        }
        return res;
      }
      Buffer4.prototype.slice = function slice3(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer4.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i2 = 0;
        while (++i2 < byteLength2 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        return val;
      };
      Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer4.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer4.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer4.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i2 = 0;
        while (++i2 < byteLength2 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer4.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let i2 = byteLength2;
        let mul = 1;
        let val = this[offset + --i2];
        while (i2 > 0 && (mul *= 256)) {
          val += this[offset + --i2] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer4.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer4.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer4.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer4.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer4.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer4.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer4.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer4.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer4.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer4.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer4.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer4.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i2 = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength2 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i2 = byteLength2 - 1;
        let mul = 1;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer4.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i2 = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer4.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i2 = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer4.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer4.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer4.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer4.prototype.copy = function copy2(target, targetStart, start, end) {
        if (!Buffer4.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer4.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        let i2;
        if (typeof val === "number") {
          for (i2 = start; i2 < end; ++i2) {
            this[i2] = val;
          }
        } else {
          const bytes2 = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
          const len = bytes2.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i2 = 0; i2 < end - start; ++i2) {
            this[i2 + start] = bytes2[i2 % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i2 = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i2 >= start + 4; i2 -= 3) {
          res = `_${val.slice(i2 - 3, i2)}${res}`;
        }
        return `${val.slice(0, i2)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n2 = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
            } else {
              range = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
            }
          } else {
            range = `>= ${min}${n2} and <= ${max}${n2}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes2(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes2 = [];
        for (let i2 = 0; i2 < length; ++i2) {
          codePoint = string.charCodeAt(i2);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes2.push(239, 191, 189);
                continue;
              } else if (i2 + 1 === length) {
                if ((units -= 3) > -1) bytes2.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes2.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes2.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes2.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes2.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes2.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes2.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes2;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i2 = 0; i2 < str.length; ++i2) {
          byteArray.push(str.charCodeAt(i2) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c2, hi, lo;
        const byteArray = [];
        for (let i2 = 0; i2 < str.length; ++i2) {
          if ((units -= 2) < 0) break;
          c2 = str.charCodeAt(i2);
          hi = c2 >> 8;
          lo = c2 % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i2;
        for (i2 = 0; i2 < length; ++i2) {
          if (i2 + offset >= dst.length || i2 >= src.length) break;
          dst[i2 + offset] = src[i2];
        }
        return i2;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i2 = 0; i2 < 16; ++i2) {
          const i16 = i2 * 16;
          for (let j2 = 0; j2 < 16; ++j2) {
            table[i16 + j2] = alphabet[i2] + alphabet[j2];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/utils.js
  var require_utils = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/utils.js"(exports) {
      "use strict";
      var toSJISFunction;
      var CODEWORDS_COUNT = [
        0,
        // Not used
        26,
        44,
        70,
        100,
        134,
        172,
        196,
        242,
        292,
        346,
        404,
        466,
        532,
        581,
        655,
        733,
        815,
        901,
        991,
        1085,
        1156,
        1258,
        1364,
        1474,
        1588,
        1706,
        1828,
        1921,
        2051,
        2185,
        2323,
        2465,
        2611,
        2761,
        2876,
        3034,
        3196,
        3362,
        3532,
        3706
      ];
      exports.getSymbolSize = function getSymbolSize(version3) {
        if (!version3) throw new Error('"version" cannot be null or undefined');
        if (version3 < 1 || version3 > 40) throw new Error('"version" should be in range from 1 to 40');
        return version3 * 4 + 17;
      };
      exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version3) {
        return CODEWORDS_COUNT[version3];
      };
      exports.getBCHDigit = function(data) {
        let digit = 0;
        while (data !== 0) {
          digit++;
          data >>>= 1;
        }
        return digit;
      };
      exports.setToSJISFunction = function setToSJISFunction(f3) {
        if (typeof f3 !== "function") {
          throw new Error('"toSJISFunc" is not a valid function.');
        }
        toSJISFunction = f3;
      };
      exports.isKanjiModeEnabled = function() {
        return typeof toSJISFunction !== "undefined";
      };
      exports.toSJIS = function toSJIS(kanji) {
        return toSJISFunction(kanji);
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/error-correction-level.js
  var require_error_correction_level = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
      "use strict";
      exports.L = { bit: 1 };
      exports.M = { bit: 0 };
      exports.Q = { bit: 3 };
      exports.H = { bit: 2 };
      function fromString3(string) {
        if (typeof string !== "string") {
          throw new Error("Param is not a string");
        }
        const lcStr = string.toLowerCase();
        switch (lcStr) {
          case "l":
          case "low":
            return exports.L;
          case "m":
          case "medium":
            return exports.M;
          case "q":
          case "quartile":
            return exports.Q;
          case "h":
          case "high":
            return exports.H;
          default:
            throw new Error("Unknown EC Level: " + string);
        }
      }
      exports.isValid = function isValid(level) {
        return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
      };
      exports.from = function from6(value, defaultValue) {
        if (exports.isValid(value)) {
          return value;
        }
        try {
          return fromString3(value);
        } catch (e2) {
          return defaultValue;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/bit-buffer.js
  var require_bit_buffer = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
      "use strict";
      function BitBuffer() {
        this.buffer = [];
        this.length = 0;
      }
      BitBuffer.prototype = {
        get: function(index2) {
          const bufIndex = Math.floor(index2 / 8);
          return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
        },
        put: function(num, length) {
          for (let i2 = 0; i2 < length; i2++) {
            this.putBit((num >>> length - i2 - 1 & 1) === 1);
          }
        },
        getLengthInBits: function() {
          return this.length;
        },
        putBit: function(bit) {
          const bufIndex = Math.floor(this.length / 8);
          if (this.buffer.length <= bufIndex) {
            this.buffer.push(0);
          }
          if (bit) {
            this.buffer[bufIndex] |= 128 >>> this.length % 8;
          }
          this.length++;
        }
      };
      module.exports = BitBuffer;
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/bit-matrix.js
  var require_bit_matrix = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
      "use strict";
      function BitMatrix(size3) {
        if (!size3 || size3 < 1) {
          throw new Error("BitMatrix size must be defined and greater than 0");
        }
        this.size = size3;
        this.data = new Uint8Array(size3 * size3);
        this.reservedBit = new Uint8Array(size3 * size3);
      }
      BitMatrix.prototype.set = function(row, col, value, reserved) {
        const index2 = row * this.size + col;
        this.data[index2] = value;
        if (reserved) this.reservedBit[index2] = true;
      };
      BitMatrix.prototype.get = function(row, col) {
        return this.data[row * this.size + col];
      };
      BitMatrix.prototype.xor = function(row, col, value) {
        this.data[row * this.size + col] ^= value;
      };
      BitMatrix.prototype.isReserved = function(row, col) {
        return this.reservedBit[row * this.size + col];
      };
      module.exports = BitMatrix;
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/alignment-pattern.js
  var require_alignment_pattern = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
      "use strict";
      var getSymbolSize = require_utils().getSymbolSize;
      exports.getRowColCoords = function getRowColCoords(version3) {
        if (version3 === 1) return [];
        const posCount = Math.floor(version3 / 7) + 2;
        const size3 = getSymbolSize(version3);
        const intervals = size3 === 145 ? 26 : Math.ceil((size3 - 13) / (2 * posCount - 2)) * 2;
        const positions = [size3 - 7];
        for (let i2 = 1; i2 < posCount - 1; i2++) {
          positions[i2] = positions[i2 - 1] - intervals;
        }
        positions.push(6);
        return positions.reverse();
      };
      exports.getPositions = function getPositions(version3) {
        const coords = [];
        const pos = exports.getRowColCoords(version3);
        const posLength = pos.length;
        for (let i2 = 0; i2 < posLength; i2++) {
          for (let j2 = 0; j2 < posLength; j2++) {
            if (i2 === 0 && j2 === 0 || // top-left
            i2 === 0 && j2 === posLength - 1 || // bottom-left
            i2 === posLength - 1 && j2 === 0) {
              continue;
            }
            coords.push([pos[i2], pos[j2]]);
          }
        }
        return coords;
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/finder-pattern.js
  var require_finder_pattern = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
      "use strict";
      var getSymbolSize = require_utils().getSymbolSize;
      var FINDER_PATTERN_SIZE = 7;
      exports.getPositions = function getPositions(version3) {
        const size3 = getSymbolSize(version3);
        return [
          // top-left
          [0, 0],
          // top-right
          [size3 - FINDER_PATTERN_SIZE, 0],
          // bottom-left
          [0, size3 - FINDER_PATTERN_SIZE]
        ];
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/mask-pattern.js
  var require_mask_pattern = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
      "use strict";
      exports.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
      };
      var PenaltyScores = {
        N1: 3,
        N2: 3,
        N3: 40,
        N4: 10
      };
      exports.isValid = function isValid(mask) {
        return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
      };
      exports.from = function from6(value) {
        return exports.isValid(value) ? parseInt(value, 10) : void 0;
      };
      exports.getPenaltyN1 = function getPenaltyN1(data) {
        const size3 = data.size;
        let points = 0;
        let sameCountCol = 0;
        let sameCountRow = 0;
        let lastCol = null;
        let lastRow = null;
        for (let row = 0; row < size3; row++) {
          sameCountCol = sameCountRow = 0;
          lastCol = lastRow = null;
          for (let col = 0; col < size3; col++) {
            let module2 = data.get(row, col);
            if (module2 === lastCol) {
              sameCountCol++;
            } else {
              if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
              lastCol = module2;
              sameCountCol = 1;
            }
            module2 = data.get(col, row);
            if (module2 === lastRow) {
              sameCountRow++;
            } else {
              if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
              lastRow = module2;
              sameCountRow = 1;
            }
          }
          if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
          if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
        }
        return points;
      };
      exports.getPenaltyN2 = function getPenaltyN2(data) {
        const size3 = data.size;
        let points = 0;
        for (let row = 0; row < size3 - 1; row++) {
          for (let col = 0; col < size3 - 1; col++) {
            const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
            if (last === 4 || last === 0) points++;
          }
        }
        return points * PenaltyScores.N2;
      };
      exports.getPenaltyN3 = function getPenaltyN3(data) {
        const size3 = data.size;
        let points = 0;
        let bitsCol = 0;
        let bitsRow = 0;
        for (let row = 0; row < size3; row++) {
          bitsCol = bitsRow = 0;
          for (let col = 0; col < size3; col++) {
            bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
            if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
            bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
            if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
          }
        }
        return points * PenaltyScores.N3;
      };
      exports.getPenaltyN4 = function getPenaltyN4(data) {
        let darkCount = 0;
        const modulesCount = data.data.length;
        for (let i2 = 0; i2 < modulesCount; i2++) darkCount += data.data[i2];
        const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
        return k * PenaltyScores.N4;
      };
      function getMaskAt(maskPattern, i2, j2) {
        switch (maskPattern) {
          case exports.Patterns.PATTERN000:
            return (i2 + j2) % 2 === 0;
          case exports.Patterns.PATTERN001:
            return i2 % 2 === 0;
          case exports.Patterns.PATTERN010:
            return j2 % 3 === 0;
          case exports.Patterns.PATTERN011:
            return (i2 + j2) % 3 === 0;
          case exports.Patterns.PATTERN100:
            return (Math.floor(i2 / 2) + Math.floor(j2 / 3)) % 2 === 0;
          case exports.Patterns.PATTERN101:
            return i2 * j2 % 2 + i2 * j2 % 3 === 0;
          case exports.Patterns.PATTERN110:
            return (i2 * j2 % 2 + i2 * j2 % 3) % 2 === 0;
          case exports.Patterns.PATTERN111:
            return (i2 * j2 % 3 + (i2 + j2) % 2) % 2 === 0;
          default:
            throw new Error("bad maskPattern:" + maskPattern);
        }
      }
      exports.applyMask = function applyMask(pattern, data) {
        const size3 = data.size;
        for (let col = 0; col < size3; col++) {
          for (let row = 0; row < size3; row++) {
            if (data.isReserved(row, col)) continue;
            data.xor(row, col, getMaskAt(pattern, row, col));
          }
        }
      };
      exports.getBestMask = function getBestMask(data, setupFormatFunc) {
        const numPatterns = Object.keys(exports.Patterns).length;
        let bestPattern = 0;
        let lowerPenalty = Infinity;
        for (let p2 = 0; p2 < numPatterns; p2++) {
          setupFormatFunc(p2);
          exports.applyMask(p2, data);
          const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
          exports.applyMask(p2, data);
          if (penalty < lowerPenalty) {
            lowerPenalty = penalty;
            bestPattern = p2;
          }
        }
        return bestPattern;
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/error-correction-code.js
  var require_error_correction_code = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
      "use strict";
      var ECLevel = require_error_correction_level();
      var EC_BLOCKS_TABLE = [
        // L  M  Q  H
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        1,
        2,
        2,
        4,
        1,
        2,
        4,
        4,
        2,
        4,
        4,
        4,
        2,
        4,
        6,
        5,
        2,
        4,
        6,
        6,
        2,
        5,
        8,
        8,
        4,
        5,
        8,
        8,
        4,
        5,
        8,
        11,
        4,
        8,
        10,
        11,
        4,
        9,
        12,
        16,
        4,
        9,
        16,
        16,
        6,
        10,
        12,
        18,
        6,
        10,
        17,
        16,
        6,
        11,
        16,
        19,
        6,
        13,
        18,
        21,
        7,
        14,
        21,
        25,
        8,
        16,
        20,
        25,
        8,
        17,
        23,
        25,
        9,
        17,
        23,
        34,
        9,
        18,
        25,
        30,
        10,
        20,
        27,
        32,
        12,
        21,
        29,
        35,
        12,
        23,
        34,
        37,
        12,
        25,
        34,
        40,
        13,
        26,
        35,
        42,
        14,
        28,
        38,
        45,
        15,
        29,
        40,
        48,
        16,
        31,
        43,
        51,
        17,
        33,
        45,
        54,
        18,
        35,
        48,
        57,
        19,
        37,
        51,
        60,
        19,
        38,
        53,
        63,
        20,
        40,
        56,
        66,
        21,
        43,
        59,
        70,
        22,
        45,
        62,
        74,
        24,
        47,
        65,
        77,
        25,
        49,
        68,
        81
      ];
      var EC_CODEWORDS_TABLE = [
        // L  M  Q  H
        7,
        10,
        13,
        17,
        10,
        16,
        22,
        28,
        15,
        26,
        36,
        44,
        20,
        36,
        52,
        64,
        26,
        48,
        72,
        88,
        36,
        64,
        96,
        112,
        40,
        72,
        108,
        130,
        48,
        88,
        132,
        156,
        60,
        110,
        160,
        192,
        72,
        130,
        192,
        224,
        80,
        150,
        224,
        264,
        96,
        176,
        260,
        308,
        104,
        198,
        288,
        352,
        120,
        216,
        320,
        384,
        132,
        240,
        360,
        432,
        144,
        280,
        408,
        480,
        168,
        308,
        448,
        532,
        180,
        338,
        504,
        588,
        196,
        364,
        546,
        650,
        224,
        416,
        600,
        700,
        224,
        442,
        644,
        750,
        252,
        476,
        690,
        816,
        270,
        504,
        750,
        900,
        300,
        560,
        810,
        960,
        312,
        588,
        870,
        1050,
        336,
        644,
        952,
        1110,
        360,
        700,
        1020,
        1200,
        390,
        728,
        1050,
        1260,
        420,
        784,
        1140,
        1350,
        450,
        812,
        1200,
        1440,
        480,
        868,
        1290,
        1530,
        510,
        924,
        1350,
        1620,
        540,
        980,
        1440,
        1710,
        570,
        1036,
        1530,
        1800,
        570,
        1064,
        1590,
        1890,
        600,
        1120,
        1680,
        1980,
        630,
        1204,
        1770,
        2100,
        660,
        1260,
        1860,
        2220,
        720,
        1316,
        1950,
        2310,
        750,
        1372,
        2040,
        2430
      ];
      exports.getBlocksCount = function getBlocksCount(version3, errorCorrectionLevel) {
        switch (errorCorrectionLevel) {
          case ECLevel.L:
            return EC_BLOCKS_TABLE[(version3 - 1) * 4 + 0];
          case ECLevel.M:
            return EC_BLOCKS_TABLE[(version3 - 1) * 4 + 1];
          case ECLevel.Q:
            return EC_BLOCKS_TABLE[(version3 - 1) * 4 + 2];
          case ECLevel.H:
            return EC_BLOCKS_TABLE[(version3 - 1) * 4 + 3];
          default:
            return void 0;
        }
      };
      exports.getTotalCodewordsCount = function getTotalCodewordsCount(version3, errorCorrectionLevel) {
        switch (errorCorrectionLevel) {
          case ECLevel.L:
            return EC_CODEWORDS_TABLE[(version3 - 1) * 4 + 0];
          case ECLevel.M:
            return EC_CODEWORDS_TABLE[(version3 - 1) * 4 + 1];
          case ECLevel.Q:
            return EC_CODEWORDS_TABLE[(version3 - 1) * 4 + 2];
          case ECLevel.H:
            return EC_CODEWORDS_TABLE[(version3 - 1) * 4 + 3];
          default:
            return void 0;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/galois-field.js
  var require_galois_field = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/galois-field.js"(exports) {
      "use strict";
      var EXP_TABLE = new Uint8Array(512);
      var LOG_TABLE = new Uint8Array(256);
      (function initTables() {
        let x2 = 1;
        for (let i2 = 0; i2 < 255; i2++) {
          EXP_TABLE[i2] = x2;
          LOG_TABLE[x2] = i2;
          x2 <<= 1;
          if (x2 & 256) {
            x2 ^= 285;
          }
        }
        for (let i2 = 255; i2 < 512; i2++) {
          EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
        }
      })();
      exports.log = function log(n2) {
        if (n2 < 1) throw new Error("log(" + n2 + ")");
        return LOG_TABLE[n2];
      };
      exports.exp = function exp(n2) {
        return EXP_TABLE[n2];
      };
      exports.mul = function mul(x2, y2) {
        if (x2 === 0 || y2 === 0) return 0;
        return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y2]];
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/polynomial.js
  var require_polynomial = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/polynomial.js"(exports) {
      "use strict";
      var GF = require_galois_field();
      exports.mul = function mul(p1, p2) {
        const coeff = new Uint8Array(p1.length + p2.length - 1);
        for (let i2 = 0; i2 < p1.length; i2++) {
          for (let j2 = 0; j2 < p2.length; j2++) {
            coeff[i2 + j2] ^= GF.mul(p1[i2], p2[j2]);
          }
        }
        return coeff;
      };
      exports.mod = function mod(divident, divisor) {
        let result = new Uint8Array(divident);
        while (result.length - divisor.length >= 0) {
          const coeff = result[0];
          for (let i2 = 0; i2 < divisor.length; i2++) {
            result[i2] ^= GF.mul(divisor[i2], coeff);
          }
          let offset = 0;
          while (offset < result.length && result[offset] === 0) offset++;
          result = result.slice(offset);
        }
        return result;
      };
      exports.generateECPolynomial = function generateECPolynomial(degree) {
        let poly = new Uint8Array([1]);
        for (let i2 = 0; i2 < degree; i2++) {
          poly = exports.mul(poly, new Uint8Array([1, GF.exp(i2)]));
        }
        return poly;
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/reed-solomon-encoder.js
  var require_reed_solomon_encoder = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
      "use strict";
      var Polynomial = require_polynomial();
      function ReedSolomonEncoder(degree) {
        this.genPoly = void 0;
        this.degree = degree;
        if (this.degree) this.initialize(this.degree);
      }
      ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
        this.degree = degree;
        this.genPoly = Polynomial.generateECPolynomial(this.degree);
      };
      ReedSolomonEncoder.prototype.encode = function encode3(data) {
        if (!this.genPoly) {
          throw new Error("Encoder not initialized");
        }
        const paddedData = new Uint8Array(data.length + this.degree);
        paddedData.set(data);
        const remainder = Polynomial.mod(paddedData, this.genPoly);
        const start = this.degree - remainder.length;
        if (start > 0) {
          const buff = new Uint8Array(this.degree);
          buff.set(remainder, start);
          return buff;
        }
        return remainder;
      };
      module.exports = ReedSolomonEncoder;
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/version-check.js
  var require_version_check = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/version-check.js"(exports) {
      "use strict";
      exports.isValid = function isValid(version3) {
        return !isNaN(version3) && version3 >= 1 && version3 <= 40;
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/regex.js
  var require_regex = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/regex.js"(exports) {
      "use strict";
      var numeric = "[0-9]+";
      var alphanumeric = "[A-Z $%*+\\-./:]+";
      var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
      kanji = kanji.replace(/u/g, "\\u");
      var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
      exports.KANJI = new RegExp(kanji, "g");
      exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
      exports.BYTE = new RegExp(byte, "g");
      exports.NUMERIC = new RegExp(numeric, "g");
      exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
      var TEST_KANJI = new RegExp("^" + kanji + "$");
      var TEST_NUMERIC = new RegExp("^" + numeric + "$");
      var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
      exports.testKanji = function testKanji(str) {
        return TEST_KANJI.test(str);
      };
      exports.testNumeric = function testNumeric(str) {
        return TEST_NUMERIC.test(str);
      };
      exports.testAlphanumeric = function testAlphanumeric(str) {
        return TEST_ALPHANUMERIC.test(str);
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/mode.js
  var require_mode = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/mode.js"(exports) {
      "use strict";
      var VersionCheck = require_version_check();
      var Regex = require_regex();
      exports.NUMERIC = {
        id: "Numeric",
        bit: 1 << 0,
        ccBits: [10, 12, 14]
      };
      exports.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 1 << 1,
        ccBits: [9, 11, 13]
      };
      exports.BYTE = {
        id: "Byte",
        bit: 1 << 2,
        ccBits: [8, 16, 16]
      };
      exports.KANJI = {
        id: "Kanji",
        bit: 1 << 3,
        ccBits: [8, 10, 12]
      };
      exports.MIXED = {
        bit: -1
      };
      exports.getCharCountIndicator = function getCharCountIndicator(mode, version3) {
        if (!mode.ccBits) throw new Error("Invalid mode: " + mode);
        if (!VersionCheck.isValid(version3)) {
          throw new Error("Invalid version: " + version3);
        }
        if (version3 >= 1 && version3 < 10) return mode.ccBits[0];
        else if (version3 < 27) return mode.ccBits[1];
        return mode.ccBits[2];
      };
      exports.getBestModeForData = function getBestModeForData(dataStr) {
        if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
        else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
        else if (Regex.testKanji(dataStr)) return exports.KANJI;
        else return exports.BYTE;
      };
      exports.toString = function toString3(mode) {
        if (mode && mode.id) return mode.id;
        throw new Error("Invalid mode");
      };
      exports.isValid = function isValid(mode) {
        return mode && mode.bit && mode.ccBits;
      };
      function fromString3(string) {
        if (typeof string !== "string") {
          throw new Error("Param is not a string");
        }
        const lcStr = string.toLowerCase();
        switch (lcStr) {
          case "numeric":
            return exports.NUMERIC;
          case "alphanumeric":
            return exports.ALPHANUMERIC;
          case "kanji":
            return exports.KANJI;
          case "byte":
            return exports.BYTE;
          default:
            throw new Error("Unknown mode: " + string);
        }
      }
      exports.from = function from6(value, defaultValue) {
        if (exports.isValid(value)) {
          return value;
        }
        try {
          return fromString3(value);
        } catch (e2) {
          return defaultValue;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/version.js
  var require_version = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/version.js"(exports) {
      "use strict";
      var Utils = require_utils();
      var ECCode = require_error_correction_code();
      var ECLevel = require_error_correction_level();
      var Mode = require_mode();
      var VersionCheck = require_version_check();
      var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
      var G18_BCH = Utils.getBCHDigit(G18);
      function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
        for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
          if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
            return currentVersion;
          }
        }
        return void 0;
      }
      function getReservedBitsCount(mode, version3) {
        return Mode.getCharCountIndicator(mode, version3) + 4;
      }
      function getTotalBitsFromDataArray(segments, version3) {
        let totalBits = 0;
        segments.forEach(function(data) {
          const reservedBits = getReservedBitsCount(data.mode, version3);
          totalBits += reservedBits + data.getBitsLength();
        });
        return totalBits;
      }
      function getBestVersionForMixedData(segments, errorCorrectionLevel) {
        for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
          const length = getTotalBitsFromDataArray(segments, currentVersion);
          if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
            return currentVersion;
          }
        }
        return void 0;
      }
      exports.from = function from6(value, defaultValue) {
        if (VersionCheck.isValid(value)) {
          return parseInt(value, 10);
        }
        return defaultValue;
      };
      exports.getCapacity = function getCapacity(version3, errorCorrectionLevel, mode) {
        if (!VersionCheck.isValid(version3)) {
          throw new Error("Invalid QR Code version");
        }
        if (typeof mode === "undefined") mode = Mode.BYTE;
        const totalCodewords = Utils.getSymbolTotalCodewords(version3);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version3, errorCorrectionLevel);
        const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
        if (mode === Mode.MIXED) return dataTotalCodewordsBits;
        const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version3);
        switch (mode) {
          case Mode.NUMERIC:
            return Math.floor(usableBits / 10 * 3);
          case Mode.ALPHANUMERIC:
            return Math.floor(usableBits / 11 * 2);
          case Mode.KANJI:
            return Math.floor(usableBits / 13);
          case Mode.BYTE:
          default:
            return Math.floor(usableBits / 8);
        }
      };
      exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
        let seg;
        const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
        if (Array.isArray(data)) {
          if (data.length > 1) {
            return getBestVersionForMixedData(data, ecl);
          }
          if (data.length === 0) {
            return 1;
          }
          seg = data[0];
        } else {
          seg = data;
        }
        return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
      };
      exports.getEncodedBits = function getEncodedBits(version3) {
        if (!VersionCheck.isValid(version3) || version3 < 7) {
          throw new Error("Invalid QR Code version");
        }
        let d2 = version3 << 12;
        while (Utils.getBCHDigit(d2) - G18_BCH >= 0) {
          d2 ^= G18 << Utils.getBCHDigit(d2) - G18_BCH;
        }
        return version3 << 12 | d2;
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/format-info.js
  var require_format_info = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/format-info.js"(exports) {
      "use strict";
      var Utils = require_utils();
      var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
      var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
      var G15_BCH = Utils.getBCHDigit(G15);
      exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
        const data = errorCorrectionLevel.bit << 3 | mask;
        let d2 = data << 10;
        while (Utils.getBCHDigit(d2) - G15_BCH >= 0) {
          d2 ^= G15 << Utils.getBCHDigit(d2) - G15_BCH;
        }
        return (data << 10 | d2) ^ G15_MASK;
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/numeric-data.js
  var require_numeric_data = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
      "use strict";
      var Mode = require_mode();
      function NumericData(data) {
        this.mode = Mode.NUMERIC;
        this.data = data.toString();
      }
      NumericData.getBitsLength = function getBitsLength(length) {
        return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
      };
      NumericData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      NumericData.prototype.getBitsLength = function getBitsLength() {
        return NumericData.getBitsLength(this.data.length);
      };
      NumericData.prototype.write = function write(bitBuffer) {
        let i2, group, value;
        for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
          group = this.data.substr(i2, 3);
          value = parseInt(group, 10);
          bitBuffer.put(value, 10);
        }
        const remainingNum = this.data.length - i2;
        if (remainingNum > 0) {
          group = this.data.substr(i2);
          value = parseInt(group, 10);
          bitBuffer.put(value, remainingNum * 3 + 1);
        }
      };
      module.exports = NumericData;
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/alphanumeric-data.js
  var require_alphanumeric_data = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
      "use strict";
      var Mode = require_mode();
      var ALPHA_NUM_CHARS = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        " ",
        "$",
        "%",
        "*",
        "+",
        "-",
        ".",
        "/",
        ":"
      ];
      function AlphanumericData(data) {
        this.mode = Mode.ALPHANUMERIC;
        this.data = data;
      }
      AlphanumericData.getBitsLength = function getBitsLength(length) {
        return 11 * Math.floor(length / 2) + 6 * (length % 2);
      };
      AlphanumericData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      AlphanumericData.prototype.getBitsLength = function getBitsLength() {
        return AlphanumericData.getBitsLength(this.data.length);
      };
      AlphanumericData.prototype.write = function write(bitBuffer) {
        let i2;
        for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
          let value = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
          value += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
          bitBuffer.put(value, 11);
        }
        if (this.data.length % 2) {
          bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
        }
      };
      module.exports = AlphanumericData;
    }
  });

  // ../../node_modules/.pnpm/encode-utf8@1.0.3/node_modules/encode-utf8/index.js
  var require_encode_utf8 = __commonJS({
    "../../node_modules/.pnpm/encode-utf8@1.0.3/node_modules/encode-utf8/index.js"(exports, module) {
      "use strict";
      module.exports = function encodeUtf8(input) {
        var result = [];
        var size3 = input.length;
        for (var index2 = 0; index2 < size3; index2++) {
          var point = input.charCodeAt(index2);
          if (point >= 55296 && point <= 56319 && size3 > index2 + 1) {
            var second = input.charCodeAt(index2 + 1);
            if (second >= 56320 && second <= 57343) {
              point = (point - 55296) * 1024 + second - 56320 + 65536;
              index2 += 1;
            }
          }
          if (point < 128) {
            result.push(point);
            continue;
          }
          if (point < 2048) {
            result.push(point >> 6 | 192);
            result.push(point & 63 | 128);
            continue;
          }
          if (point < 55296 || point >= 57344 && point < 65536) {
            result.push(point >> 12 | 224);
            result.push(point >> 6 & 63 | 128);
            result.push(point & 63 | 128);
            continue;
          }
          if (point >= 65536 && point <= 1114111) {
            result.push(point >> 18 | 240);
            result.push(point >> 12 & 63 | 128);
            result.push(point >> 6 & 63 | 128);
            result.push(point & 63 | 128);
            continue;
          }
          result.push(239, 191, 189);
        }
        return new Uint8Array(result).buffer;
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/byte-data.js
  var require_byte_data = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
      "use strict";
      var encodeUtf8 = require_encode_utf8();
      var Mode = require_mode();
      function ByteData(data) {
        this.mode = Mode.BYTE;
        if (typeof data === "string") {
          data = encodeUtf8(data);
        }
        this.data = new Uint8Array(data);
      }
      ByteData.getBitsLength = function getBitsLength(length) {
        return length * 8;
      };
      ByteData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      ByteData.prototype.getBitsLength = function getBitsLength() {
        return ByteData.getBitsLength(this.data.length);
      };
      ByteData.prototype.write = function(bitBuffer) {
        for (let i2 = 0, l2 = this.data.length; i2 < l2; i2++) {
          bitBuffer.put(this.data[i2], 8);
        }
      };
      module.exports = ByteData;
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/kanji-data.js
  var require_kanji_data = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
      "use strict";
      var Mode = require_mode();
      var Utils = require_utils();
      function KanjiData(data) {
        this.mode = Mode.KANJI;
        this.data = data;
      }
      KanjiData.getBitsLength = function getBitsLength(length) {
        return length * 13;
      };
      KanjiData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      KanjiData.prototype.getBitsLength = function getBitsLength() {
        return KanjiData.getBitsLength(this.data.length);
      };
      KanjiData.prototype.write = function(bitBuffer) {
        let i2;
        for (i2 = 0; i2 < this.data.length; i2++) {
          let value = Utils.toSJIS(this.data[i2]);
          if (value >= 33088 && value <= 40956) {
            value -= 33088;
          } else if (value >= 57408 && value <= 60351) {
            value -= 49472;
          } else {
            throw new Error(
              "Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8"
            );
          }
          value = (value >>> 8 & 255) * 192 + (value & 255);
          bitBuffer.put(value, 13);
        }
      };
      module.exports = KanjiData;
    }
  });

  // ../../node_modules/.pnpm/dijkstrajs@1.0.3/node_modules/dijkstrajs/dijkstra.js
  var require_dijkstra = __commonJS({
    "../../node_modules/.pnpm/dijkstrajs@1.0.3/node_modules/dijkstrajs/dijkstra.js"(exports, module) {
      "use strict";
      var dijkstra = {
        single_source_shortest_paths: function(graph, s2, d2) {
          var predecessors = {};
          var costs = {};
          costs[s2] = 0;
          var open2 = dijkstra.PriorityQueue.make();
          open2.push(s2, 0);
          var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
          while (!open2.empty()) {
            closest = open2.pop();
            u2 = closest.value;
            cost_of_s_to_u = closest.cost;
            adjacent_nodes = graph[u2] || {};
            for (v2 in adjacent_nodes) {
              if (adjacent_nodes.hasOwnProperty(v2)) {
                cost_of_e = adjacent_nodes[v2];
                cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
                cost_of_s_to_v = costs[v2];
                first_visit = typeof costs[v2] === "undefined";
                if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                  costs[v2] = cost_of_s_to_u_plus_cost_of_e;
                  open2.push(v2, cost_of_s_to_u_plus_cost_of_e);
                  predecessors[v2] = u2;
                }
              }
            }
          }
          if (typeof d2 !== "undefined" && typeof costs[d2] === "undefined") {
            var msg = ["Could not find a path from ", s2, " to ", d2, "."].join("");
            throw new Error(msg);
          }
          return predecessors;
        },
        extract_shortest_path_from_predecessor_list: function(predecessors, d2) {
          var nodes = [];
          var u2 = d2;
          var predecessor;
          while (u2) {
            nodes.push(u2);
            predecessor = predecessors[u2];
            u2 = predecessors[u2];
          }
          nodes.reverse();
          return nodes;
        },
        find_path: function(graph, s2, d2) {
          var predecessors = dijkstra.single_source_shortest_paths(graph, s2, d2);
          return dijkstra.extract_shortest_path_from_predecessor_list(
            predecessors,
            d2
          );
        },
        /**
         * A very naive priority queue implementation.
         */
        PriorityQueue: {
          make: function(opts) {
            var T = dijkstra.PriorityQueue, t2 = {}, key;
            opts = opts || {};
            for (key in T) {
              if (T.hasOwnProperty(key)) {
                t2[key] = T[key];
              }
            }
            t2.queue = [];
            t2.sorter = opts.sorter || T.default_sorter;
            return t2;
          },
          default_sorter: function(a2, b2) {
            return a2.cost - b2.cost;
          },
          /**
           * Add a new item to the queue and ensure the highest priority element
           * is at the front of the queue.
           */
          push: function(value, cost) {
            var item = { value, cost };
            this.queue.push(item);
            this.queue.sort(this.sorter);
          },
          /**
           * Return the highest priority element in the queue.
           */
          pop: function() {
            return this.queue.shift();
          },
          empty: function() {
            return this.queue.length === 0;
          }
        }
      };
      if (typeof module !== "undefined") {
        module.exports = dijkstra;
      }
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/segments.js
  var require_segments = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/segments.js"(exports) {
      "use strict";
      var Mode = require_mode();
      var NumericData = require_numeric_data();
      var AlphanumericData = require_alphanumeric_data();
      var ByteData = require_byte_data();
      var KanjiData = require_kanji_data();
      var Regex = require_regex();
      var Utils = require_utils();
      var dijkstra = require_dijkstra();
      function getStringByteLength(str) {
        return unescape(encodeURIComponent(str)).length;
      }
      function getSegments(regex, mode, str) {
        const segments = [];
        let result;
        while ((result = regex.exec(str)) !== null) {
          segments.push({
            data: result[0],
            index: result.index,
            mode,
            length: result[0].length
          });
        }
        return segments;
      }
      function getSegmentsFromString(dataStr) {
        const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
        const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
        let byteSegs;
        let kanjiSegs;
        if (Utils.isKanjiModeEnabled()) {
          byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
          kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
        } else {
          byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
          kanjiSegs = [];
        }
        const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
        return segs.sort(function(s1, s2) {
          return s1.index - s2.index;
        }).map(function(obj) {
          return {
            data: obj.data,
            mode: obj.mode,
            length: obj.length
          };
        });
      }
      function getSegmentBitsLength(length, mode) {
        switch (mode) {
          case Mode.NUMERIC:
            return NumericData.getBitsLength(length);
          case Mode.ALPHANUMERIC:
            return AlphanumericData.getBitsLength(length);
          case Mode.KANJI:
            return KanjiData.getBitsLength(length);
          case Mode.BYTE:
            return ByteData.getBitsLength(length);
        }
      }
      function mergeSegments(segs) {
        return segs.reduce(function(acc, curr) {
          const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
          if (prevSeg && prevSeg.mode === curr.mode) {
            acc[acc.length - 1].data += curr.data;
            return acc;
          }
          acc.push(curr);
          return acc;
        }, []);
      }
      function buildNodes(segs) {
        const nodes = [];
        for (let i2 = 0; i2 < segs.length; i2++) {
          const seg = segs[i2];
          switch (seg.mode) {
            case Mode.NUMERIC:
              nodes.push([
                seg,
                { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
                { data: seg.data, mode: Mode.BYTE, length: seg.length }
              ]);
              break;
            case Mode.ALPHANUMERIC:
              nodes.push([
                seg,
                { data: seg.data, mode: Mode.BYTE, length: seg.length }
              ]);
              break;
            case Mode.KANJI:
              nodes.push([
                seg,
                { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
              ]);
              break;
            case Mode.BYTE:
              nodes.push([
                { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
              ]);
          }
        }
        return nodes;
      }
      function buildGraph(nodes, version3) {
        const table = {};
        const graph = { start: {} };
        let prevNodeIds = ["start"];
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const nodeGroup = nodes[i2];
          const currentNodeIds = [];
          for (let j2 = 0; j2 < nodeGroup.length; j2++) {
            const node = nodeGroup[j2];
            const key = "" + i2 + j2;
            currentNodeIds.push(key);
            table[key] = { node, lastCount: 0 };
            graph[key] = {};
            for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
              const prevNodeId = prevNodeIds[n2];
              if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
                graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
                table[prevNodeId].lastCount += node.length;
              } else {
                if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
                graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version3);
              }
            }
          }
          prevNodeIds = currentNodeIds;
        }
        for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
          graph[prevNodeIds[n2]].end = 0;
        }
        return { map: graph, table };
      }
      function buildSingleSegment(data, modesHint) {
        let mode;
        const bestMode = Mode.getBestModeForData(data);
        mode = Mode.from(modesHint, bestMode);
        if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
          throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
        }
        if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
          mode = Mode.BYTE;
        }
        switch (mode) {
          case Mode.NUMERIC:
            return new NumericData(data);
          case Mode.ALPHANUMERIC:
            return new AlphanumericData(data);
          case Mode.KANJI:
            return new KanjiData(data);
          case Mode.BYTE:
            return new ByteData(data);
        }
      }
      exports.fromArray = function fromArray2(array) {
        return array.reduce(function(acc, seg) {
          if (typeof seg === "string") {
            acc.push(buildSingleSegment(seg, null));
          } else if (seg.data) {
            acc.push(buildSingleSegment(seg.data, seg.mode));
          }
          return acc;
        }, []);
      };
      exports.fromString = function fromString3(data, version3) {
        const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
        const nodes = buildNodes(segs);
        const graph = buildGraph(nodes, version3);
        const path = dijkstra.find_path(graph.map, "start", "end");
        const optimizedSegs = [];
        for (let i2 = 1; i2 < path.length - 1; i2++) {
          optimizedSegs.push(graph.table[path[i2]].node);
        }
        return exports.fromArray(mergeSegments(optimizedSegs));
      };
      exports.rawSplit = function rawSplit(data) {
        return exports.fromArray(
          getSegmentsFromString(data, Utils.isKanjiModeEnabled())
        );
      };
    }
  });

  // ../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/qrcode.js
  var require_qrcode = __commonJS({
    "../../node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/qrcode.js"(exports) {
      "use strict";
      var Utils = require_utils();
      var ECLevel = require_error_correction_level();
      var BitBuffer = require_bit_buffer();
      var BitMatrix = require_bit_matrix();
      var AlignmentPattern = require_alignment_pattern();
      var FinderPattern = require_finder_pattern();
      var MaskPattern = require_mask_pattern();
      var ECCode = require_error_correction_code();
      var ReedSolomonEncoder = require_reed_solomon_encoder();
      var Version = require_version();
      var FormatInfo = require_format_info();
      var Mode = require_mode();
      var Segments = require_segments();
      function setupFinderPattern(matrix, version3) {
        const size3 = matrix.size;
        const pos = FinderPattern.getPositions(version3);
        for (let i2 = 0; i2 < pos.length; i2++) {
          const row = pos[i2][0];
          const col = pos[i2][1];
          for (let r3 = -1; r3 <= 7; r3++) {
            if (row + r3 <= -1 || size3 <= row + r3) continue;
            for (let c2 = -1; c2 <= 7; c2++) {
              if (col + c2 <= -1 || size3 <= col + c2) continue;
              if (r3 >= 0 && r3 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r3 === 0 || r3 === 6) || r3 >= 2 && r3 <= 4 && c2 >= 2 && c2 <= 4) {
                matrix.set(row + r3, col + c2, true, true);
              } else {
                matrix.set(row + r3, col + c2, false, true);
              }
            }
          }
        }
      }
      function setupTimingPattern(matrix) {
        const size3 = matrix.size;
        for (let r3 = 8; r3 < size3 - 8; r3++) {
          const value = r3 % 2 === 0;
          matrix.set(r3, 6, value, true);
          matrix.set(6, r3, value, true);
        }
      }
      function setupAlignmentPattern(matrix, version3) {
        const pos = AlignmentPattern.getPositions(version3);
        for (let i2 = 0; i2 < pos.length; i2++) {
          const row = pos[i2][0];
          const col = pos[i2][1];
          for (let r3 = -2; r3 <= 2; r3++) {
            for (let c2 = -2; c2 <= 2; c2++) {
              if (r3 === -2 || r3 === 2 || c2 === -2 || c2 === 2 || r3 === 0 && c2 === 0) {
                matrix.set(row + r3, col + c2, true, true);
              } else {
                matrix.set(row + r3, col + c2, false, true);
              }
            }
          }
        }
      }
      function setupVersionInfo(matrix, version3) {
        const size3 = matrix.size;
        const bits = Version.getEncodedBits(version3);
        let row, col, mod;
        for (let i2 = 0; i2 < 18; i2++) {
          row = Math.floor(i2 / 3);
          col = i2 % 3 + size3 - 8 - 3;
          mod = (bits >> i2 & 1) === 1;
          matrix.set(row, col, mod, true);
          matrix.set(col, row, mod, true);
        }
      }
      function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
        const size3 = matrix.size;
        const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
        let i2, mod;
        for (i2 = 0; i2 < 15; i2++) {
          mod = (bits >> i2 & 1) === 1;
          if (i2 < 6) {
            matrix.set(i2, 8, mod, true);
          } else if (i2 < 8) {
            matrix.set(i2 + 1, 8, mod, true);
          } else {
            matrix.set(size3 - 15 + i2, 8, mod, true);
          }
          if (i2 < 8) {
            matrix.set(8, size3 - i2 - 1, mod, true);
          } else if (i2 < 9) {
            matrix.set(8, 15 - i2 - 1 + 1, mod, true);
          } else {
            matrix.set(8, 15 - i2 - 1, mod, true);
          }
        }
        matrix.set(size3 - 8, 8, 1, true);
      }
      function setupData(matrix, data) {
        const size3 = matrix.size;
        let inc = -1;
        let row = size3 - 1;
        let bitIndex = 7;
        let byteIndex = 0;
        for (let col = size3 - 1; col > 0; col -= 2) {
          if (col === 6) col--;
          while (true) {
            for (let c2 = 0; c2 < 2; c2++) {
              if (!matrix.isReserved(row, col - c2)) {
                let dark = false;
                if (byteIndex < data.length) {
                  dark = (data[byteIndex] >>> bitIndex & 1) === 1;
                }
                matrix.set(row, col - c2, dark);
                bitIndex--;
                if (bitIndex === -1) {
                  byteIndex++;
                  bitIndex = 7;
                }
              }
            }
            row += inc;
            if (row < 0 || size3 <= row) {
              row -= inc;
              inc = -inc;
              break;
            }
          }
        }
      }
      function createData(version3, errorCorrectionLevel, segments) {
        const buffer = new BitBuffer();
        segments.forEach(function(data) {
          buffer.put(data.mode.bit, 4);
          buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version3));
          data.write(buffer);
        });
        const totalCodewords = Utils.getSymbolTotalCodewords(version3);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version3, errorCorrectionLevel);
        const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
        if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
          buffer.put(0, 4);
        }
        while (buffer.getLengthInBits() % 8 !== 0) {
          buffer.putBit(0);
        }
        const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
        for (let i2 = 0; i2 < remainingByte; i2++) {
          buffer.put(i2 % 2 ? 17 : 236, 8);
        }
        return createCodewords(buffer, version3, errorCorrectionLevel);
      }
      function createCodewords(bitBuffer, version3, errorCorrectionLevel) {
        const totalCodewords = Utils.getSymbolTotalCodewords(version3);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version3, errorCorrectionLevel);
        const dataTotalCodewords = totalCodewords - ecTotalCodewords;
        const ecTotalBlocks = ECCode.getBlocksCount(version3, errorCorrectionLevel);
        const blocksInGroup2 = totalCodewords % ecTotalBlocks;
        const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
        const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
        const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
        const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
        const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
        const rs = new ReedSolomonEncoder(ecCount);
        let offset = 0;
        const dcData = new Array(ecTotalBlocks);
        const ecData = new Array(ecTotalBlocks);
        let maxDataSize = 0;
        const buffer = new Uint8Array(bitBuffer.buffer);
        for (let b2 = 0; b2 < ecTotalBlocks; b2++) {
          const dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
          dcData[b2] = buffer.slice(offset, offset + dataSize);
          ecData[b2] = rs.encode(dcData[b2]);
          offset += dataSize;
          maxDataSize = Math.max(maxDataSize, dataSize);
        }
        const data = new Uint8Array(totalCodewords);
        let index2 = 0;
        let i2, r3;
        for (i2 = 0; i2 < maxDataSize; i2++) {
          for (r3 = 0; r3 < ecTotalBlocks; r3++) {
            if (i2 < dcData[r3].length) {
              data[index2++] = dcData[r3][i2];
            }
          }
        }
        for (i2 = 0; i2 < ecCount; i2++) {
          for (r3 = 0; r3 < ecTotalBlocks; r3++) {
            data[index2++] = ecData[r3][i2];
          }
        }
        return data;
      }
      function createSymbol(data, version3, errorCorrectionLevel, maskPattern) {
        let segments;
        if (Array.isArray(data)) {
          segments = Segments.fromArray(data);
        } else if (typeof data === "string") {
          let estimatedVersion = version3;
          if (!estimatedVersion) {
            const rawSegments = Segments.rawSplit(data);
            estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
          }
          segments = Segments.fromString(data, estimatedVersion || 40);
        } else {
          throw new Error("Invalid data");
        }
        const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
        if (!bestVersion) {
          throw new Error("The amount of data is too big to be stored in a QR Code");
        }
        if (!version3) {
          version3 = bestVersion;
        } else if (version3 < bestVersion) {
          throw new Error(
            "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
          );
        }
        const dataBits = createData(version3, errorCorrectionLevel, segments);
        const moduleCount = Utils.getSymbolSize(version3);
        const modules = new BitMatrix(moduleCount);
        setupFinderPattern(modules, version3);
        setupTimingPattern(modules);
        setupAlignmentPattern(modules, version3);
        setupFormatInfo(modules, errorCorrectionLevel, 0);
        if (version3 >= 7) {
          setupVersionInfo(modules, version3);
        }
        setupData(modules, dataBits);
        if (isNaN(maskPattern)) {
          maskPattern = MaskPattern.getBestMask(
            modules,
            setupFormatInfo.bind(null, modules, errorCorrectionLevel)
          );
        }
        MaskPattern.applyMask(maskPattern, modules);
        setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
        return {
          modules,
          version: version3,
          errorCorrectionLevel,
          maskPattern,
          segments
        };
      }
      exports.create = function create3(data, options) {
        if (typeof data === "undefined" || data === "") {
          throw new Error("No input text");
        }
        let errorCorrectionLevel = ECLevel.M;
        let version3;
        let mask;
        if (typeof options !== "undefined") {
          errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
          version3 = Version.from(options.version);
          mask = MaskPattern.from(options.maskPattern);
          if (options.toSJISFunc) {
            Utils.setToSJISFunction(options.toSJISFunc);
          }
        }
        return createSymbol(data, version3, errorCorrectionLevel, mask);
      };
    }
  });

  // ../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react-jsx-runtime.production.min.js
  var require_react_jsx_runtime_production_min = __commonJS({
    "../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports) {
      "use strict";
      var f3 = require_react();
      var k = Symbol.for("react.element");
      var l2 = Symbol.for("react.fragment");
      var m2 = Object.prototype.hasOwnProperty;
      var n2 = f3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
      var p2 = { key: true, ref: true, __self: true, __source: true };
      function q(c2, a2, g2) {
        var b2, d2 = {}, e2 = null, h2 = null;
        void 0 !== g2 && (e2 = "" + g2);
        void 0 !== a2.key && (e2 = "" + a2.key);
        void 0 !== a2.ref && (h2 = a2.ref);
        for (b2 in a2) m2.call(a2, b2) && !p2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
        if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
        return { $$typeof: k, type: c2, key: e2, ref: h2, props: d2, _owner: n2.current };
      }
      exports.Fragment = l2;
      exports.jsx = q;
      exports.jsxs = q;
    }
  });

  // ../../node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "../../node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_jsx_runtime_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "../../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module.exports = ReactPropTypesSecret;
    }
  });

  // ../../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithThrowingShims.js
  var require_factoryWithThrowingShims = __commonJS({
    "../../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithThrowingShims.js"(exports, module) {
      "use strict";
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      function emptyFunction() {
      }
      function emptyFunctionWithReset() {
      }
      emptyFunctionWithReset.resetWarningCache = emptyFunction;
      module.exports = function() {
        function shim(props, propName, componentName, location, propFullName, secret) {
          if (secret === ReactPropTypesSecret) {
            return;
          }
          var err = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
          );
          err.name = "Invariant Violation";
          throw err;
        }
        ;
        shim.isRequired = shim;
        function getShim() {
          return shim;
        }
        ;
        var ReactPropTypes = {
          array: shim,
          bigint: shim,
          bool: shim,
          func: shim,
          number: shim,
          object: shim,
          string: shim,
          symbol: shim,
          any: shim,
          arrayOf: getShim,
          element: shim,
          elementType: shim,
          instanceOf: getShim,
          node: shim,
          objectOf: getShim,
          oneOf: getShim,
          oneOfType: getShim,
          shape: getShim,
          exact: getShim,
          checkPropTypes: emptyFunctionWithReset,
          resetWarningCache: emptyFunction
        };
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // ../../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "../../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js"(exports, module) {
      "use strict";
      if (false) {
        ReactIs = null;
        throwOnDirectAccess = true;
        module.exports = null(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module.exports = require_factoryWithThrowingShims()();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // ../../node_modules/.pnpm/toggle-selection@1.0.6/node_modules/toggle-selection/index.js
  var require_toggle_selection = __commonJS({
    "../../node_modules/.pnpm/toggle-selection@1.0.6/node_modules/toggle-selection/index.js"(exports, module) {
      "use strict";
      module.exports = function() {
        var selection = document.getSelection();
        if (!selection.rangeCount) {
          return function() {
          };
        }
        var active = document.activeElement;
        var ranges = [];
        for (var i2 = 0; i2 < selection.rangeCount; i2++) {
          ranges.push(selection.getRangeAt(i2));
        }
        switch (active.tagName.toUpperCase()) {
          case "INPUT":
          case "TEXTAREA":
            active.blur();
            break;
          default:
            active = null;
            break;
        }
        selection.removeAllRanges();
        return function() {
          selection.type === "Caret" && selection.removeAllRanges();
          if (!selection.rangeCount) {
            ranges.forEach(function(range) {
              selection.addRange(range);
            });
          }
          active && active.focus();
        };
      };
    }
  });

  // ../../node_modules/.pnpm/copy-to-clipboard@3.3.3/node_modules/copy-to-clipboard/index.js
  var require_copy_to_clipboard = __commonJS({
    "../../node_modules/.pnpm/copy-to-clipboard@3.3.3/node_modules/copy-to-clipboard/index.js"(exports, module) {
      "use strict";
      var deselectCurrent = require_toggle_selection();
      var clipboardToIE11Formatting = {
        "text/plain": "Text",
        "text/html": "Url",
        "default": "Text"
      };
      var defaultMessage = "Copy to clipboard: #{key}, Enter";
      function format2(message) {
        var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
        return message.replace(/#{\s*key\s*}/g, copyKey);
      }
      function copy2(text, options) {
        var debug, message, reselectPrevious, range, selection, mark, success = false;
        if (!options) {
          options = {};
        }
        debug = options.debug || false;
        try {
          reselectPrevious = deselectCurrent();
          range = document.createRange();
          selection = document.getSelection();
          mark = document.createElement("span");
          mark.textContent = text;
          mark.ariaHidden = "true";
          mark.style.all = "unset";
          mark.style.position = "fixed";
          mark.style.top = 0;
          mark.style.clip = "rect(0, 0, 0, 0)";
          mark.style.whiteSpace = "pre";
          mark.style.webkitUserSelect = "text";
          mark.style.MozUserSelect = "text";
          mark.style.msUserSelect = "text";
          mark.style.userSelect = "text";
          mark.addEventListener("copy", function(e2) {
            e2.stopPropagation();
            if (options.format) {
              e2.preventDefault();
              if (typeof e2.clipboardData === "undefined") {
                debug && console.warn("unable to use e.clipboardData");
                debug && console.warn("trying IE specific stuff");
                window.clipboardData.clearData();
                var format3 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
                window.clipboardData.setData(format3, text);
              } else {
                e2.clipboardData.clearData();
                e2.clipboardData.setData(options.format, text);
              }
            }
            if (options.onCopy) {
              e2.preventDefault();
              options.onCopy(e2.clipboardData);
            }
          });
          document.body.appendChild(mark);
          range.selectNodeContents(mark);
          selection.addRange(range);
          var successful = document.execCommand("copy");
          if (!successful) {
            throw new Error("copy command was unsuccessful");
          }
          success = true;
        } catch (err) {
          debug && console.error("unable to copy using execCommand: ", err);
          debug && console.warn("trying IE specific stuff");
          try {
            window.clipboardData.setData(options.format || "text", text);
            options.onCopy && options.onCopy(window.clipboardData);
            success = true;
          } catch (err2) {
            debug && console.error("unable to copy using clipboardData: ", err2);
            debug && console.error("falling back to prompt");
            message = format2("message" in options ? options.message : defaultMessage);
            window.prompt(message, text);
          }
        } finally {
          if (selection) {
            if (typeof selection.removeRange == "function") {
              selection.removeRange(range);
            } else {
              selection.removeAllRanges();
            }
          }
          if (mark) {
            document.body.removeChild(mark);
          }
          reselectPrevious();
        }
        return success;
      }
      module.exports = copy2;
    }
  });

  // ../../node_modules/.pnpm/@emotion+memoize@0.7.4/node_modules/@emotion/memoize/dist/memoize.esm.js
  function memoize(fn) {
    var cache = {};
    return function(arg) {
      if (cache[arg] === void 0) cache[arg] = fn(arg);
      return cache[arg];
    };
  }
  var memoize_esm_default;
  var init_memoize_esm = __esm({
    "../../node_modules/.pnpm/@emotion+memoize@0.7.4/node_modules/@emotion/memoize/dist/memoize.esm.js"() {
      "use strict";
      memoize_esm_default = memoize;
    }
  });

  // ../../node_modules/.pnpm/@emotion+is-prop-valid@0.8.8/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js
  var is_prop_valid_esm_exports = {};
  __export(is_prop_valid_esm_exports, {
    default: () => is_prop_valid_esm_default
  });
  var reactPropsRegex, index, is_prop_valid_esm_default;
  var init_is_prop_valid_esm = __esm({
    "../../node_modules/.pnpm/@emotion+is-prop-valid@0.8.8/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js"() {
      "use strict";
      init_memoize_esm();
      reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
      index = memoize_esm_default(
        function(prop) {
          return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
        }
        /* Z+1 */
      );
      is_prop_valid_esm_default = index;
    }
  });

  // src/index.tsx
  var import_client = __toESM(require_client(), 1);

  // ../../node_modules/.pnpm/zustand@4.5.4_@types+react@18.0.25_react@18.2.0/node_modules/zustand/esm/shallow.mjs
  function shallow$1(objA, objB) {
    if (Object.is(objA, objB)) {
      return true;
    }
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
      return false;
    }
    if (objA instanceof Map && objB instanceof Map) {
      if (objA.size !== objB.size) return false;
      for (const [key, value] of objA) {
        if (!Object.is(value, objB.get(key))) {
          return false;
        }
      }
      return true;
    }
    if (objA instanceof Set && objB instanceof Set) {
      if (objA.size !== objB.size) return false;
      for (const value of objA) {
        if (!objB.has(value)) {
          return false;
        }
      }
      return true;
    }
    const keysA = Object.keys(objA);
    if (keysA.length !== Object.keys(objB).length) {
      return false;
    }
    for (const keyA of keysA) {
      if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
        return false;
      }
    }
    return true;
  }

  // ../../node_modules/.pnpm/zustand@4.5.4_@types+react@18.0.25_react@18.2.0/node_modules/zustand/esm/traditional.mjs
  var import_react = __toESM(require_react(), 1);
  var import_with_selector = __toESM(require_with_selector(), 1);

  // ../../node_modules/.pnpm/zustand@4.5.4_@types+react@18.0.25_react@18.2.0/node_modules/zustand/esm/vanilla.mjs
  var import_meta = {};
  var createStoreImpl = (createState2) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState2 = () => state;
    const getInitialState = () => initialState;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const destroy = () => {
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
        );
      }
      listeners.clear();
    };
    const api = { setState, getState: getState2, getInitialState, subscribe, destroy };
    const initialState = state = createState2(setState, getState2, api);
    return api;
  };
  var createStore = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;

  // ../../node_modules/.pnpm/zustand@4.5.4_@types+react@18.0.25_react@18.2.0/node_modules/zustand/esm/traditional.mjs
  var { useDebugValue } = import_react.default;
  var { useSyncExternalStoreWithSelector } = import_with_selector.default;
  var identity = (arg) => arg;
  function useStoreWithEqualityFn(api, selector = identity, equalityFn) {
    const slice3 = useSyncExternalStoreWithSelector(
      api.subscribe,
      api.getState,
      api.getServerState || api.getInitialState,
      selector,
      equalityFn
    );
    useDebugValue(slice3);
    return slice3;
  }
  var createWithEqualityFnImpl = (createState2, defaultEqualityFn) => {
    const api = createStore(createState2);
    const useBoundStoreWithEqualityFn = (selector, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector, equalityFn);
    Object.assign(useBoundStoreWithEqualityFn, api);
    return useBoundStoreWithEqualityFn;
  };
  var createWithEqualityFn = (createState2, defaultEqualityFn) => createState2 ? createWithEqualityFnImpl(createState2, defaultEqualityFn) : createWithEqualityFnImpl;

  // ../core/build/chunk-HZ2SQA5V.js
  var import_buffer = __toESM(require_buffer(), 1);

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/version.js
  var version = "1.0.6";

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/errors.js
  var BaseError = class _BaseError extends Error {
    constructor(shortMessage, args = {}) {
      const details = args.cause instanceof _BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
      const docsPath = args.cause instanceof _BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
      const message = [
        shortMessage || "An error occurred.",
        "",
        ...args.metaMessages ? [...args.metaMessages, ""] : [],
        ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
        ...details ? [`Details: ${details}`] : [],
        `Version: abitype@${version}`
      ].join("\n");
      super(message);
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "metaMessages", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiTypeError"
      });
      if (args.cause)
        this.cause = args.cause;
      this.details = details;
      this.docsPath = docsPath;
      this.metaMessages = args.metaMessages;
      this.shortMessage = shortMessage;
    }
  };

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/regex.js
  function execTyped(regex, string) {
    const match = regex.exec(string);
    return match?.groups;
  }
  var bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  var integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  var isTupleRegex = /^\(.+?\).*?$/;

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js
  var tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
  function formatAbiParameter(abiParameter) {
    let type = abiParameter.type;
    if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
      type = "(";
      const length = abiParameter.components.length;
      for (let i2 = 0; i2 < length; i2++) {
        const component = abiParameter.components[i2];
        type += formatAbiParameter(component);
        if (i2 < length - 1)
          type += ", ";
      }
      const result = execTyped(tupleRegex, abiParameter.type);
      type += `)${result?.array ?? ""}`;
      return formatAbiParameter({
        ...abiParameter,
        type
      });
    }
    if ("indexed" in abiParameter && abiParameter.indexed)
      type = `${type} indexed`;
    if (abiParameter.name)
      return `${type} ${abiParameter.name}`;
    return type;
  }

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js
  function formatAbiParameters(abiParameters) {
    let params = "";
    const length = abiParameters.length;
    for (let i2 = 0; i2 < length; i2++) {
      const abiParameter = abiParameters[i2];
      params += formatAbiParameter(abiParameter);
      if (i2 !== length - 1)
        params += ", ";
    }
    return params;
  }

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js
  var structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
  function isStructSignature(signature) {
    return structSignatureRegex.test(signature);
  }
  function execStructSignature(signature) {
    return execTyped(structSignatureRegex, signature);
  }
  var modifiers = /* @__PURE__ */ new Set([
    "memory",
    "indexed",
    "storage",
    "calldata"
  ]);
  var functionModifiers = /* @__PURE__ */ new Set([
    "calldata",
    "memory",
    "storage"
  ]);

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js
  var UnknownTypeError = class extends BaseError {
    constructor({ type }) {
      super("Unknown type.", {
        metaMessages: [
          `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownTypeError"
      });
    }
  };
  var UnknownSolidityTypeError = class extends BaseError {
    constructor({ type }) {
      super("Unknown type.", {
        metaMessages: [`Type "${type}" is not a valid ABI type.`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownSolidityTypeError"
      });
    }
  };

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js
  var InvalidAbiParametersError = class extends BaseError {
    constructor({ params }) {
      super("Failed to parse ABI parameters.", {
        details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
        docsPath: "/api/human#parseabiparameters-1"
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiParametersError"
      });
    }
  };
  var InvalidParameterError = class extends BaseError {
    constructor({ param }) {
      super("Invalid ABI parameter.", {
        details: param
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidParameterError"
      });
    }
  };
  var SolidityProtectedKeywordError = class extends BaseError {
    constructor({ param, name }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SolidityProtectedKeywordError"
      });
    }
  };
  var InvalidModifierError = class extends BaseError {
    constructor({ param, type, modifier }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidModifierError"
      });
    }
  };
  var InvalidFunctionModifierError = class extends BaseError {
    constructor({ param, type, modifier }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
          `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidFunctionModifierError"
      });
    }
  };
  var InvalidAbiTypeParameterError = class extends BaseError {
    constructor({ abiParameter }) {
      super("Invalid ABI parameter.", {
        details: JSON.stringify(abiParameter, null, 2),
        metaMessages: ["ABI parameter type is invalid."]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiTypeParameterError"
      });
    }
  };

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/human-readable/errors/signature.js
  var InvalidSignatureError = class extends BaseError {
    constructor({ signature, type }) {
      super(`Invalid ${type} signature.`, {
        details: signature
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidSignatureError"
      });
    }
  };
  var InvalidStructSignatureError = class extends BaseError {
    constructor({ signature }) {
      super("Invalid struct signature.", {
        details: signature,
        metaMessages: ["No properties exist."]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidStructSignatureError"
      });
    }
  };

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/human-readable/errors/struct.js
  var CircularReferenceError = class extends BaseError {
    constructor({ type }) {
      super("Circular reference detected.", {
        metaMessages: [`Struct "${type}" is a circular reference.`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "CircularReferenceError"
      });
    }
  };

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js
  var InvalidParenthesisError = class extends BaseError {
    constructor({ current, depth }) {
      super("Unbalanced parentheses.", {
        metaMessages: [
          `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
        ],
        details: `Depth "${depth}"`
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidParenthesisError"
      });
    }
  };

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/human-readable/runtime/cache.js
  function getParameterCacheKey(param, type) {
    if (type)
      return `${type}:${param}`;
    return param;
  }
  var parameterCache = /* @__PURE__ */ new Map([
    // Unnamed
    ["address", { type: "address" }],
    ["bool", { type: "bool" }],
    ["bytes", { type: "bytes" }],
    ["bytes32", { type: "bytes32" }],
    ["int", { type: "int256" }],
    ["int256", { type: "int256" }],
    ["string", { type: "string" }],
    ["uint", { type: "uint256" }],
    ["uint8", { type: "uint8" }],
    ["uint16", { type: "uint16" }],
    ["uint24", { type: "uint24" }],
    ["uint32", { type: "uint32" }],
    ["uint64", { type: "uint64" }],
    ["uint96", { type: "uint96" }],
    ["uint112", { type: "uint112" }],
    ["uint160", { type: "uint160" }],
    ["uint192", { type: "uint192" }],
    ["uint256", { type: "uint256" }],
    // Named
    ["address owner", { type: "address", name: "owner" }],
    ["address to", { type: "address", name: "to" }],
    ["bool approved", { type: "bool", name: "approved" }],
    ["bytes _data", { type: "bytes", name: "_data" }],
    ["bytes data", { type: "bytes", name: "data" }],
    ["bytes signature", { type: "bytes", name: "signature" }],
    ["bytes32 hash", { type: "bytes32", name: "hash" }],
    ["bytes32 r", { type: "bytes32", name: "r" }],
    ["bytes32 root", { type: "bytes32", name: "root" }],
    ["bytes32 s", { type: "bytes32", name: "s" }],
    ["string name", { type: "string", name: "name" }],
    ["string symbol", { type: "string", name: "symbol" }],
    ["string tokenURI", { type: "string", name: "tokenURI" }],
    ["uint tokenId", { type: "uint256", name: "tokenId" }],
    ["uint8 v", { type: "uint8", name: "v" }],
    ["uint256 balance", { type: "uint256", name: "balance" }],
    ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
    ["uint256 value", { type: "uint256", name: "value" }],
    // Indexed
    [
      "event:address indexed from",
      { type: "address", name: "from", indexed: true }
    ],
    ["event:address indexed to", { type: "address", name: "to", indexed: true }],
    [
      "event:uint indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ],
    [
      "event:uint256 indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ]
  ]);

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/human-readable/runtime/utils.js
  var abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
  var abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
  var dynamicIntegerRegex = /^u?int$/;
  function parseAbiParameter(param, options) {
    const parameterCacheKey = getParameterCacheKey(param, options?.type);
    if (parameterCache.has(parameterCacheKey))
      return parameterCache.get(parameterCacheKey);
    const isTuple = isTupleRegex.test(param);
    const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
    if (!match)
      throw new InvalidParameterError({ param });
    if (match.name && isSolidityKeyword(match.name))
      throw new SolidityProtectedKeywordError({ param, name: match.name });
    const name = match.name ? { name: match.name } : {};
    const indexed = match.modifier === "indexed" ? { indexed: true } : {};
    const structs = options?.structs ?? {};
    let type;
    let components = {};
    if (isTuple) {
      type = "tuple";
      const params = splitParameters(match.type);
      const components_ = [];
      const length = params.length;
      for (let i2 = 0; i2 < length; i2++) {
        components_.push(parseAbiParameter(params[i2], { structs }));
      }
      components = { components: components_ };
    } else if (match.type in structs) {
      type = "tuple";
      components = { components: structs[match.type] };
    } else if (dynamicIntegerRegex.test(match.type)) {
      type = `${match.type}256`;
    } else {
      type = match.type;
      if (!(options?.type === "struct") && !isSolidityType(type))
        throw new UnknownSolidityTypeError({ type });
    }
    if (match.modifier) {
      if (!options?.modifiers?.has?.(match.modifier))
        throw new InvalidModifierError({
          param,
          type: options?.type,
          modifier: match.modifier
        });
      if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
        throw new InvalidFunctionModifierError({
          param,
          type: options?.type,
          modifier: match.modifier
        });
    }
    const abiParameter = {
      type: `${type}${match.array ?? ""}`,
      ...name,
      ...indexed,
      ...components
    };
    parameterCache.set(parameterCacheKey, abiParameter);
    return abiParameter;
  }
  function splitParameters(params, result = [], current = "", depth = 0) {
    const length = params.trim().length;
    for (let i2 = 0; i2 < length; i2++) {
      const char = params[i2];
      const tail = params.slice(i2 + 1);
      switch (char) {
        case ",":
          return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
        case "(":
          return splitParameters(tail, result, `${current}${char}`, depth + 1);
        case ")":
          return splitParameters(tail, result, `${current}${char}`, depth - 1);
        default:
          return splitParameters(tail, result, `${current}${char}`, depth);
      }
    }
    if (current === "")
      return result;
    if (depth !== 0)
      throw new InvalidParenthesisError({ current, depth });
    result.push(current.trim());
    return result;
  }
  function isSolidityType(type) {
    return type === "address" || type === "bool" || type === "function" || type === "string" || bytesRegex.test(type) || integerRegex.test(type);
  }
  var protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
  function isSolidityKeyword(name) {
    return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || bytesRegex.test(name) || integerRegex.test(name) || protectedKeywordsRegex.test(name);
  }
  function isValidDataLocation(type, isArray) {
    return isArray || type === "bytes" || type === "string" || type === "tuple";
  }

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/human-readable/runtime/structs.js
  function parseStructs(signatures) {
    const shallowStructs = {};
    const signaturesLength = signatures.length;
    for (let i2 = 0; i2 < signaturesLength; i2++) {
      const signature = signatures[i2];
      if (!isStructSignature(signature))
        continue;
      const match = execStructSignature(signature);
      if (!match)
        throw new InvalidSignatureError({ signature, type: "struct" });
      const properties = match.properties.split(";");
      const components = [];
      const propertiesLength = properties.length;
      for (let k = 0; k < propertiesLength; k++) {
        const property = properties[k];
        const trimmed = property.trim();
        if (!trimmed)
          continue;
        const abiParameter = parseAbiParameter(trimmed, {
          type: "struct"
        });
        components.push(abiParameter);
      }
      if (!components.length)
        throw new InvalidStructSignatureError({ signature });
      shallowStructs[match.name] = components;
    }
    const resolvedStructs = {};
    const entries = Object.entries(shallowStructs);
    const entriesLength = entries.length;
    for (let i2 = 0; i2 < entriesLength; i2++) {
      const [name, parameters] = entries[i2];
      resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
    }
    return resolvedStructs;
  }
  var typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
  function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
    const components = [];
    const length = abiParameters.length;
    for (let i2 = 0; i2 < length; i2++) {
      const abiParameter = abiParameters[i2];
      const isTuple = isTupleRegex.test(abiParameter.type);
      if (isTuple)
        components.push(abiParameter);
      else {
        const match = execTyped(typeWithoutTupleRegex, abiParameter.type);
        if (!match?.type)
          throw new InvalidAbiTypeParameterError({ abiParameter });
        const { array, type } = match;
        if (type in structs) {
          if (ancestors.has(type))
            throw new CircularReferenceError({ type });
          components.push({
            ...abiParameter,
            type: `tuple${array ?? ""}`,
            components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type]))
          });
        } else {
          if (isSolidityType(type))
            components.push(abiParameter);
          else
            throw new UnknownTypeError({ type });
        }
      }
    }
    return components;
  }

  // ../../node_modules/.pnpm/abitype@1.0.6_typescript@5.3.3_zod@3.23.8/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js
  function parseAbiParameters(params) {
    const abiParameters = [];
    if (typeof params === "string") {
      const parameters = splitParameters(params);
      const length = parameters.length;
      for (let i2 = 0; i2 < length; i2++) {
        abiParameters.push(parseAbiParameter(parameters[i2], { modifiers }));
      }
    } else {
      const structs = parseStructs(params);
      const length = params.length;
      for (let i2 = 0; i2 < length; i2++) {
        const signature = params[i2];
        if (isStructSignature(signature))
          continue;
        const parameters = splitParameters(signature);
        const length2 = parameters.length;
        for (let k = 0; k < length2; k++) {
          abiParameters.push(parseAbiParameter(parameters[k], { modifiers, structs }));
        }
      }
    }
    if (abiParameters.length === 0)
      throw new InvalidAbiParametersError({ params });
    return abiParameters;
  }

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/version.js
  var version2 = "0.1.0";

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/internal/errors.js
  function getVersion() {
    return version2;
  }

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/Errors.js
  var BaseError2 = class _BaseError extends Error {
    constructor(shortMessage, options = {}) {
      const details = (() => {
        if (options.cause instanceof _BaseError) {
          if (options.cause.details)
            return options.cause.details;
          if (options.cause.shortMessage)
            return options.cause.shortMessage;
        }
        if (options.cause?.message)
          return options.cause.message;
        return options.details;
      })();
      const docsPath = (() => {
        if (options.cause instanceof _BaseError)
          return options.cause.docsPath || options.docsPath;
        return options.docsPath;
      })();
      const docsBaseUrl = "https://oxlib.sh";
      const docs = `${docsBaseUrl}${docsPath ?? ""}`;
      const message = [
        shortMessage || "An error occurred.",
        ...options.metaMessages ? ["", ...options.metaMessages] : [],
        ...details || docsPath ? [
          "",
          details ? `Details: ${details}` : void 0,
          docsPath ? `See: ${docs}` : void 0
        ] : []
      ].filter((x2) => typeof x2 === "string").join("\n");
      super(message, options.cause ? { cause: options.cause } : void 0);
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "docs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BaseError"
      });
      Object.defineProperty(this, "version", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: `ox@${getVersion()}`
      });
      this.cause = options.cause;
      this.details = details;
      this.docs = docs;
      this.docsPath = docsPath;
      this.shortMessage = shortMessage;
    }
    walk(fn) {
      return walk(this, fn);
    }
  };
  function walk(err, fn) {
    if (fn?.(err))
      return err;
    if (err && typeof err === "object" && "cause" in err && err.cause)
      return walk(err.cause, fn);
    return fn ? null : err;
  }

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/Hash.js
  var Hash_exports = {};
  __export(Hash_exports, {
    keccak256: () => keccak256,
    ripemd160: () => ripemd1602,
    sha256: () => sha2562,
    validate: () => validate3
  });

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_assert.js
  function number(n2) {
    if (!Number.isSafeInteger(n2) || n2 < 0)
      throw new Error(`positive integer expected, not ${n2}`);
  }
  function isBytes(a2) {
    return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
  }
  function bytes(b2, ...lengths) {
    if (!isBytes(b2))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b2.length))
      throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b2.length}`);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js
  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  function byteSwap32(arr) {
    for (let i2 = 0; i2 < arr.length; i2++) {
      arr[i2] = byteSwap(arr[i2]);
    }
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    bytes(data);
    return data;
  }
  var Hash = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  var toStr = {}.toString;
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_md.js
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h2 = isLE2 ? 4 : 0;
    const l2 = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h2, wh, isLE2);
    view.setUint32(byteOffset + l2, wl, isLE2);
  }
  var Chi = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
  var Maj = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
  var HashMD = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      exists(this);
      output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i2 = pos; i2 < blockLen; i2++)
        buffer[i2] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i2 = 0; i2 < outLen; i2++)
        oview.setUint32(4 * i2, state[i2], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/ripemd160.js
  var Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
  var Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i2) => i2));
  var Pi = /* @__PURE__ */ Id.map((i2) => (9 * i2 + 5) % 16);
  var idxL = [Id];
  var idxR = [Pi];
  for (let i2 = 0; i2 < 4; i2++)
    for (let j2 of [idxL, idxR])
      j2.push(j2[i2].map((k) => Rho[k]));
  var shifts = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map((i2) => new Uint8Array(i2));
  var shiftsL = /* @__PURE__ */ idxL.map((idx, i2) => idx.map((j2) => shifts[i2][j2]));
  var shiftsR = /* @__PURE__ */ idxR.map((idx, i2) => idx.map((j2) => shifts[i2][j2]));
  var Kl = /* @__PURE__ */ new Uint32Array([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
  ]);
  var Kr = /* @__PURE__ */ new Uint32Array([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
  ]);
  function f(group, x2, y2, z2) {
    if (group === 0)
      return x2 ^ y2 ^ z2;
    else if (group === 1)
      return x2 & y2 | ~x2 & z2;
    else if (group === 2)
      return (x2 | ~y2) ^ z2;
    else if (group === 3)
      return x2 & z2 | y2 & ~z2;
    else
      return x2 ^ (y2 | ~z2);
  }
  var R_BUF = /* @__PURE__ */ new Uint32Array(16);
  var RIPEMD160 = class extends HashMD {
    constructor() {
      super(64, 20, 8, true);
      this.h0 = 1732584193 | 0;
      this.h1 = 4023233417 | 0;
      this.h2 = 2562383102 | 0;
      this.h3 = 271733878 | 0;
      this.h4 = 3285377520 | 0;
    }
    get() {
      const { h0, h1, h2, h3, h4 } = this;
      return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
    process(view, offset) {
      for (let i2 = 0; i2 < 16; i2++, offset += 4)
        R_BUF[i2] = view.getUint32(offset, true);
      let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
      for (let group = 0; group < 5; group++) {
        const rGroup = 4 - group;
        const hbl = Kl[group], hbr = Kr[group];
        const rl = idxL[group], rr = idxR[group];
        const sl = shiftsL[group], sr = shiftsR[group];
        for (let i2 = 0; i2 < 16; i2++) {
          const tl = rotl(al + f(group, bl, cl, dl) + R_BUF[rl[i2]] + hbl, sl[i2]) + el | 0;
          al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
        }
        for (let i2 = 0; i2 < 16; i2++) {
          const tr = rotl(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i2]] + hbr, sr[i2]) + er | 0;
          ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
        }
      }
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
      R_BUF.fill(0);
    }
    destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  };
  var ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n2, le = false) {
    if (le)
      return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
    return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i2 = 0; i2 < lst.length; i2++) {
      const { h: h2, l: l2 } = fromBig(lst[i2], le);
      [Ah[i2], Al[i2]] = [h2, l2];
    }
    return [Ah, Al];
  }
  var rotlSH = (h2, l2, s2) => h2 << s2 | l2 >>> 32 - s2;
  var rotlSL = (h2, l2, s2) => l2 << s2 | h2 >>> 32 - s2;
  var rotlBH = (h2, l2, s2) => l2 << s2 - 32 | h2 >>> 64 - s2;
  var rotlBL = (h2, l2, s2) => h2 << s2 - 32 | l2 >>> 64 - s2;

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha3.js
  var SHA3_PI = [];
  var SHA3_ROTL = [];
  var _SHA3_IOTA = [];
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  var _7n = /* @__PURE__ */ BigInt(7);
  var _256n = /* @__PURE__ */ BigInt(256);
  var _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n, x2 = 1, y2 = 0; round < 24; round++) {
    [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
    SHA3_PI.push(2 * (5 * y2 + x2));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t2 = _0n;
    for (let j2 = 0; j2 < 7; j2++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t2 ^= _1n << (_1n << /* @__PURE__ */ BigInt(j2)) - _1n;
    }
    _SHA3_IOTA.push(t2);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
  var rotlH = (h2, l2, s2) => s2 > 32 ? rotlBH(h2, l2, s2) : rotlSH(h2, l2, s2);
  var rotlL = (h2, l2, s2) => s2 > 32 ? rotlBL(h2, l2, s2) : rotlSL(h2, l2, s2);
  function keccakP(s2, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x2 = 0; x2 < 10; x2++)
        B[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
      for (let x2 = 0; x2 < 10; x2 += 2) {
        const idx1 = (x2 + 8) % 10;
        const idx0 = (x2 + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y2 = 0; y2 < 50; y2 += 10) {
          s2[x2 + y2] ^= Th;
          s2[x2 + y2 + 1] ^= Tl;
        }
      }
      let curH = s2[2];
      let curL = s2[3];
      for (let t2 = 0; t2 < 24; t2++) {
        const shift = SHA3_ROTL[t2];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t2];
        curH = s2[PI];
        curL = s2[PI + 1];
        s2[PI] = Th;
        s2[PI + 1] = Tl;
      }
      for (let y2 = 0; y2 < 50; y2 += 10) {
        for (let x2 = 0; x2 < 10; x2++)
          B[x2] = s2[y2 + x2];
        for (let x2 = 0; x2 < 10; x2++)
          s2[y2 + x2] ^= ~B[(x2 + 2) % 10] & B[(x2 + 4) % 10];
      }
      s2[0] ^= SHA3_IOTA_H[round];
      s2[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  }
  var Keccak = class _Keccak extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      number(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    keccak() {
      if (!isLE)
        byteSwap32(this.state32);
      keccakP(this.state32, this.rounds);
      if (!isLE)
        byteSwap32(this.state32);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      exists(this);
      const { blockLen, state } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i2 = 0; i2 < take; i2++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      exists(this, false);
      bytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes2) {
      number(bytes2);
      return this.xofInto(new Uint8Array(bytes2));
    }
    digestInto(out) {
      output(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
  var sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
  var sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
  var sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
  var sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
  var keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
  var keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  var keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
  var keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
  var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
  var shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
  var shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha256.js
  var SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends HashMD {
    constructor() {
      super(64, 32, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A: A2, B, C, D, E, F, G, H } = this;
      return [A2, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A2, B, C, D, E, F, G, H) {
      this.A = A2 | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i2 = 0; i2 < 16; i2++, offset += 4)
        SHA256_W[i2] = view.getUint32(offset, false);
      for (let i2 = 16; i2 < 64; i2++) {
        const W15 = SHA256_W[i2 - 15];
        const W2 = SHA256_W[i2 - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
      }
      let { A: A2, B, C, D, E, F, G, H } = this;
      for (let i2 = 0; i2 < 64; i2++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
        const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
        const T2 = sigma0 + Maj(A2, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A2;
        A2 = T1 + T2 | 0;
      }
      A2 = A2 + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A2, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/Bytes.js
  var Bytes_exports = {};
  __export(Bytes_exports, {
    InvalidBytesBooleanError: () => InvalidBytesBooleanError,
    InvalidBytesTypeError: () => InvalidBytesTypeError,
    SizeExceedsPaddingSizeError: () => SizeExceedsPaddingSizeError,
    SizeOverflowError: () => SizeOverflowError,
    SliceOffsetOutOfBoundsError: () => SliceOffsetOutOfBoundsError,
    assert: () => assert2,
    concat: () => concat2,
    from: () => from2,
    fromArray: () => fromArray,
    fromBoolean: () => fromBoolean2,
    fromHex: () => fromHex,
    fromNumber: () => fromNumber2,
    fromString: () => fromString2,
    isEqual: () => isEqual2,
    padLeft: () => padLeft2,
    padRight: () => padRight2,
    random: () => random,
    size: () => size,
    slice: () => slice2,
    toBigInt: () => toBigInt2,
    toBoolean: () => toBoolean2,
    toHex: () => toHex,
    toNumber: () => toNumber2,
    toString: () => toString2,
    trimLeft: () => trimLeft2,
    trimRight: () => trimRight,
    validate: () => validate2
  });

  // ../../node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js
  function equalBytes(a2, b2) {
    if (a2.length !== b2.length)
      return false;
    let diff = 0;
    for (let i2 = 0; i2 < a2.length; i2++)
      diff |= a2[i2] ^ b2[i2];
    return diff === 0;
  }

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/Hex.js
  var Hex_exports = {};
  __export(Hex_exports, {
    IntegerOutOfRangeError: () => IntegerOutOfRangeError,
    InvalidHexBooleanError: () => InvalidHexBooleanError,
    InvalidHexTypeError: () => InvalidHexTypeError,
    InvalidHexValueError: () => InvalidHexValueError,
    InvalidLengthError: () => InvalidLengthError,
    SizeExceedsPaddingSizeError: () => SizeExceedsPaddingSizeError2,
    SizeOverflowError: () => SizeOverflowError2,
    SliceOffsetOutOfBoundsError: () => SliceOffsetOutOfBoundsError2,
    assert: () => assert,
    concat: () => concat,
    from: () => from,
    fromBoolean: () => fromBoolean,
    fromBytes: () => fromBytes,
    fromNumber: () => fromNumber,
    fromString: () => fromString,
    isEqual: () => isEqual,
    padLeft: () => padLeft,
    padRight: () => padRight,
    random: () => random2,
    size: () => size2,
    slice: () => slice,
    toBigInt: () => toBigInt,
    toBoolean: () => toBoolean,
    toBytes: () => toBytes2,
    toNumber: () => toNumber,
    toString: () => toString,
    trimLeft: () => trimLeft,
    trimRight: () => trimRight2,
    validate: () => validate
  });

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/Json.js
  var bigIntSuffix = "#__bigint";
  function parse(string, reviver) {
    return JSON.parse(string, (key, value_) => {
      const value = value_;
      if (typeof value === "string" && value.endsWith(bigIntSuffix))
        return BigInt(value.slice(0, -bigIntSuffix.length));
      return typeof reviver === "function" ? reviver(key, value) : value;
    });
  }
  parse.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function stringify(value, replacer, space) {
    return JSON.stringify(value, (key, value2) => {
      if (typeof replacer === "function")
        return replacer(key, value2);
      if (typeof value2 === "bigint")
        return value2.toString() + bigIntSuffix;
      return value2;
    }, space);
  }
  stringify.parseError = (error) => (
    /* v8 ignore next */
    error
  );

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/internal/bytes.js
  function assertSize(bytes2, size_) {
    if (size(bytes2) > size_)
      throw new SizeOverflowError({
        givenSize: size(bytes2),
        maxSize: size_
      });
  }
  function assertStartOffset(value, start) {
    if (typeof start === "number" && start > 0 && start > size(value) - 1)
      throw new SliceOffsetOutOfBoundsError({
        offset: start,
        position: "start",
        size: size(value)
      });
  }
  function assertEndOffset(value, start, end) {
    if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
      throw new SliceOffsetOutOfBoundsError({
        offset: end,
        position: "end",
        size: size(value)
      });
    }
  }
  var charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
  };
  function charCodeToBase16(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine)
      return char - charCodeMap.zero;
    if (char >= charCodeMap.A && char <= charCodeMap.F)
      return char - (charCodeMap.A - 10);
    if (char >= charCodeMap.a && char <= charCodeMap.f)
      return char - (charCodeMap.a - 10);
    return void 0;
  }
  function pad(bytes2, options = {}) {
    const { dir, size: size3 = 32 } = options;
    if (size3 === 0)
      return bytes2;
    if (bytes2.length > size3)
      throw new SizeExceedsPaddingSizeError({
        size: bytes2.length,
        targetSize: size3,
        type: "Bytes"
      });
    const paddedBytes = new Uint8Array(size3);
    for (let i2 = 0; i2 < size3; i2++) {
      const padEnd = dir === "right";
      paddedBytes[padEnd ? i2 : size3 - i2 - 1] = bytes2[padEnd ? i2 : bytes2.length - i2 - 1];
    }
    return paddedBytes;
  }
  function trim(value, options = {}) {
    const { dir = "left" } = options;
    let data = value;
    let sliceLength = 0;
    for (let i2 = 0; i2 < data.length - 1; i2++) {
      if (data[dir === "left" ? i2 : data.length - i2 - 1].toString() === "0")
        sliceLength++;
      else
        break;
    }
    data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    return data;
  }

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/internal/hex.js
  function assertSize2(hex2, size_) {
    if (size2(hex2) > size_)
      throw new SizeOverflowError2({
        givenSize: size2(hex2),
        maxSize: size_
      });
  }
  function assertStartOffset2(value, start) {
    if (typeof start === "number" && start > 0 && start > size2(value) - 1)
      throw new SliceOffsetOutOfBoundsError2({
        offset: start,
        position: "start",
        size: size2(value)
      });
  }
  function assertEndOffset2(value, start, end) {
    if (typeof start === "number" && typeof end === "number" && size2(value) !== end - start) {
      throw new SliceOffsetOutOfBoundsError2({
        offset: end,
        position: "end",
        size: size2(value)
      });
    }
  }
  function pad2(hex_, options = {}) {
    const { dir, size: size3 = 32 } = options;
    if (size3 === 0)
      return hex_;
    const hex2 = hex_.replace("0x", "");
    if (hex2.length > size3 * 2)
      throw new SizeExceedsPaddingSizeError2({
        size: Math.ceil(hex2.length / 2),
        targetSize: size3,
        type: "Hex"
      });
    return `0x${hex2[dir === "right" ? "padEnd" : "padStart"](size3 * 2, "0")}`;
  }
  function trim2(value, options = {}) {
    const { dir = "left" } = options;
    let data = value.replace("0x", "");
    let sliceLength = 0;
    for (let i2 = 0; i2 < data.length - 1; i2++) {
      if (data[dir === "left" ? i2 : data.length - i2 - 1].toString() === "0")
        sliceLength++;
      else
        break;
    }
    data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    if (data.length === 1 && dir === "right")
      data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/Hex.js
  var encoder = /* @__PURE__ */ new TextEncoder();
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i2) => i2.toString(16).padStart(2, "0"));
  function assert(value, options = {}) {
    const { strict = false } = options;
    if (!value)
      throw new InvalidHexTypeError(value);
    if (typeof value !== "string")
      throw new InvalidHexTypeError(value);
    if (strict) {
      if (!/^0x[0-9a-fA-F]*$/.test(value))
        throw new InvalidHexValueError(value);
    }
    if (!value.startsWith("0x"))
      throw new InvalidHexValueError(value);
  }
  assert.parseError = (error) => error;
  function concat(...values) {
    return `0x${values.reduce((acc, x2) => acc + x2.replace("0x", ""), "")}`;
  }
  concat.parseError = (error) => error;
  function from(value) {
    if (value instanceof Uint8Array)
      return fromBytes(value);
    if (Array.isArray(value))
      return fromBytes(new Uint8Array(value));
    return value;
  }
  from.parseError = (error) => error;
  function fromBoolean(value, options = {}) {
    const hex2 = `0x0${Number(value)}`;
    if (typeof options.size === "number") {
      assertSize2(hex2, options.size);
      return padLeft(hex2, options.size);
    }
    return hex2;
  }
  fromBoolean.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function fromBytes(value, options = {}) {
    let string = "";
    for (let i2 = 0; i2 < value.length; i2++)
      string += hexes[value[i2]];
    const hex2 = `0x${string}`;
    if (typeof options.size === "number") {
      assertSize2(hex2, options.size);
      return padRight(hex2, options.size);
    }
    return hex2;
  }
  fromBytes.parseError = (error) => error;
  function fromNumber(value, options = {}) {
    const { signed, size: size3 } = options;
    const value_ = BigInt(value);
    let maxValue;
    if (size3) {
      if (signed)
        maxValue = (1n << BigInt(size3) * 8n - 1n) - 1n;
      else
        maxValue = 2n ** (BigInt(size3) * 8n) - 1n;
    } else if (typeof value === "number") {
      maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
    if (maxValue && value_ > maxValue || value_ < minValue) {
      const suffix = typeof value === "bigint" ? "n" : "";
      throw new IntegerOutOfRangeError({
        max: maxValue ? `${maxValue}${suffix}` : void 0,
        min: `${minValue}${suffix}`,
        signed,
        size: size3,
        value: `${value}${suffix}`
      });
    }
    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size3 * 8)) + BigInt(value_) : value_).toString(16);
    const hex2 = `0x${stringValue.length % 2 === 0 ? stringValue : `0${stringValue}`}`;
    if (size3)
      return padLeft(hex2, size3);
    return hex2;
  }
  fromNumber.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function fromString(value, options = {}) {
    return fromBytes(encoder.encode(value), options);
  }
  fromString.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function isEqual(hexA, hexB) {
    return equalBytes(fromHex(hexA), fromHex(hexB));
  }
  isEqual.parseError = (error) => error;
  function padLeft(value, size3) {
    return pad2(value, { dir: "left", size: size3 });
  }
  padLeft.parseError = (error) => error;
  function padRight(value, size3) {
    return pad2(value, { dir: "right", size: size3 });
  }
  padRight.parseError = (error) => error;
  function random2(length) {
    return fromBytes(random(length));
  }
  random2.parseError = (error) => error;
  function slice(value, start, end, options = {}) {
    const { strict } = options;
    assertStartOffset2(value, start);
    const value_ = `0x${value.replace("0x", "").slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;
    if (strict)
      assertEndOffset2(value_, start, end);
    return value_;
  }
  slice.parseError = (error) => error;
  function size2(value) {
    return Math.ceil((value.length - 2) / 2);
  }
  size2.parseError = (error) => error;
  function trimLeft(value) {
    return trim2(value, { dir: "left" });
  }
  trimLeft.parseError = (error) => error;
  function trimRight2(value) {
    return trim2(value, { dir: "right" });
  }
  trimRight2.parseError = (error) => error;
  function toBigInt(hex2, options = {}) {
    const { signed } = options;
    if (options.size)
      assertSize2(hex2, options.size);
    const value = BigInt(hex2);
    if (!signed)
      return value;
    const size3 = (hex2.length - 2) / 2;
    const max_unsigned = (1n << BigInt(size3) * 8n) - 1n;
    const max_signed = max_unsigned >> 1n;
    if (value <= max_signed)
      return value;
    return value - max_unsigned - 1n;
  }
  toBigInt.parseError = (error) => error;
  function toBoolean(hex2, options = {}) {
    let hex_ = hex2;
    if (options.size) {
      assertSize2(hex2, options.size);
      hex_ = trimLeft(hex_);
    }
    if (trimLeft(hex_) === "0x00")
      return false;
    if (trimLeft(hex_) === "0x01")
      return true;
    throw new InvalidHexBooleanError(hex_);
  }
  toBoolean.parseError = (error) => error;
  function toBytes2(hex2, options = {}) {
    return fromHex(hex2, options);
  }
  toBytes2.parseError = (error) => error;
  function toNumber(hex2, options = {}) {
    const { signed, size: size3 } = options;
    if (!signed && !size3)
      return Number(hex2);
    return Number(toBigInt(hex2, options));
  }
  toNumber.parseError = (error) => error;
  function toString(hex2, options = {}) {
    const { size: size3 } = options;
    let bytes2 = fromHex(hex2);
    if (size3) {
      assertSize(bytes2, size3);
      bytes2 = trimRight(bytes2);
    }
    return new TextDecoder().decode(bytes2);
  }
  toString.parseError = (error) => error;
  function validate(value, options = {}) {
    const { strict = false } = options;
    try {
      assert(value, { strict });
      return true;
    } catch {
      return false;
    }
  }
  validate.parseError = (error) => error;
  var IntegerOutOfRangeError = class extends BaseError2 {
    constructor({ max, min, signed, size: size3, value }) {
      super(`Number \`${value}\` is not in safe${size3 ? ` ${size3 * 8}-bit` : ""}${signed ? " signed" : " unsigned"} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.IntegerOutOfRangeError"
      });
    }
  };
  var InvalidHexBooleanError = class extends BaseError2 {
    constructor(hex2) {
      super(`Hex value \`"${hex2}"\` is not a valid boolean.`, {
        metaMessages: [
          'The hex value must be `"0x0"` (false) or `"0x1"` (true).'
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.InvalidHexBooleanError"
      });
    }
  };
  var InvalidHexTypeError = class extends BaseError2 {
    constructor(value) {
      super(`Value \`${typeof value === "object" ? stringify(value) : value}\` of type \`${typeof value}\` is an invalid hex type.`, {
        metaMessages: ['Hex types must be represented as `"0x${string}"`.']
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.InvalidHexTypeError"
      });
    }
  };
  var InvalidHexValueError = class extends BaseError2 {
    constructor(value) {
      super(`Value \`${value}\` is an invalid hex value.`, {
        metaMessages: [
          'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.InvalidHexValueError"
      });
    }
  };
  var InvalidLengthError = class extends BaseError2 {
    constructor(value) {
      super(`Hex value \`"${value}"\` is an odd length (${value.length - 2} nibbles).`, {
        metaMessages: ["It must be an even length."]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.InvalidLengthError"
      });
    }
  };
  var SizeOverflowError2 = class extends BaseError2 {
    constructor({ givenSize, maxSize }) {
      super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.SizeOverflowError"
      });
    }
  };
  var SliceOffsetOutOfBoundsError2 = class extends BaseError2 {
    constructor({ offset, position, size: size3 }) {
      super(`Slice ${position === "start" ? "starting" : "ending"} at offset \`${offset}\` is out-of-bounds (size: \`${size3}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.SliceOffsetOutOfBoundsError"
      });
    }
  };
  var SizeExceedsPaddingSizeError2 = class extends BaseError2 {
    constructor({ size: size3, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size3}\`) exceeds padding size (\`${targetSize}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Hex.SizeExceedsPaddingSizeError"
      });
    }
  };

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/Bytes.js
  var decoder = /* @__PURE__ */ new TextDecoder();
  var encoder2 = /* @__PURE__ */ new TextEncoder();
  function assert2(value) {
    if (value instanceof Uint8Array)
      return;
    if (!value)
      throw new InvalidBytesTypeError(value);
    if (typeof value !== "object")
      throw new InvalidBytesTypeError(value);
    if (!("BYTES_PER_ELEMENT" in value))
      throw new InvalidBytesTypeError(value);
    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== "Uint8Array")
      throw new InvalidBytesTypeError(value);
  }
  assert2.parseError = (error) => error;
  function concat2(...values) {
    let length = 0;
    for (const arr of values) {
      length += arr.length;
    }
    const result = new Uint8Array(length);
    for (let i2 = 0, index2 = 0; i2 < values.length; i2++) {
      const arr = values[i2];
      result.set(arr, index2);
      index2 += arr.length;
    }
    return result;
  }
  concat2.parseError = (error) => error;
  function from2(value) {
    if (value instanceof Uint8Array)
      return value;
    if (typeof value === "string")
      return fromHex(value);
    return fromArray(value);
  }
  from2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function fromArray(value) {
    return value instanceof Uint8Array ? value : new Uint8Array(value);
  }
  fromArray.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function fromBoolean2(value, options = {}) {
    const { size: size3 } = options;
    const bytes2 = new Uint8Array(1);
    bytes2[0] = Number(value);
    if (typeof size3 === "number") {
      assertSize(bytes2, size3);
      return padLeft2(bytes2, size3);
    }
    return bytes2;
  }
  fromBoolean2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function fromHex(value, options = {}) {
    const { size: size3 } = options;
    if (value.length % 2)
      throw new InvalidLengthError(value);
    let hex2 = value;
    if (size3) {
      assertSize2(value, size3);
      hex2 = padRight(value, size3);
    }
    const hexString = hex2.slice(2);
    const length = hexString.length / 2;
    const bytes2 = new Uint8Array(length);
    for (let index2 = 0, j2 = 0; index2 < length; index2++) {
      const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j2++));
      const nibbleRight = charCodeToBase16(hexString.charCodeAt(j2++));
      if (nibbleLeft === void 0 || nibbleRight === void 0) {
        throw new BaseError2(`Invalid byte sequence ("${hexString[j2 - 2]}${hexString[j2 - 1]}" in "${hexString}").`);
      }
      bytes2[index2] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes2;
  }
  fromHex.parseError = (error) => error;
  function fromNumber2(value, options) {
    const hex2 = fromNumber(value, options);
    return fromHex(hex2);
  }
  fromNumber2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function fromString2(value, options = {}) {
    const { size: size3 } = options;
    const bytes2 = encoder2.encode(value);
    if (typeof size3 === "number") {
      assertSize(bytes2, size3);
      return padRight2(bytes2, size3);
    }
    return bytes2;
  }
  fromString2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function isEqual2(bytesA, bytesB) {
    return equalBytes(bytesA, bytesB);
  }
  isEqual2.parseError = (error) => error;
  function padLeft2(value, size3) {
    return pad(value, { dir: "left", size: size3 });
  }
  padLeft2.parseError = (error) => error;
  function padRight2(value, size3) {
    return pad(value, { dir: "right", size: size3 });
  }
  padRight2.parseError = (error) => error;
  function random(length) {
    return crypto.getRandomValues(new Uint8Array(length));
  }
  random.parseError = (error) => error;
  function size(value) {
    return value.length;
  }
  size.parseError = (error) => error;
  function slice2(value, start, end, options = {}) {
    const { strict } = options;
    assertStartOffset(value, start);
    const value_ = value.slice(start, end);
    if (strict)
      assertEndOffset(value_, start, end);
    return value_;
  }
  slice2.parseError = (error) => error;
  function toBigInt2(bytes2, options = {}) {
    const { size: size3 } = options;
    if (typeof size3 !== "undefined")
      assertSize(bytes2, size3);
    const hex2 = fromBytes(bytes2, options);
    return toBigInt(hex2, options);
  }
  toBigInt2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function toBoolean2(bytes2, options = {}) {
    const { size: size3 } = options;
    let bytes_ = bytes2;
    if (typeof size3 !== "undefined") {
      assertSize(bytes_, size3);
      bytes_ = trimLeft2(bytes_);
    }
    if (bytes_.length > 1 || bytes_[0] > 1)
      throw new InvalidBytesBooleanError(bytes_);
    return Boolean(bytes_[0]);
  }
  toBoolean2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function toHex(value, options = {}) {
    return fromBytes(value, options);
  }
  toHex.parseError = (error) => error;
  function toNumber2(bytes2, options = {}) {
    const { size: size3 } = options;
    if (typeof size3 !== "undefined")
      assertSize(bytes2, size3);
    const hex2 = fromBytes(bytes2, options);
    return toNumber(hex2, options);
  }
  toNumber2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function toString2(bytes2, options = {}) {
    const { size: size3 } = options;
    let bytes_ = bytes2;
    if (typeof size3 !== "undefined") {
      assertSize(bytes_, size3);
      bytes_ = trimRight(bytes_);
    }
    return decoder.decode(bytes_);
  }
  toString2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function trimLeft2(value) {
    return trim(value, { dir: "left" });
  }
  trimLeft2.parseError = (error) => error;
  function trimRight(value) {
    return trim(value, { dir: "right" });
  }
  trimRight.parseError = (error) => error;
  function validate2(value) {
    try {
      assert2(value);
      return true;
    } catch {
      return false;
    }
  }
  validate2.parseError = (error) => error;
  var InvalidBytesBooleanError = class extends BaseError2 {
    constructor(bytes2) {
      super(`Bytes value \`${bytes2}\` is not a valid boolean.`, {
        metaMessages: [
          "The bytes array must contain a single byte of either a `0` or `1` value."
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Bytes.InvalidBytesBooleanError"
      });
    }
  };
  var InvalidBytesTypeError = class extends BaseError2 {
    constructor(value) {
      super(`Value \`${typeof value === "object" ? stringify(value) : value}\` of type \`${typeof value}\` is an invalid Bytes value.`, {
        metaMessages: ["Bytes values must be of type `Bytes`."]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Bytes.InvalidBytesTypeError"
      });
    }
  };
  var SizeOverflowError = class extends BaseError2 {
    constructor({ givenSize, maxSize }) {
      super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Bytes.SizeOverflowError"
      });
    }
  };
  var SliceOffsetOutOfBoundsError = class extends BaseError2 {
    constructor({ offset, position, size: size3 }) {
      super(`Slice ${position === "start" ? "starting" : "ending"} at offset \`${offset}\` is out-of-bounds (size: \`${size3}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Bytes.SliceOffsetOutOfBoundsError"
      });
    }
  };
  var SizeExceedsPaddingSizeError = class extends BaseError2 {
    constructor({ size: size3, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size3}\`) exceeds padding size (\`${targetSize}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Bytes.SizeExceedsPaddingSizeError"
      });
    }
  };

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/Hash.js
  function keccak256(value, options = {}) {
    const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
    const bytes2 = keccak_256(from2(value));
    if (as === "Bytes")
      return bytes2;
    return fromBytes(bytes2);
  }
  keccak256.parseError = (error) => error;
  function ripemd1602(value, options = {}) {
    const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
    const bytes2 = ripemd160(from2(value));
    if (as === "Bytes")
      return bytes2;
    return fromBytes(bytes2);
  }
  ripemd1602.parseError = (error) => error;
  function sha2562(value, options = {}) {
    const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
    const bytes2 = sha256(from2(value));
    if (as === "Bytes")
      return bytes2;
    return fromBytes(bytes2);
  }
  sha2562.parseError = (error) => error;
  function validate3(value) {
    return validate(value) && size2(value) === 32;
  }
  validate3.parseError = (error) => error;

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/internal/lru.js
  var LruMap = class extends Map {
    constructor(size3) {
      super();
      Object.defineProperty(this, "maxSize", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.maxSize = size3;
    }
    get(key) {
      const value = super.get(key);
      if (super.has(key) && value !== void 0) {
        this.delete(key);
        super.set(key, value);
      }
      return value;
    }
    set(key, value) {
      super.set(key, value);
      if (this.maxSize && this.size > this.maxSize) {
        const firstKey = this.keys().next().value;
        if (firstKey)
          this.delete(firstKey);
      }
      return this;
    }
  };

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/Caches.js
  var caches = {
    checksum: /* @__PURE__ */ new LruMap(8192)
  };
  var checksum = caches.checksum;

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/PublicKey.js
  function assert3(publicKey, options = {}) {
    const { compressed } = options;
    const { prefix, x: x2, y: y2 } = publicKey;
    if (compressed === false || typeof x2 === "bigint" && typeof y2 === "bigint") {
      if (prefix !== 4)
        throw new InvalidPrefixError({
          prefix,
          cause: new InvalidUncompressedPrefixError()
        });
      return;
    }
    if (compressed === true || typeof x2 === "bigint" && typeof y2 === "undefined") {
      if (prefix !== 3 && prefix !== 2)
        throw new InvalidPrefixError({
          prefix,
          cause: new InvalidCompressedPrefixError()
        });
      return;
    }
    throw new InvalidError({ publicKey });
  }
  function compress(publicKey) {
    const { x: x2, y: y2 } = publicKey;
    return {
      prefix: y2 % 2n === 0n ? 2 : 3,
      x: x2
    };
  }
  compress.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function from3(value) {
    const publicKey = (() => {
      if (validate(value))
        return fromHex2(value);
      if (validate2(value))
        return fromBytes2(value);
      const { prefix, x: x2, y: y2 } = value;
      if (typeof x2 === "bigint" && typeof y2 === "bigint")
        return { prefix: prefix ?? 4, x: x2, y: y2 };
      return { prefix, x: x2 };
    })();
    assert3(publicKey);
    return publicKey;
  }
  from3.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function fromBytes2(publicKey) {
    return fromHex2(fromBytes(publicKey));
  }
  fromBytes2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function fromHex2(publicKey) {
    if (publicKey.length !== 132 && publicKey.length !== 130 && publicKey.length !== 68)
      throw new InvalidSerializedSizeError({ publicKey });
    if (publicKey.length === 130) {
      const x3 = BigInt(slice(publicKey, 0, 32));
      const y2 = BigInt(slice(publicKey, 32, 64));
      return {
        prefix: 4,
        x: x3,
        y: y2
      };
    }
    if (publicKey.length === 132) {
      const prefix2 = Number(slice(publicKey, 0, 1));
      const x3 = BigInt(slice(publicKey, 1, 33));
      const y2 = BigInt(slice(publicKey, 33, 65));
      return {
        prefix: prefix2,
        x: x3,
        y: y2
      };
    }
    const prefix = Number(slice(publicKey, 0, 1));
    const x2 = BigInt(slice(publicKey, 1, 33));
    return {
      prefix,
      x: x2
    };
  }
  fromHex2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function toBytes3(publicKey, options = {}) {
    return fromHex(toHex2(publicKey, options));
  }
  toBytes3.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function toHex2(publicKey, options = {}) {
    assert3(publicKey);
    const { prefix, x: x2, y: y2 } = publicKey;
    const { includePrefix = true } = options;
    const publicKey_ = concat(
      includePrefix ? fromNumber(prefix, { size: 1 }) : "0x",
      fromNumber(x2, { size: 32 }),
      // If the public key is not compressed, add the y coordinate.
      typeof y2 === "bigint" ? fromNumber(y2, { size: 32 }) : "0x"
    );
    return publicKey_;
  }
  toHex2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  var InvalidError = class extends BaseError2 {
    constructor({ publicKey }) {
      super(`Value \`${stringify(publicKey)}\` is not a valid public key.`, {
        metaMessages: [
          "Public key must contain:",
          "- an `x` and `prefix` value (compressed)",
          "- an `x`, `y`, and `prefix` value (uncompressed)"
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "PublicKey.InvalidError"
      });
    }
  };
  var InvalidPrefixError = class extends BaseError2 {
    constructor({ prefix, cause }) {
      super(`Prefix "${prefix}" is invalid.`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "PublicKey.InvalidPrefixError"
      });
    }
  };
  var InvalidCompressedPrefixError = class extends BaseError2 {
    constructor() {
      super("Prefix must be 2 or 3 for compressed public keys.");
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "PublicKey.InvalidCompressedPrefixError"
      });
    }
  };
  var InvalidUncompressedPrefixError = class extends BaseError2 {
    constructor() {
      super("Prefix must be 4 for uncompressed public keys.");
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "PublicKey.InvalidUncompressedPrefixError"
      });
    }
  };
  var InvalidSerializedSizeError = class extends BaseError2 {
    constructor({ publicKey }) {
      super(`Value \`${publicKey}\` is an invalid public key size.`, {
        metaMessages: [
          "Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).",
          `Received ${size2(from(publicKey))} bytes.`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "PublicKey.InvalidSerializedSizeError"
      });
    }
  };

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/Address.js
  var addressRegex = /^0x[a-fA-F0-9]{40}$/;
  function assert4(value, options = {}) {
    const { strict = true } = options;
    if (!addressRegex.test(value))
      throw new InvalidAddressError({
        address: value,
        cause: new InvalidInputError()
      });
    if (strict) {
      if (value.toLowerCase() === value)
        return;
      if (checksum2(value) !== value)
        throw new InvalidAddressError({
          address: value,
          cause: new InvalidChecksumError()
        });
    }
  }
  assert4.parseError = (error) => error;
  function checksum2(address) {
    if (checksum.has(address))
      return checksum.get(address);
    assert4(address, { strict: false });
    const hexAddress = address.substring(2).toLowerCase();
    const hash = keccak256(fromString2(hexAddress), { as: "Bytes" });
    const characters = hexAddress.split("");
    for (let i2 = 0; i2 < 40; i2 += 2) {
      if (hash[i2 >> 1] >> 4 >= 8 && characters[i2]) {
        characters[i2] = characters[i2].toUpperCase();
      }
      if ((hash[i2 >> 1] & 15) >= 8 && characters[i2 + 1]) {
        characters[i2 + 1] = characters[i2 + 1].toUpperCase();
      }
    }
    const result = `0x${characters.join("")}`;
    checksum.set(address, result);
    return result;
  }
  checksum2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function from4(address, options = {}) {
    const { checksum: checksumVal = false } = options;
    assert4(address);
    if (checksumVal)
      return checksum2(address);
    return address;
  }
  from4.parseError = (error) => error;
  function fromPublicKey(publicKey, options = {}) {
    const address = keccak256(`0x${toHex2(publicKey).slice(4)}`).substring(26);
    return from4(`0x${address}`, options);
  }
  fromPublicKey.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function isEqual3(addressA, addressB) {
    assert4(addressA, { strict: false });
    assert4(addressB, { strict: false });
    return addressA.toLowerCase() === addressB.toLowerCase();
  }
  isEqual3.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  var InvalidAddressError = class extends BaseError2 {
    constructor({ address, cause }) {
      super(`Address "${address}" is invalid.`, {
        cause
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Address.InvalidAddressError"
      });
    }
  };
  var InvalidInputError = class extends BaseError2 {
    constructor() {
      super("Address is not a 20 byte (40 hexadecimal character) value.");
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Address.InvalidInputError"
      });
    }
  };
  var InvalidChecksumError = class extends BaseError2 {
    constructor() {
      super("Address does not match its checksum counterpart.");
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Address.InvalidChecksumError"
      });
    }
  };

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/AbiParameters.js
  var AbiParameters_exports = {};
  __export(AbiParameters_exports, {
    ArrayLengthMismatchError: () => ArrayLengthMismatchError,
    BytesSizeMismatchError: () => BytesSizeMismatchError,
    DataSizeTooSmallError: () => DataSizeTooSmallError,
    InvalidArrayError: () => InvalidArrayError,
    InvalidTypeError: () => InvalidTypeError,
    LengthMismatchError: () => LengthMismatchError,
    ZeroDataError: () => ZeroDataError,
    decode: () => decode,
    encode: () => encode2,
    encodePacked: () => encodePacked,
    format: () => format,
    from: () => from5
  });

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/Solidity.js
  var arrayRegex = /^(.*)\[([0-9]*)\]$/;
  var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  var maxInt8 = 2n ** (8n - 1n) - 1n;
  var maxInt16 = 2n ** (16n - 1n) - 1n;
  var maxInt24 = 2n ** (24n - 1n) - 1n;
  var maxInt32 = 2n ** (32n - 1n) - 1n;
  var maxInt40 = 2n ** (40n - 1n) - 1n;
  var maxInt48 = 2n ** (48n - 1n) - 1n;
  var maxInt56 = 2n ** (56n - 1n) - 1n;
  var maxInt64 = 2n ** (64n - 1n) - 1n;
  var maxInt72 = 2n ** (72n - 1n) - 1n;
  var maxInt80 = 2n ** (80n - 1n) - 1n;
  var maxInt88 = 2n ** (88n - 1n) - 1n;
  var maxInt96 = 2n ** (96n - 1n) - 1n;
  var maxInt104 = 2n ** (104n - 1n) - 1n;
  var maxInt112 = 2n ** (112n - 1n) - 1n;
  var maxInt120 = 2n ** (120n - 1n) - 1n;
  var maxInt128 = 2n ** (128n - 1n) - 1n;
  var maxInt136 = 2n ** (136n - 1n) - 1n;
  var maxInt144 = 2n ** (144n - 1n) - 1n;
  var maxInt152 = 2n ** (152n - 1n) - 1n;
  var maxInt160 = 2n ** (160n - 1n) - 1n;
  var maxInt168 = 2n ** (168n - 1n) - 1n;
  var maxInt176 = 2n ** (176n - 1n) - 1n;
  var maxInt184 = 2n ** (184n - 1n) - 1n;
  var maxInt192 = 2n ** (192n - 1n) - 1n;
  var maxInt200 = 2n ** (200n - 1n) - 1n;
  var maxInt208 = 2n ** (208n - 1n) - 1n;
  var maxInt216 = 2n ** (216n - 1n) - 1n;
  var maxInt224 = 2n ** (224n - 1n) - 1n;
  var maxInt232 = 2n ** (232n - 1n) - 1n;
  var maxInt240 = 2n ** (240n - 1n) - 1n;
  var maxInt248 = 2n ** (248n - 1n) - 1n;
  var maxInt256 = 2n ** (256n - 1n) - 1n;
  var minInt8 = -(2n ** (8n - 1n));
  var minInt16 = -(2n ** (16n - 1n));
  var minInt24 = -(2n ** (24n - 1n));
  var minInt32 = -(2n ** (32n - 1n));
  var minInt40 = -(2n ** (40n - 1n));
  var minInt48 = -(2n ** (48n - 1n));
  var minInt56 = -(2n ** (56n - 1n));
  var minInt64 = -(2n ** (64n - 1n));
  var minInt72 = -(2n ** (72n - 1n));
  var minInt80 = -(2n ** (80n - 1n));
  var minInt88 = -(2n ** (88n - 1n));
  var minInt96 = -(2n ** (96n - 1n));
  var minInt104 = -(2n ** (104n - 1n));
  var minInt112 = -(2n ** (112n - 1n));
  var minInt120 = -(2n ** (120n - 1n));
  var minInt128 = -(2n ** (128n - 1n));
  var minInt136 = -(2n ** (136n - 1n));
  var minInt144 = -(2n ** (144n - 1n));
  var minInt152 = -(2n ** (152n - 1n));
  var minInt160 = -(2n ** (160n - 1n));
  var minInt168 = -(2n ** (168n - 1n));
  var minInt176 = -(2n ** (176n - 1n));
  var minInt184 = -(2n ** (184n - 1n));
  var minInt192 = -(2n ** (192n - 1n));
  var minInt200 = -(2n ** (200n - 1n));
  var minInt208 = -(2n ** (208n - 1n));
  var minInt216 = -(2n ** (216n - 1n));
  var minInt224 = -(2n ** (224n - 1n));
  var minInt232 = -(2n ** (232n - 1n));
  var minInt240 = -(2n ** (240n - 1n));
  var minInt248 = -(2n ** (248n - 1n));
  var minInt256 = -(2n ** (256n - 1n));
  var maxUint8 = 2n ** 8n - 1n;
  var maxUint16 = 2n ** 16n - 1n;
  var maxUint24 = 2n ** 24n - 1n;
  var maxUint32 = 2n ** 32n - 1n;
  var maxUint40 = 2n ** 40n - 1n;
  var maxUint48 = 2n ** 48n - 1n;
  var maxUint56 = 2n ** 56n - 1n;
  var maxUint64 = 2n ** 64n - 1n;
  var maxUint72 = 2n ** 72n - 1n;
  var maxUint80 = 2n ** 80n - 1n;
  var maxUint88 = 2n ** 88n - 1n;
  var maxUint96 = 2n ** 96n - 1n;
  var maxUint104 = 2n ** 104n - 1n;
  var maxUint112 = 2n ** 112n - 1n;
  var maxUint120 = 2n ** 120n - 1n;
  var maxUint128 = 2n ** 128n - 1n;
  var maxUint136 = 2n ** 136n - 1n;
  var maxUint144 = 2n ** 144n - 1n;
  var maxUint152 = 2n ** 152n - 1n;
  var maxUint160 = 2n ** 160n - 1n;
  var maxUint168 = 2n ** 168n - 1n;
  var maxUint176 = 2n ** 176n - 1n;
  var maxUint184 = 2n ** 184n - 1n;
  var maxUint192 = 2n ** 192n - 1n;
  var maxUint200 = 2n ** 200n - 1n;
  var maxUint208 = 2n ** 208n - 1n;
  var maxUint216 = 2n ** 216n - 1n;
  var maxUint224 = 2n ** 224n - 1n;
  var maxUint232 = 2n ** 232n - 1n;
  var maxUint240 = 2n ** 240n - 1n;
  var maxUint248 = 2n ** 248n - 1n;
  var maxUint256 = 2n ** 256n - 1n;

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/internal/abiParameters.js
  function decodeParameter(cursor, param, { staticPosition }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return decodeArray(cursor, { ...param, type }, { length, staticPosition });
    }
    if (param.type === "tuple")
      return decodeTuple(cursor, param, { staticPosition });
    if (param.type === "address")
      return decodeAddress(cursor);
    if (param.type === "bool")
      return decodeBool(cursor);
    if (param.type.startsWith("bytes"))
      return decodeBytes(cursor, param, { staticPosition });
    if (param.type.startsWith("uint") || param.type.startsWith("int"))
      return decodeNumber(cursor, param);
    if (param.type === "string")
      return decodeString(cursor, { staticPosition });
    throw new InvalidTypeError(param.type);
  }
  var sizeOfLength = 32;
  var sizeOfOffset = 32;
  function decodeAddress(cursor) {
    const value = cursor.readBytes(32);
    return [fromBytes(slice2(value, -20)), 32];
  }
  function decodeArray(cursor, param, { length, staticPosition }) {
    if (!length) {
      const offset = toNumber2(cursor.readBytes(sizeOfOffset));
      const start = staticPosition + offset;
      const startOfData = start + sizeOfLength;
      cursor.setPosition(start);
      const length2 = toNumber2(cursor.readBytes(sizeOfLength));
      const dynamicChild = hasDynamicChild(param);
      let consumed2 = 0;
      const value2 = [];
      for (let i2 = 0; i2 < length2; ++i2) {
        cursor.setPosition(startOfData + (dynamicChild ? i2 * 32 : consumed2));
        const [data, consumed_] = decodeParameter(cursor, param, {
          staticPosition: startOfData
        });
        consumed2 += consumed_;
        value2.push(data);
      }
      cursor.setPosition(staticPosition + 32);
      return [value2, 32];
    }
    if (hasDynamicChild(param)) {
      const offset = toNumber2(cursor.readBytes(sizeOfOffset));
      const start = staticPosition + offset;
      const value2 = [];
      for (let i2 = 0; i2 < length; ++i2) {
        cursor.setPosition(start + i2 * 32);
        const [data] = decodeParameter(cursor, param, {
          staticPosition: start
        });
        value2.push(data);
      }
      cursor.setPosition(staticPosition + 32);
      return [value2, 32];
    }
    let consumed = 0;
    const value = [];
    for (let i2 = 0; i2 < length; ++i2) {
      const [data, consumed_] = decodeParameter(cursor, param, {
        staticPosition: staticPosition + consumed
      });
      consumed += consumed_;
      value.push(data);
    }
    return [value, consumed];
  }
  function decodeBool(cursor) {
    return [toBoolean2(cursor.readBytes(32), { size: 32 }), 32];
  }
  function decodeBytes(cursor, param, { staticPosition }) {
    const [_, size3] = param.type.split("bytes");
    if (!size3) {
      const offset = toNumber2(cursor.readBytes(32));
      cursor.setPosition(staticPosition + offset);
      const length = toNumber2(cursor.readBytes(32));
      if (length === 0) {
        cursor.setPosition(staticPosition + 32);
        return ["0x", 32];
      }
      const data = cursor.readBytes(length);
      cursor.setPosition(staticPosition + 32);
      return [fromBytes(data), 32];
    }
    const value = fromBytes(cursor.readBytes(Number.parseInt(size3), 32));
    return [value, 32];
  }
  function decodeNumber(cursor, param) {
    const signed = param.type.startsWith("int");
    const size3 = Number.parseInt(param.type.split("int")[1] || "256");
    const value = cursor.readBytes(32);
    return [
      size3 > 48 ? toBigInt2(value, { signed }) : toNumber2(value, { signed }),
      32
    ];
  }
  function decodeTuple(cursor, param, { staticPosition }) {
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    if (hasDynamicChild(param)) {
      const offset = toNumber2(cursor.readBytes(sizeOfOffset));
      const start = staticPosition + offset;
      for (let i2 = 0; i2 < param.components.length; ++i2) {
        const component = param.components[i2];
        cursor.setPosition(start + consumed);
        const [data, consumed_] = decodeParameter(cursor, component, {
          staticPosition: start
        });
        consumed += consumed_;
        value[hasUnnamedChild ? i2 : component?.name] = data;
      }
      cursor.setPosition(staticPosition + 32);
      return [value, 32];
    }
    for (let i2 = 0; i2 < param.components.length; ++i2) {
      const component = param.components[i2];
      const [data, consumed_] = decodeParameter(cursor, component, {
        staticPosition
      });
      value[hasUnnamedChild ? i2 : component?.name] = data;
      consumed += consumed_;
    }
    return [value, consumed];
  }
  function decodeString(cursor, { staticPosition }) {
    const offset = toNumber2(cursor.readBytes(32));
    const start = staticPosition + offset;
    cursor.setPosition(start);
    const length = toNumber2(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["", 32];
    }
    const data = cursor.readBytes(length, 32);
    const value = toString2(trimLeft2(data));
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
  }
  function prepareParameters({ parameters, values }) {
    const preparedParameters = [];
    for (let i2 = 0; i2 < parameters.length; i2++) {
      preparedParameters.push(prepareParameter({ parameter: parameters[i2], value: values[i2] }));
    }
    return preparedParameters;
  }
  function prepareParameter({ parameter: parameter_, value }) {
    const parameter = parameter_;
    const arrayComponents = getArrayComponents(parameter.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return encodeArray(value, {
        length,
        parameter: {
          ...parameter,
          type
        }
      });
    }
    if (parameter.type === "tuple") {
      return encodeTuple(value, {
        parameter
      });
    }
    if (parameter.type === "address") {
      return encodeAddress(value);
    }
    if (parameter.type === "bool") {
      return encodeBoolean(value);
    }
    if (parameter.type.startsWith("uint") || parameter.type.startsWith("int")) {
      const signed = parameter.type.startsWith("int");
      return encodeNumber(value, { signed });
    }
    if (parameter.type.startsWith("bytes")) {
      return encodeBytes(value, { type: parameter.type });
    }
    if (parameter.type === "string") {
      return encodeString(value);
    }
    throw new InvalidTypeError(parameter.type);
  }
  function encode(preparedParameters) {
    let staticSize = 0;
    for (let i2 = 0; i2 < preparedParameters.length; i2++) {
      const { dynamic, encoded } = preparedParameters[i2];
      if (dynamic)
        staticSize += 32;
      else
        staticSize += size2(encoded);
    }
    const staticParameters = [];
    const dynamicParameters = [];
    let dynamicSize = 0;
    for (let i2 = 0; i2 < preparedParameters.length; i2++) {
      const { dynamic, encoded } = preparedParameters[i2];
      if (dynamic) {
        staticParameters.push(fromNumber(staticSize + dynamicSize, { size: 32 }));
        dynamicParameters.push(encoded);
        dynamicSize += size2(encoded);
      } else {
        staticParameters.push(encoded);
      }
    }
    return concat(...staticParameters, ...dynamicParameters);
  }
  function encodeAddress(value) {
    assert4(value, { strict: false });
    return {
      dynamic: false,
      encoded: padLeft(value.toLowerCase())
    };
  }
  function encodeArray(value, { length, parameter }) {
    const dynamic = length === null;
    if (!Array.isArray(value))
      throw new InvalidArrayError(value);
    if (!dynamic && value.length !== length)
      throw new ArrayLengthMismatchError({
        expectedLength: length,
        givenLength: value.length,
        type: `${parameter.type}[${length}]`
      });
    let dynamicChild = false;
    const preparedParameters = [];
    for (let i2 = 0; i2 < value.length; i2++) {
      const preparedParam = prepareParameter({ parameter, value: value[i2] });
      if (preparedParam.dynamic)
        dynamicChild = true;
      preparedParameters.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
      const data = encode(preparedParameters);
      if (dynamic) {
        const length2 = fromNumber(preparedParameters.length, { size: 32 });
        return {
          dynamic: true,
          encoded: preparedParameters.length > 0 ? concat(length2, data) : length2
        };
      }
      if (dynamicChild)
        return { dynamic: true, encoded: data };
    }
    return {
      dynamic: false,
      encoded: concat(...preparedParameters.map(({ encoded }) => encoded))
    };
  }
  function encodeBytes(value, { type }) {
    const [, parametersize] = type.split("bytes");
    const bytesSize = size2(value);
    if (!parametersize) {
      let value_ = value;
      if (bytesSize % 32 !== 0)
        value_ = padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);
      return {
        dynamic: true,
        encoded: concat(padLeft(fromNumber(bytesSize, { size: 32 })), value_)
      };
    }
    if (bytesSize !== Number.parseInt(parametersize))
      throw new BytesSizeMismatchError({
        expectedSize: Number.parseInt(parametersize),
        value
      });
    return { dynamic: false, encoded: padRight(value) };
  }
  function encodeBoolean(value) {
    if (typeof value !== "boolean")
      throw new BaseError2(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
    return { dynamic: false, encoded: padLeft(fromBoolean(value)) };
  }
  function encodeNumber(value, { signed }) {
    return {
      dynamic: false,
      encoded: fromNumber(value, {
        size: 32,
        signed
      })
    };
  }
  function encodeString(value) {
    const hexValue = fromString(value);
    const partsLength = Math.ceil(size2(hexValue) / 32);
    const parts = [];
    for (let i2 = 0; i2 < partsLength; i2++) {
      parts.push(padRight(slice(hexValue, i2 * 32, (i2 + 1) * 32)));
    }
    return {
      dynamic: true,
      encoded: concat(padRight(fromNumber(size2(hexValue), { size: 32 })), ...parts)
    };
  }
  function encodeTuple(value, { parameter }) {
    let dynamic = false;
    const preparedParameters = [];
    for (let i2 = 0; i2 < parameter.components.length; i2++) {
      const param_ = parameter.components[i2];
      const index2 = Array.isArray(value) ? i2 : param_.name;
      const preparedParam = prepareParameter({
        parameter: param_,
        value: value[index2]
      });
      preparedParameters.push(preparedParam);
      if (preparedParam.dynamic)
        dynamic = true;
    }
    return {
      dynamic,
      encoded: dynamic ? encode(preparedParameters) : concat(...preparedParameters.map(({ encoded }) => encoded))
    };
  }
  function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? (
      // Return `null` if the array is dynamic.
      [matches[2] ? Number(matches[2]) : null, matches[1]]
    ) : void 0;
  }
  function hasDynamicChild(param) {
    const { type } = param;
    if (type === "string")
      return true;
    if (type === "bytes")
      return true;
    if (type.endsWith("[]"))
      return true;
    if (type === "tuple")
      return param.components?.some(hasDynamicChild);
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents && hasDynamicChild({
      ...param,
      type: arrayComponents[1]
    }))
      return true;
    return false;
  }

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/internal/cursor.js
  var staticCursor = {
    bytes: new Uint8Array(),
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: /* @__PURE__ */ new Map(),
    recursiveReadCount: 0,
    recursiveReadLimit: Number.POSITIVE_INFINITY,
    assertReadLimit() {
      if (this.recursiveReadCount >= this.recursiveReadLimit)
        throw new RecursiveReadLimitExceededError({
          count: this.recursiveReadCount + 1,
          limit: this.recursiveReadLimit
        });
    },
    assertPosition(position) {
      if (position < 0 || position > this.bytes.length - 1)
        throw new PositionOutOfBoundsError({
          length: this.bytes.length,
          position
        });
    },
    decrementPosition(offset) {
      if (offset < 0)
        throw new NegativeOffsetError({ offset });
      const position = this.position - offset;
      this.assertPosition(position);
      this.position = position;
    },
    getReadCount(position) {
      return this.positionReadCount.get(position || this.position) || 0;
    },
    incrementPosition(offset) {
      if (offset < 0)
        throw new NegativeOffsetError({ offset });
      const position = this.position + offset;
      this.assertPosition(position);
      this.position = position;
    },
    inspectByte(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectBytes(length, position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + length - 1);
      return this.bytes.subarray(position, position + length);
    },
    inspectUint8(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectUint16(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 1);
      return this.dataView.getUint16(position);
    },
    inspectUint24(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 2);
      return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
    },
    inspectUint32(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 3);
      return this.dataView.getUint32(position);
    },
    pushByte(byte) {
      this.assertPosition(this.position);
      this.bytes[this.position] = byte;
      this.position++;
    },
    pushBytes(bytes2) {
      this.assertPosition(this.position + bytes2.length - 1);
      this.bytes.set(bytes2, this.position);
      this.position += bytes2.length;
    },
    pushUint8(value) {
      this.assertPosition(this.position);
      this.bytes[this.position] = value;
      this.position++;
    },
    pushUint16(value) {
      this.assertPosition(this.position + 1);
      this.dataView.setUint16(this.position, value);
      this.position += 2;
    },
    pushUint24(value) {
      this.assertPosition(this.position + 2);
      this.dataView.setUint16(this.position, value >> 8);
      this.dataView.setUint8(this.position + 2, value & ~4294967040);
      this.position += 3;
    },
    pushUint32(value) {
      this.assertPosition(this.position + 3);
      this.dataView.setUint32(this.position, value);
      this.position += 4;
    },
    readByte() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectByte();
      this.position++;
      return value;
    },
    readBytes(length, size3) {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectBytes(length);
      this.position += size3 ?? length;
      return value;
    },
    readUint8() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint8();
      this.position += 1;
      return value;
    },
    readUint16() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint16();
      this.position += 2;
      return value;
    },
    readUint24() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint24();
      this.position += 3;
      return value;
    },
    readUint32() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint32();
      this.position += 4;
      return value;
    },
    get remaining() {
      return this.bytes.length - this.position;
    },
    setPosition(position) {
      const oldPosition = this.position;
      this.assertPosition(position);
      this.position = position;
      return () => this.position = oldPosition;
    },
    _touch() {
      if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
        return;
      const count3 = this.getReadCount();
      this.positionReadCount.set(this.position, count3 + 1);
      if (count3 > 0)
        this.recursiveReadCount++;
    }
  };
  function create(bytes2, { recursiveReadLimit = 8192 } = {}) {
    const cursor = Object.create(staticCursor);
    cursor.bytes = bytes2;
    cursor.dataView = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
    cursor.positionReadCount = /* @__PURE__ */ new Map();
    cursor.recursiveReadLimit = recursiveReadLimit;
    return cursor;
  }
  var NegativeOffsetError = class extends BaseError2 {
    constructor({ offset }) {
      super(`Offset \`${offset}\` cannot be negative.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Cursor.NegativeOffsetError"
      });
    }
  };
  var PositionOutOfBoundsError = class extends BaseError2 {
    constructor({ length, position }) {
      super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Cursor.PositionOutOfBoundsError"
      });
    }
  };
  var RecursiveReadLimitExceededError = class extends BaseError2 {
    constructor({ count: count3, limit }) {
      super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count3}\`).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Cursor.RecursiveReadLimitExceededError"
      });
    }
  };

  // ../../node_modules/.pnpm/ox@0.1.0_typescript@5.3.3_zod@3.23.8/node_modules/ox/_esm/AbiParameters.js
  function decode(parameters, data, options = {}) {
    const { as = "Array" } = options;
    const bytes2 = typeof data === "string" ? fromHex(data) : data;
    const cursor = create(bytes2);
    if (size(bytes2) === 0 && parameters.length > 0)
      throw new ZeroDataError();
    if (size(bytes2) && size(bytes2) < 32)
      throw new DataSizeTooSmallError({
        data: typeof data === "string" ? data : fromBytes(data),
        parameters,
        size: size(bytes2)
      });
    let consumed = 0;
    const values = as === "Array" ? [] : {};
    for (let i2 = 0; i2 < parameters.length; ++i2) {
      const param = parameters[i2];
      cursor.setPosition(consumed);
      const [data2, consumed_] = decodeParameter(cursor, param, {
        staticPosition: 0
      });
      consumed += consumed_;
      if (as === "Array")
        values.push(data2);
      else
        values[param.name ?? i2] = data2;
    }
    return values;
  }
  decode.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function encode2(parameters, values) {
    if (parameters.length !== values.length)
      throw new LengthMismatchError({
        expectedLength: parameters.length,
        givenLength: values.length
      });
    const preparedParameters = prepareParameters({
      parameters,
      values
    });
    const data = encode(preparedParameters);
    if (data.length === 0)
      return "0x";
    return data;
  }
  encode2.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function encodePacked(types, values) {
    if (types.length !== values.length)
      throw new LengthMismatchError({
        expectedLength: types.length,
        givenLength: values.length
      });
    const data = [];
    for (let i2 = 0; i2 < types.length; i2++) {
      const type = types[i2];
      const value = values[i2];
      data.push(encodePacked.encode(type, value));
    }
    return concat(...data);
  }
  (function(encodePacked2) {
    function encode3(type, value, isArray = false) {
      if (type === "address") {
        const address = value;
        assert4(address);
        return padLeft(address.toLowerCase(), isArray ? 32 : 0);
      }
      if (type === "string")
        return fromString(value);
      if (type === "bytes")
        return value;
      if (type === "bool")
        return padLeft(fromBoolean(value), isArray ? 32 : 1);
      const intMatch = type.match(integerRegex2);
      if (intMatch) {
        const [_type, baseType, bits = "256"] = intMatch;
        const size3 = Number.parseInt(bits) / 8;
        return fromNumber(value, {
          size: isArray ? 32 : size3,
          signed: baseType === "int"
        });
      }
      const bytesMatch = type.match(bytesRegex2);
      if (bytesMatch) {
        const [_type, size3] = bytesMatch;
        if (Number.parseInt(size3) !== (value.length - 2) / 2)
          throw new BytesSizeMismatchError({
            expectedSize: Number.parseInt(size3),
            value
          });
        return padRight(value, isArray ? 32 : 0);
      }
      const arrayMatch = type.match(arrayRegex);
      if (arrayMatch && Array.isArray(value)) {
        const [_type, childType] = arrayMatch;
        const data = [];
        for (let i2 = 0; i2 < value.length; i2++) {
          data.push(encode3(childType, value[i2], true));
        }
        if (data.length === 0)
          return "0x";
        return concat(...data);
      }
      throw new InvalidTypeError(type);
    }
    encodePacked2.encode = encode3;
  })(encodePacked || (encodePacked = {}));
  encodePacked.parseError = (error) => error;
  function format(parameters) {
    return formatAbiParameters(parameters);
  }
  format.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  function from5(parameters) {
    if (Array.isArray(parameters) && typeof parameters[0] === "string")
      return parseAbiParameters(parameters);
    if (typeof parameters === "string")
      return parseAbiParameters(parameters);
    return parameters;
  }
  from5.parseError = (error) => (
    /* v8 ignore next */
    error
  );
  var DataSizeTooSmallError = class extends BaseError2 {
    constructor({ data, parameters, size: size3 }) {
      super(`Data size of ${size3} bytes is too small for given parameters.`, {
        metaMessages: [
          `Params: (${formatAbiParameters(parameters)})`,
          `Data:   ${data} (${size3} bytes)`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiParameters.DataSizeTooSmallError"
      });
    }
  };
  var ZeroDataError = class extends BaseError2 {
    constructor() {
      super('Cannot decode zero data ("0x") with ABI parameters.');
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiParameters.ZeroDataError"
      });
    }
  };
  var ArrayLengthMismatchError = class extends BaseError2 {
    constructor({ expectedLength, givenLength, type }) {
      super(`Array length mismatch for type \`${type}\`. Expected: \`${expectedLength}\`. Given: \`${givenLength}\`.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiParameters.ArrayLengthMismatchError"
      });
    }
  };
  var BytesSizeMismatchError = class extends BaseError2 {
    constructor({ expectedSize, value }) {
      super(`Size of bytes "${value}" (bytes${size2(value)}) does not match expected size (bytes${expectedSize}).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiParameters.BytesSizeMismatchError"
      });
    }
  };
  var LengthMismatchError = class extends BaseError2 {
    constructor({ expectedLength, givenLength }) {
      super([
        "ABI encoding parameters/values length mismatch.",
        `Expected length (parameters): ${expectedLength}`,
        `Given length (values): ${givenLength}`
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiParameters.LengthMismatchError"
      });
    }
  };
  var InvalidArrayError = class extends BaseError2 {
    constructor(value) {
      super(`Value \`${value}\` is not a valid array.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiParameters.InvalidArrayError"
      });
    }
  };
  var InvalidTypeError = class extends BaseError2 {
    constructor(type) {
      super(`Type \`${type}\` is not a valid ABI Type.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiParameters.InvalidTypeError"
      });
    }
  };

  // ../core/build/chunk-HZ2SQA5V.js
  function hashToField(input) {
    if (Bytes_exports.validate(input) || Hex_exports.validate(input)) return hashEncodedBytes(input);
    return hashString(input);
  }
  function packAndEncode(input) {
    const [types, values] = input.reduce(
      ([types2, values2], [type, value]) => {
        types2.push(type);
        values2.push(value);
        return [types2, values2];
      },
      [[], []]
    );
    return hashEncodedBytes(AbiParameters_exports.encodePacked(types, values));
  }
  function hashString(input) {
    const bytesInput = import_buffer.Buffer.from(input);
    return hashEncodedBytes(bytesInput);
  }
  function hashEncodedBytes(input) {
    const hash = BigInt(Hash_exports.keccak256(input, { as: "Hex" })) >> 8n;
    const rawDigest = hash.toString(16);
    return { hash, digest: `0x${rawDigest.padStart(64, "0")}` };
  }
  var generateSignal = (signal) => {
    if (!signal || typeof signal === "string") return hashToField(signal ?? "");
    return packAndEncode(signal.types.map((type, index2) => [type, signal.values[index2]]));
  };
  var encodeAction = (action) => {
    if (!action) return "";
    if (typeof action === "string") return action;
    return action.types.map((type, index2) => `${type}(${action.values[index2]})`).join(",");
  };

  // ../../node_modules/.pnpm/zustand@4.5.2_@types+react@18.0.25_react@18.2.0/node_modules/zustand/esm/vanilla.mjs
  var import_meta2 = {};
  var createStoreImpl2 = (createState2) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState2 = () => state;
    const getInitialState = () => initialState;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const destroy = () => {
      if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
        );
      }
      listeners.clear();
    };
    const api = { setState, getState: getState2, getInitialState, subscribe, destroy };
    const initialState = state = createState2(setState, getState2, api);
    return api;
  };
  var createStore2 = (createState2) => createState2 ? createStoreImpl2(createState2) : createStoreImpl2;

  // ../../node_modules/.pnpm/zustand@4.5.2_@types+react@18.0.25_react@18.2.0/node_modules/zustand/esm/index.mjs
  var import_react2 = __toESM(require_react(), 1);
  var import_with_selector2 = __toESM(require_with_selector(), 1);
  var import_meta3 = {};
  var { useDebugValue: useDebugValue2 } = import_react2.default;
  var { useSyncExternalStoreWithSelector: useSyncExternalStoreWithSelector2 } = import_with_selector2.default;
  var didWarnAboutEqualityFn = false;
  var identity2 = (arg) => arg;
  function useStore(api, selector = identity2, equalityFn) {
    if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
      console.warn(
        "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
      );
      didWarnAboutEqualityFn = true;
    }
    const slice3 = useSyncExternalStoreWithSelector2(
      api.subscribe,
      api.getState,
      api.getServerState || api.getInitialState,
      selector,
      equalityFn
    );
    useDebugValue2(slice3);
    return slice3;
  }
  var createImpl = (createState2) => {
    if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production" && typeof createState2 !== "function") {
      console.warn(
        "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
      );
    }
    const api = typeof createState2 === "function" ? createStore2(createState2) : createState2;
    const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
    Object.assign(useBoundStore, api);
    return useBoundStore;
  };
  var create2 = (createState2) => createState2 ? createImpl(createState2) : createImpl;

  // ../core/build/index.js
  var import_buffer2 = __toESM(require_buffer(), 1);
  var AppErrorCodes = /* @__PURE__ */ ((AppErrorCodes2) => {
    AppErrorCodes2["ConnectionFailed"] = "connection_failed";
    AppErrorCodes2["VerificationRejected"] = "verification_rejected";
    AppErrorCodes2["MaxVerificationsReached"] = "max_verifications_reached";
    AppErrorCodes2["CredentialUnavailable"] = "credential_unavailable";
    AppErrorCodes2["MalformedRequest"] = "malformed_request";
    AppErrorCodes2["InvalidNetwork"] = "invalid_network";
    AppErrorCodes2["InclusionProofFailed"] = "inclusion_proof_failed";
    AppErrorCodes2["InclusionProofPending"] = "inclusion_proof_pending";
    AppErrorCodes2["UnexpectedResponse"] = "unexpected_response";
    AppErrorCodes2["FailedByHostApp"] = "failed_by_host_app";
    AppErrorCodes2["GenericError"] = "generic_error";
    return AppErrorCodes2;
  })(AppErrorCodes || {});
  var VerificationState = /* @__PURE__ */ ((VerificationState2) => {
    VerificationState2["PreparingClient"] = "loading_widget";
    VerificationState2["WaitingForConnection"] = "awaiting_connection";
    VerificationState2["WaitingForApp"] = "awaiting_app";
    VerificationState2["Confirmed"] = "confirmed";
    VerificationState2["Failed"] = "failed";
    return VerificationState2;
  })(VerificationState || {});
  var VerificationLevel = /* @__PURE__ */ ((VerificationLevel2) => {
    VerificationLevel2["Orb"] = "orb";
    VerificationLevel2["SecureDocument"] = "secure_document";
    VerificationLevel2["Document"] = "document";
    VerificationLevel2["Device"] = "device";
    return VerificationLevel2;
  })(VerificationLevel || {});
  function validate_bridge_url(bridge_url, is_staging) {
    try {
      new URL(bridge_url);
    } catch (e2) {
      return { valid: false, errors: ["Failed to parse Bridge URL."] };
    }
    const test_url = new URL(bridge_url);
    const errors = [];
    if (is_staging && ["localhost", "127.0.0.1"].includes(test_url.hostname)) {
      console.log("Using staging app_id with localhost bridge_url. Skipping validation.");
      return { valid: true };
    }
    if (test_url.protocol !== "https:") {
      errors.push("Bridge URL must use HTTPS.");
    }
    if (test_url.port) {
      errors.push("Bridge URL must use the default port (443).");
    }
    if (test_url.pathname !== "/") {
      errors.push("Bridge URL must not have a path.");
    }
    if (test_url.search) {
      errors.push("Bridge URL must not have query parameters.");
    }
    if (test_url.hash) {
      errors.push("Bridge URL must not have a fragment.");
    }
    if (!test_url.hostname.endsWith(".worldcoin.org") && !test_url.hostname.endsWith(".toolsforhumanity.com")) {
      console.warn(
        "Bridge URL should be a subdomain of worldcoin.org or toolsforhumanity.com. The user's identity wallet may refuse to connect. This is a temporary measure and may be removed in the future."
      );
    }
    if (errors.length) {
      return { valid: false, errors };
    }
    return { valid: true };
  }
  var DEFAULT_VERIFICATION_LEVEL = "orb";
  var buffer_encode = (buffer) => {
    return import_buffer2.Buffer.from(buffer).toString("base64");
  };
  var buffer_decode = (encoded) => {
    return import_buffer2.Buffer.from(encoded, "base64");
  };
  var verification_level_to_credential_types = (verification_level) => {
    switch (verification_level) {
      case "device":
        return [
          "orb",
          "device"
          /* Device */
        ];
      case "document":
        return [
          "document",
          "secure_document",
          "orb"
          /* Orb */
        ];
      case "secure_document":
        return [
          "secure_document",
          "orb"
          /* Orb */
        ];
      case "orb":
        return [
          "orb"
          /* Orb */
        ];
      default:
        throw new Error(`Unknown verification level: ${verification_level}`);
    }
  };
  var credential_type_to_verification_level = (credential_type) => {
    switch (credential_type) {
      case "orb":
        return "orb";
      case "secure_document":
        return "secure_document";
      case "document":
        return "document";
      case "device":
        return "device";
      default:
        throw new Error(`Unknown credential_type: ${credential_type}`);
    }
  };
  var encoder3 = new TextEncoder();
  var decoder2 = new TextDecoder();
  var generateKey = async () => {
    return {
      iv: window.crypto.getRandomValues(new Uint8Array(12)),
      key: await window.crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"])
    };
  };
  var exportKey = async (key) => {
    return buffer_encode(await window.crypto.subtle.exportKey("raw", key));
  };
  var encryptRequest = async (key, iv, request) => {
    return {
      iv: buffer_encode(iv),
      payload: buffer_encode(
        await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, encoder3.encode(request))
      )
    };
  };
  var decryptResponse = async (key, iv, payload) => {
    return decoder2.decode(await window.crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, buffer_decode(payload)));
  };
  var DEFAULT_BRIDGE_URL = "https://bridge.worldcoin.org";
  var useWorldBridgeStore = create2((set, get) => ({
    iv: null,
    key: null,
    result: null,
    errorCode: null,
    requestId: null,
    connectorURI: null,
    bridge_url: DEFAULT_BRIDGE_URL,
    verificationState: "loading_widget",
    createClient: async ({ bridge_url, app_id, verification_level, action_description, action, signal, partner }) => {
      const { key, iv } = await generateKey();
      if (bridge_url) {
        const validation = validate_bridge_url(bridge_url, app_id.includes("staging"));
        if (!validation.valid) {
          console.error(validation.errors.join("\n"));
          set({
            verificationState: "failed"
            /* Failed */
          });
          throw new Error("Invalid bridge_url. Please check the console for more details.");
        }
      }
      const res = await fetch(new URL("/request", bridge_url ?? DEFAULT_BRIDGE_URL), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(
          await encryptRequest(
            key,
            iv,
            JSON.stringify({
              app_id,
              action_description,
              action: encodeAction(action),
              signal: generateSignal(signal).digest,
              credential_types: verification_level_to_credential_types(
                verification_level ?? DEFAULT_VERIFICATION_LEVEL
              ),
              verification_level: verification_level ?? DEFAULT_VERIFICATION_LEVEL
            })
          )
        )
      });
      if (!res.ok) {
        set({
          verificationState: "failed"
          /* Failed */
        });
        throw new Error("Failed to create client");
      }
      const { request_id } = await res.json();
      set({
        iv,
        key,
        requestId: request_id,
        bridge_url: bridge_url ?? DEFAULT_BRIDGE_URL,
        verificationState: "awaiting_connection",
        connectorURI: `https://world.org/verify?t=wld&i=${request_id}&k=${encodeURIComponent(
          await exportKey(key)
        )}${bridge_url && bridge_url !== DEFAULT_BRIDGE_URL ? `&b=${encodeURIComponent(bridge_url)}` : ""}${partner ? `&partner=${encodeURIComponent(true)}` : ""}`
      });
    },
    pollForUpdates: async () => {
      const key = get().key;
      if (!key) throw new Error("No keypair found. Please call `createClient` first.");
      const res = await fetch(new URL(`/response/${get().requestId}`, get().bridge_url));
      if (!res.ok) {
        return set({
          errorCode: "connection_failed",
          verificationState: "failed"
          /* Failed */
        });
      }
      const { response, status } = await res.json();
      if (status != "completed") {
        return set({
          verificationState: status == "retrieved" ? "awaiting_app" : "awaiting_connection"
          /* WaitingForConnection */
        });
      }
      let result = JSON.parse(
        await decryptResponse(key, buffer_decode(response.iv), response.payload)
      );
      if ("error_code" in result) {
        return set({
          errorCode: result.error_code,
          verificationState: "failed"
          /* Failed */
        });
      }
      if ("credential_type" in result) {
        result = {
          verification_level: credential_type_to_verification_level(result.credential_type),
          ...result
        };
      }
      set({
        result,
        key: null,
        requestId: null,
        connectorURI: null,
        verificationState: "confirmed"
        /* Confirmed */
      });
    },
    reset: () => {
      set({
        iv: null,
        key: null,
        result: null,
        errorCode: null,
        requestId: null,
        connectorURI: null,
        verificationState: "loading_widget"
        /* PreparingClient */
      });
    }
  }));

  // ../react/build/chunk-5OWPJUHG.js
  var import_react3 = __toESM(require_react(), 1);
  var import_qrcode = __toESM(require_qrcode(), 1);
  var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
  var translations = {};
  var getLang = () => {
    if (!navigator?.languages) return;
    const supportedLang = navigator.languages.find((l2) => translations[l2] != void 0) ?? "";
    return translations[supportedLang];
  };
  var replaceParams = (str, params) => {
    let replaced = str;
    for (const [key, value] of Object.entries(params ?? {})) replaced = str.replace(`:${key}`, value);
    return replaced;
  };
  function __(str, params) {
    if (typeof navigator === "undefined") return str;
    return replaceParams(getLang()?.[str] ?? str, params);
  }
  var SELF_HOSTED_APP_ID = "self_hosted";
  var useIDKitStore = createWithEqualityFn()(
    (set, get) => ({
      app_id: "",
      signal: "",
      action: "",
      action_description: "",
      bridge_url: "",
      verification_level: DEFAULT_VERIFICATION_LEVEL,
      partner: false,
      open: false,
      result: null,
      errorTitle: "",
      errorDetail: "",
      autoClose: true,
      errorState: null,
      processing: false,
      errorCallbacks: {},
      verifyCallbacks: {},
      successCallbacks: {},
      stage: "WORLD_ID",
      setStage: (stage) => set({ stage }),
      setErrorState: (errorState) => set({ errorState }),
      setProcessing: (processing) => set({ processing }),
      retryFlow: () => {
        set({ stage: "WORLD_ID", errorState: null });
      },
      addErrorCallback: (cb, source) => {
        set((state) => {
          state.errorCallbacks[source] = cb;
          return state;
        });
      },
      addSuccessCallback: (cb, source) => {
        set((state) => {
          state.successCallbacks[source] = cb;
          return state;
        });
      },
      addVerificationCallback: (cb, source) => {
        set((state) => {
          state.verifyCallbacks[source] = cb;
          return state;
        });
      },
      setOptions: ({
        handleVerify,
        onSuccess,
        signal,
        action,
        app_id,
        partner,
        onError,
        verification_level,
        action_description,
        bridge_url,
        autoClose,
        advanced
      }, source) => {
        set({
          signal,
          action,
          bridge_url,
          action_description,
          autoClose: autoClose ?? true,
          app_id: advanced?.self_hosted ? SELF_HOSTED_APP_ID : app_id,
          verification_level: verification_level ?? DEFAULT_VERIFICATION_LEVEL,
          partner
        });
        get().addSuccessCallback(onSuccess, source);
        if (onError) get().addErrorCallback(onError, source);
        if (handleVerify) get().addVerificationCallback(handleVerify, source);
      },
      handleVerify: (result) => {
        set({ stage: "HOST_APP_VERIFICATION", processing: false });
        Promise.all(Object.values(get().verifyCallbacks).map(async (cb) => cb?.(result))).then(
          () => {
            set({ stage: "SUCCESS", result });
            if (get().autoClose) setTimeout(() => get().onOpenChange(false), 2500);
          },
          (response) => {
            let errorMessage = void 0;
            if (response && typeof response === "object" && response.message) {
              errorMessage = response.message;
            }
            set({
              stage: "ERROR",
              errorState: {
                code: AppErrorCodes.FailedByHostApp,
                message: errorMessage ? __(errorMessage) : void 0
              }
            });
          }
        );
      },
      onOpenChange: (open2) => {
        if (open2) {
          return set({ open: open2 });
        }
        const errorState = get().errorState;
        if (get().stage === "ERROR" && errorState) {
          const callbacks = get().errorCallbacks;
          requestAnimationFrame(() => Object.values(callbacks).forEach((cb) => void cb?.(errorState)));
        }
        const result = get().result;
        if (get().stage == "SUCCESS" && result) {
          const callbacks = get().successCallbacks;
          requestAnimationFrame(() => Object.values(callbacks).forEach((cb) => void cb?.(result)));
        }
        set({
          open: open2,
          result: null,
          errorState: null,
          processing: false,
          stage: "WORLD_ID"
          /* WORLD_ID */
        });
      }
    }),
    shallow$1
  );
  var idkit_default = useIDKitStore;
  var ConfigSource = /* @__PURE__ */ ((ConfigSource2) => {
    ConfigSource2["HOOK"] = "hook";
    ConfigSource2["PROPS"] = "props";
    ConfigSource2["MANUAL"] = "manual";
    return ConfigSource2;
  })(ConfigSource || {});
  var generateMatrix = (data) => {
    const arr = import_qrcode.default.create(data, { errorCorrectionLevel: "M" }).modules.data;
    const sqrt = Math.sqrt(arr.length);
    return arr.reduce(
      (rows, key, index2) => {
        if (index2 % sqrt === 0) rows.push([key]);
        else rows[rows.length - 1].push(key);
        return rows;
      },
      []
    );
  };
  var Qrcode = ({ data, size: size3 = 300 }) => {
    const dots = (0, import_react3.useMemo)(() => {
      const dots2 = [];
      const matrix = generateMatrix(data);
      const cellSize = size3 / matrix.length;
      const qrList = [
        { x: 0, y: 0 },
        { x: 1, y: 0 },
        { x: 0, y: 1 }
      ];
      qrList.forEach(({ x: x2, y: y2 }) => {
        const x1 = (matrix.length - 7) * cellSize * x2;
        const y1 = (matrix.length - 7) * cellSize * y2;
        for (let i2 = 0; i2 < 3; i2++) {
          dots2.push(
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
              "rect",
              {
                fill: "currentColor",
                x: x1 + cellSize * i2,
                y: y1 + cellSize * i2,
                width: cellSize * (7 - i2 * 2),
                height: cellSize * (7 - i2 * 2),
                rx: (i2 - 2) * -5,
                ry: (i2 - 2) * -5,
                className: i2 % 3 === 0 ? "text-black" : i2 % 3 === 1 ? "text-white" : "text-black"
              },
              `${i2}-${x2}-${y2}`
            )
          );
        }
      });
      matrix.forEach((row, i2) => {
        row.forEach((_, j2) => {
          if (!matrix[i2][j2]) return;
          if (i2 < 7 && j2 < 7 || i2 > matrix.length - 8 && j2 < 7 || i2 < 7 && j2 > matrix.length - 8) return;
          dots2.push(
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
              "circle",
              {
                fill: "currentColor",
                r: cellSize / 3,
                cx: i2 * cellSize + cellSize / 2,
                cy: j2 * cellSize + cellSize / 2,
                className: "text-black dark:text-white"
              },
              `circle-${i2}-${j2}`
            )
          );
        });
      });
      return dots2;
    }, [size3, data]);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", { height: size3, width: size3, "data-test-id": "qr-code", children: dots });
  };
  var QRCode_default = (0, import_react3.memo)(Qrcode);

  // ../react/build/index.js
  var import_react32 = __toESM(require_react(), 1);
  var import_react33 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/react-shadow@19.1.0_prop-types@15.8.1_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/react-shadow/react-shadow.esm.js
  var import_react4 = __toESM(require_react());
  var import_react_dom = __toESM(require_react_dom());
  var import_prop_types = __toESM(require_prop_types());
  var s = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
  function f2(e2, r3) {
    return e2(r3 = { exports: {} }, r3.exports), r3.exports;
  }
  var p = f2(function(e2) {
    !function(r3) {
      var t2 = function(e3, r4, n3) {
        if (!i2(r4) || s2(r4) || f3(r4) || p2(r4) || u2(r4)) return r4;
        var o3, a3 = 0, c3 = 0;
        if (l2(r4)) for (o3 = [], c3 = r4.length; a3 < c3; a3++) o3.push(t2(e3, r4[a3], n3));
        else for (var d3 in o3 = {}, r4) Object.prototype.hasOwnProperty.call(r4, d3) && (o3[e3(d3, n3)] = t2(e3, r4[d3], n3));
        return o3;
      }, n2 = function(e3) {
        return d2(e3) ? e3 : (e3 = e3.replace(/[\-_\s]+(.)?/g, function(e4, r4) {
          return r4 ? r4.toUpperCase() : "";
        })).substr(0, 1).toLowerCase() + e3.substr(1);
      }, o2 = function(e3) {
        var r4 = n2(e3);
        return r4.substr(0, 1).toUpperCase() + r4.substr(1);
      }, a2 = function(e3, r4) {
        return function(e4, r5) {
          var t3 = (r5 = r5 || {}).separator || "_", n3 = r5.split || /(?=[A-Z])/;
          return e4.split(n3).join(t3);
        }(e3, r4).toLowerCase();
      }, c2 = Object.prototype.toString, u2 = function(e3) {
        return "function" == typeof e3;
      }, i2 = function(e3) {
        return e3 === Object(e3);
      }, l2 = function(e3) {
        return "[object Array]" == c2.call(e3);
      }, s2 = function(e3) {
        return "[object Date]" == c2.call(e3);
      }, f3 = function(e3) {
        return "[object RegExp]" == c2.call(e3);
      }, p2 = function(e3) {
        return "[object Boolean]" == c2.call(e3);
      }, d2 = function(e3) {
        return (e3 -= 0) == e3;
      }, y2 = function(e3, r4) {
        var t3 = r4 && "process" in r4 ? r4.process : r4;
        return "function" != typeof t3 ? e3 : function(r5, n3) {
          return t3(r5, e3, n3);
        };
      }, h2 = { camelize: n2, decamelize: a2, pascalize: o2, depascalize: a2, camelizeKeys: function(e3, r4) {
        return t2(y2(n2, r4), e3);
      }, decamelizeKeys: function(e3, r4) {
        return t2(y2(a2, r4), e3, r4);
      }, pascalizeKeys: function(e3, r4) {
        return t2(y2(o2, r4), e3);
      }, depascalizeKeys: function() {
        return this.decamelizeKeys.apply(this, arguments);
      } };
      e2.exports ? e2.exports = h2 : r3.humps = h2;
    }(s);
  }).decamelize;
  var d = f2(function(e2) {
    function r3() {
      return e2.exports = r3 = Object.assign || function(e3) {
        for (var r4 = 1; r4 < arguments.length; r4++) {
          var t2 = arguments[r4];
          for (var n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (e3[n2] = t2[n2]);
        }
        return e3;
      }, r3.apply(this, arguments);
    }
    e2.exports = r3;
  });
  var y = function(e2) {
    if (Array.isArray(e2)) return e2;
  };
  var h = function(e2, r3) {
    if ("undefined" != typeof Symbol && Symbol.iterator in Object(e2)) {
      var t2 = [], n2 = true, o2 = false, a2 = void 0;
      try {
        for (var c2, u2 = e2[Symbol.iterator](); !(n2 = (c2 = u2.next()).done) && (t2.push(c2.value), !r3 || t2.length !== r3); n2 = true) ;
      } catch (e3) {
        o2 = true, a2 = e3;
      } finally {
        try {
          n2 || null == u2.return || u2.return();
        } finally {
          if (o2) throw a2;
        }
      }
      return t2;
    }
  };
  var v = function(e2, r3) {
    (null == r3 || r3 > e2.length) && (r3 = e2.length);
    for (var t2 = 0, n2 = new Array(r3); t2 < r3; t2++) n2[t2] = e2[t2];
    return n2;
  };
  var m = function(e2, r3) {
    if (e2) {
      if ("string" == typeof e2) return v(e2, r3);
      var t2 = Object.prototype.toString.call(e2).slice(8, -1);
      return "Object" === t2 && e2.constructor && (t2 = e2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(e2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? v(e2, r3) : void 0;
    }
  };
  var b = function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  };
  var g = function(e2, r3) {
    return y(e2) || h(e2, r3) || m(e2, r3) || b();
  };
  var S = function(e2, r3) {
    if (null == e2) return {};
    var t2, n2, o2 = {}, a2 = Object.keys(e2);
    for (n2 = 0; n2 < a2.length; n2++) t2 = a2[n2], r3.indexOf(t2) >= 0 || (o2[t2] = e2[t2]);
    return o2;
  };
  var w = function(e2, r3) {
    if (null == e2) return {};
    var t2, n2, o2 = S(e2, r3);
    if (Object.getOwnPropertySymbols) {
      var a2 = Object.getOwnPropertySymbols(e2);
      for (n2 = 0; n2 < a2.length; n2++) t2 = a2[n2], r3.indexOf(t2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
    }
    return o2;
  };
  var O = (0, import_react4.createContext)(null);
  function j(e2) {
    var r3 = e2.root, t2 = e2.children;
    return (0, import_react_dom.createPortal)(t2, r3);
  }
  function x(n2) {
    var u2 = (0, import_react4.forwardRef)(function(o2, u3) {
      var i2, l2, s2 = o2.mode, f3 = o2.delegatesFocus, p2 = o2.styleSheets, y2 = o2.ssr, h2 = o2.children, v2 = w(o2, ["mode", "delegatesFocus", "styleSheets", "ssr", "children"]), m2 = (l2 = (0, import_react4.useRef)((i2 = u3) && i2.current), (0, import_react4.useEffect)(function() {
        i2 && (i2.current = l2.current);
      }, [i2]), l2), b2 = (0, import_react4.useState)(null), S2 = g(b2, 2), x2 = S2[0], z2 = S2[1], E = "node_".concat(s2).concat(f3);
      return (0, import_react4.useLayoutEffect)(function() {
        if (m2.current) try {
          if ("function" == typeof u3 && u3(m2.current), y2) {
            var e2 = m2.current.shadowRoot;
            return void z2(e2);
          }
          var r3 = m2.current.attachShadow({ mode: s2, delegatesFocus: f3 });
          p2.length > 0 && (r3.adoptedStyleSheets = p2), z2(r3);
        } catch (e3) {
          !function(e4) {
            var r4 = e4.error, t2 = e4.styleSheets, n3 = e4.root;
            switch (r4.name) {
              case "NotSupportedError":
                t2.length > 0 && (n3.adoptedStyleSheets = t2);
                break;
              default:
                throw r4;
            }
          }({ error: e3, styleSheets: p2, root: x2 });
        }
      }, [u3, m2, p2]), import_react4.default.createElement(import_react4.default.Fragment, null, import_react4.default.createElement(n2.tag, d({ key: E, ref: m2 }, v2), (x2 || y2) && import_react4.default.createElement(O.Provider, { value: x2 }, y2 ? import_react4.default.createElement("template", { shadowroot: "open" }, n2.render({ root: x2, ssr: y2, children: h2 })) : import_react4.default.createElement(j, { root: x2 }, n2.render({ root: x2, ssr: y2, children: h2 })))));
    });
    return u2.propTypes = { mode: import_prop_types.default.oneOf(["open", "closed"]), delegatesFocus: import_prop_types.default.bool, styleSheets: import_prop_types.default.arrayOf(import_prop_types.default.instanceOf(globalThis.CSSStyleSheet)), ssr: import_prop_types.default.bool, children: import_prop_types.default.node }, u2.defaultProps = { mode: "open", delegatesFocus: false, styleSheets: [], ssr: false, children: null }, u2;
  }
  j.propTypes = { root: import_prop_types.default.object.isRequired, children: import_prop_types.default.node }, j.defaultProps = { children: null };
  var z = /* @__PURE__ */ new Map();
  function A() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "core", t2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function(e3) {
      return e3.children;
    };
    return new Proxy(e2, { get: function(e3, n2) {
      var o2 = p(n2, { separator: "-" }), a2 = "".concat(r3, "-").concat(o2);
      return z.has(a2) || z.set(a2, x({ tag: o2, render: t2 })), z.get(a2);
    } });
  }
  var P = A();
  var react_shadow_esm_default = P;

  // ../react/build/index.js
  var import_react34 = __toESM(require_react(), 1);
  var import_react_dom3 = __toESM(require_react_dom(), 1);
  var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
  var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
  var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
  var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
  var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
  var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);

  // ../../node_modules/.pnpm/@radix-ui+react-toast@1.2.1_@types+react-dom@18.0.9_@types+react@18.0.25_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@radix-ui/react-toast/dist/index.mjs
  var React14 = __toESM(require_react(), 1);
  var ReactDOM4 = __toESM(require_react_dom(), 1);

  // ../../node_modules/.pnpm/@radix-ui+primitive@1.1.0/node_modules/@radix-ui/primitive/dist/index.mjs
  function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler?.(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented) {
        return ourEventHandler?.(event);
      }
    };
  }

  // ../../node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.0_@types+react@18.0.25_react@18.2.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var React = __toESM(require_react(), 1);
  function setRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  function composeRefs(...refs) {
    return (node) => refs.forEach((ref) => setRef(ref, node));
  }
  function useComposedRefs(...refs) {
    return React.useCallback(composeRefs(...refs), refs);
  }

  // ../../node_modules/.pnpm/@radix-ui+react-collection@1.1.0_@types+react-dom@18.0.9_@types+react@18.0.25_react-dom@18.2._pvmvtcspzgufffeoi55jvigoga/node_modules/@radix-ui/react-collection/dist/index.mjs
  var import_react5 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/@radix-ui+react-context@1.1.0_@types+react@18.0.25_react@18.2.0/node_modules/@radix-ui/react-context/dist/index.mjs
  var React2 = __toESM(require_react(), 1);
  var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
  function createContext2(rootComponentName, defaultContext) {
    const Context = React2.createContext(defaultContext);
    function Provider2(props) {
      const { children, ...context } = props;
      const value = React2.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Context.Provider, { value, children });
    }
    function useContext22(consumerName) {
      const context = React2.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [Provider2, useContext22];
  }
  function createContextScope(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function createContext32(rootComponentName, defaultContext) {
      const BaseContext = React2.createContext(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [...defaultContexts, defaultContext];
      function Provider2(props) {
        const { scope, children, ...context } = props;
        const Context = scope?.[scopeName][index2] || BaseContext;
        const value = React2.useMemo(() => context, Object.values(context));
        return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Context.Provider, { value, children });
      }
      function useContext22(consumerName, scope) {
        const Context = scope?.[scopeName][index2] || BaseContext;
        const context = React2.useContext(Context);
        if (context) return context;
        if (defaultContext !== void 0) return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider2.displayName = rootComponentName + "Provider";
      return [Provider2, useContext22];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return React2.createContext(defaultContext);
      });
      return function useScope(scope) {
        const contexts = scope?.[scopeName] || scopeContexts;
        return React2.useMemo(
          () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
          [scope, contexts]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
  }
  function composeContextScopes(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1) return baseScope;
    const createScope = () => {
      const scopeHooks = scopes.map((createScope2) => ({
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      }));
      return function useComposedScopes(overrideScopes) {
        const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return { ...nextScopes2, ...currentScope };
        }, {});
        return React2.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
      };
    };
    createScope.scopeName = baseScope.scopeName;
    return createScope;
  }

  // ../../node_modules/.pnpm/@radix-ui+react-slot@1.1.0_@types+react@18.0.25_react@18.2.0/node_modules/@radix-ui/react-slot/dist/index.mjs
  var React3 = __toESM(require_react(), 1);
  var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
  var Slot = React3.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React3.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React3.Children.count(newElement) > 1) return React3.Children.only(null);
          return React3.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React3.isValidElement(newElement) ? React3.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot.displayName = "Slot";
  var SlotClone = React3.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React3.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      return React3.cloneElement(children, {
        ...mergeProps(slotProps, children.props),
        // @ts-ignore
        ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
      });
    }
    return React3.Children.count(children) > 1 ? React3.Children.only(null) : null;
  });
  SlotClone.displayName = "SlotClone";
  var Slottable = ({ children }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children });
  };
  function isSlottable(child) {
    return React3.isValidElement(child) && child.type === Slottable;
  }
  function mergeProps(slotProps, childProps) {
    const overrideProps = { ...childProps };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue) {
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        } else if (slotPropValue) {
          overrideProps[propName] = slotPropValue;
        }
      } else if (propName === "style") {
        overrideProps[propName] = { ...slotPropValue, ...childPropValue };
      } else if (propName === "className") {
        overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
      }
    }
    return { ...slotProps, ...overrideProps };
  }
  function getElementRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }

  // ../../node_modules/.pnpm/@radix-ui+react-collection@1.1.0_@types+react-dom@18.0.9_@types+react@18.0.25_react-dom@18.2._pvmvtcspzgufffeoi55jvigoga/node_modules/@radix-ui/react-collection/dist/index.mjs
  var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
  function createCollection(name) {
    const PROVIDER_NAME2 = name + "CollectionProvider";
    const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
    const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
      PROVIDER_NAME2,
      { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
    );
    const CollectionProvider = (props) => {
      const { scope, children } = props;
      const ref = import_react5.default.useRef(null);
      const itemMap = import_react5.default.useRef(/* @__PURE__ */ new Map()).current;
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
    };
    CollectionProvider.displayName = PROVIDER_NAME2;
    const COLLECTION_SLOT_NAME = name + "CollectionSlot";
    const CollectionSlot = import_react5.default.forwardRef(
      (props, forwardedRef) => {
        const { scope, children } = props;
        const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
        const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
        return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Slot, { ref: composedRefs, children });
      }
    );
    CollectionSlot.displayName = COLLECTION_SLOT_NAME;
    const ITEM_SLOT_NAME = name + "CollectionItemSlot";
    const ITEM_DATA_ATTR = "data-radix-collection-item";
    const CollectionItemSlot = import_react5.default.forwardRef(
      (props, forwardedRef) => {
        const { scope, children, ...itemData } = props;
        const ref = import_react5.default.useRef(null);
        const composedRefs = useComposedRefs(forwardedRef, ref);
        const context = useCollectionContext(ITEM_SLOT_NAME, scope);
        import_react5.default.useEffect(() => {
          context.itemMap.set(ref, { ref, ...itemData });
          return () => void context.itemMap.delete(ref);
        });
        return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Slot, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
      }
    );
    CollectionItemSlot.displayName = ITEM_SLOT_NAME;
    function useCollection2(scope) {
      const context = useCollectionContext(name + "CollectionConsumer", scope);
      const getItems = import_react5.default.useCallback(() => {
        const collectionNode = context.collectionRef.current;
        if (!collectionNode) return [];
        const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
        const items = Array.from(context.itemMap.values());
        const orderedItems = items.sort(
          (a2, b2) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b2.ref.current)
        );
        return orderedItems;
      }, [context.collectionRef, context.itemMap]);
      return getItems;
    }
    return [
      { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
      useCollection2,
      createCollectionScope2
    ];
  }

  // ../../node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.1.0_@types+react-dom@18.0.9_@types+react@18.0.25_react-do_whf7mcrhb3ivqjwmosbijm32oe/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
  var React8 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/@radix-ui+react-primitive@2.0.0_@types+react-dom@18.0.9_@types+react@18.0.25_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var React5 = __toESM(require_react(), 1);
  var ReactDOM = __toESM(require_react_dom(), 1);
  var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
  var NODES = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var Primitive = NODES.reduce((primitive, node) => {
    const Node = React5.forwardRef((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? Slot : node;
      if (typeof window !== "undefined") {
        window[Symbol.for("radix-ui")] = true;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
    });
    Node.displayName = `Primitive.${node}`;
    return { ...primitive, [node]: Node };
  }, {});
  function dispatchDiscreteCustomEvent(target, event) {
    if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
  }

  // ../../node_modules/.pnpm/@radix-ui+react-use-callback-ref@1.1.0_@types+react@18.0.25_react@18.2.0/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
  var React6 = __toESM(require_react(), 1);
  function useCallbackRef(callback) {
    const callbackRef = React6.useRef(callback);
    React6.useEffect(() => {
      callbackRef.current = callback;
    });
    return React6.useMemo(() => (...args) => callbackRef.current?.(...args), []);
  }

  // ../../node_modules/.pnpm/@radix-ui+react-use-escape-keydown@1.1.0_@types+react@18.0.25_react@18.2.0/node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
  var React7 = __toESM(require_react(), 1);
  function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
    const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
    React7.useEffect(() => {
      const handleKeyDown = (event) => {
        if (event.key === "Escape") {
          onEscapeKeyDown(event);
        }
      };
      ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
      return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
    }, [onEscapeKeyDown, ownerDocument]);
  }

  // ../../node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.1.0_@types+react-dom@18.0.9_@types+react@18.0.25_react-do_whf7mcrhb3ivqjwmosbijm32oe/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
  var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
  var DISMISSABLE_LAYER_NAME = "DismissableLayer";
  var CONTEXT_UPDATE = "dismissableLayer.update";
  var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
  var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
  var originalBodyPointerEvents;
  var DismissableLayerContext = React8.createContext({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  });
  var DismissableLayer = React8.forwardRef(
    (props, forwardedRef) => {
      const {
        disableOutsidePointerEvents = false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        onDismiss,
        ...layerProps
      } = props;
      const context = React8.useContext(DismissableLayerContext);
      const [node, setNode] = React8.useState(null);
      const ownerDocument = node?.ownerDocument ?? globalThis?.document;
      const [, force] = React8.useState({});
      const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
      const layers = Array.from(context.layers);
      const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
      const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
      const index2 = node ? layers.indexOf(node) : -1;
      const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
      const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
      const pointerDownOutside = usePointerDownOutside((event) => {
        const target = event.target;
        const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
        if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
        onPointerDownOutside?.(event);
        onInteractOutside?.(event);
        if (!event.defaultPrevented) onDismiss?.();
      }, ownerDocument);
      const focusOutside = useFocusOutside((event) => {
        const target = event.target;
        const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
        if (isFocusInBranch) return;
        onFocusOutside?.(event);
        onInteractOutside?.(event);
        if (!event.defaultPrevented) onDismiss?.();
      }, ownerDocument);
      useEscapeKeydown((event) => {
        const isHighestLayer = index2 === context.layers.size - 1;
        if (!isHighestLayer) return;
        onEscapeKeyDown?.(event);
        if (!event.defaultPrevented && onDismiss) {
          event.preventDefault();
          onDismiss();
        }
      }, ownerDocument);
      React8.useEffect(() => {
        if (!node) return;
        if (disableOutsidePointerEvents) {
          if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
            originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
            ownerDocument.body.style.pointerEvents = "none";
          }
          context.layersWithOutsidePointerEventsDisabled.add(node);
        }
        context.layers.add(node);
        dispatchUpdate();
        return () => {
          if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
            ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
          }
        };
      }, [node, ownerDocument, disableOutsidePointerEvents, context]);
      React8.useEffect(() => {
        return () => {
          if (!node) return;
          context.layers.delete(node);
          context.layersWithOutsidePointerEventsDisabled.delete(node);
          dispatchUpdate();
        };
      }, [node, context]);
      React8.useEffect(() => {
        const handleUpdate = () => force({});
        document.addEventListener(CONTEXT_UPDATE, handleUpdate);
        return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
      }, []);
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
        Primitive.div,
        {
          ...layerProps,
          ref: composedRefs,
          style: {
            pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
            ...props.style
          },
          onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
          onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
          onPointerDownCapture: composeEventHandlers(
            props.onPointerDownCapture,
            pointerDownOutside.onPointerDownCapture
          )
        }
      );
    }
  );
  DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
  var BRANCH_NAME = "DismissableLayerBranch";
  var DismissableLayerBranch = React8.forwardRef((props, forwardedRef) => {
    const context = React8.useContext(DismissableLayerContext);
    const ref = React8.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React8.useEffect(() => {
      const node = ref.current;
      if (node) {
        context.branches.add(node);
        return () => {
          context.branches.delete(node);
        };
      }
    }, [context.branches]);
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Primitive.div, { ...props, ref: composedRefs });
  });
  DismissableLayerBranch.displayName = BRANCH_NAME;
  function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
    const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
    const isPointerInsideReactTreeRef = React8.useRef(false);
    const handleClickRef = React8.useRef(() => {
    });
    React8.useEffect(() => {
      const handlePointerDown = (event) => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent2 = function() {
            handleAndDispatchCustomEvent(
              POINTER_DOWN_OUTSIDE,
              handlePointerDownOutside,
              eventDetail,
              { discrete: true }
            );
          };
          var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
          const eventDetail = { originalEvent: event };
          if (event.pointerType === "touch") {
            ownerDocument.removeEventListener("click", handleClickRef.current);
            handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
            ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
          } else {
            handleAndDispatchPointerDownOutsideEvent2();
          }
        } else {
          ownerDocument.removeEventListener("click", handleClickRef.current);
        }
        isPointerInsideReactTreeRef.current = false;
      };
      const timerId = window.setTimeout(() => {
        ownerDocument.addEventListener("pointerdown", handlePointerDown);
      }, 0);
      return () => {
        window.clearTimeout(timerId);
        ownerDocument.removeEventListener("pointerdown", handlePointerDown);
        ownerDocument.removeEventListener("click", handleClickRef.current);
      };
    }, [ownerDocument, handlePointerDownOutside]);
    return {
      // ensures we check React component tree (not just DOM tree)
      onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
    };
  }
  function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
    const handleFocusOutside = useCallbackRef(onFocusOutside);
    const isFocusInsideReactTreeRef = React8.useRef(false);
    React8.useEffect(() => {
      const handleFocus = (event) => {
        if (event.target && !isFocusInsideReactTreeRef.current) {
          const eventDetail = { originalEvent: event };
          handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
            discrete: false
          });
        }
      };
      ownerDocument.addEventListener("focusin", handleFocus);
      return () => ownerDocument.removeEventListener("focusin", handleFocus);
    }, [ownerDocument, handleFocusOutside]);
    return {
      onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
      onBlurCapture: () => isFocusInsideReactTreeRef.current = false
    };
  }
  function dispatchUpdate() {
    const event = new CustomEvent(CONTEXT_UPDATE);
    document.dispatchEvent(event);
  }
  function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
    const target = detail.originalEvent.target;
    const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
    if (handler) target.addEventListener(name, handler, { once: true });
    if (discrete) {
      dispatchDiscreteCustomEvent(target, event);
    } else {
      target.dispatchEvent(event);
    }
  }
  var Root = DismissableLayer;
  var Branch = DismissableLayerBranch;

  // ../../node_modules/.pnpm/@radix-ui+react-portal@1.1.1_@types+react-dom@18.0.9_@types+react@18.0.25_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@radix-ui/react-portal/dist/index.mjs
  var React10 = __toESM(require_react(), 1);
  var import_react_dom2 = __toESM(require_react_dom(), 1);

  // ../../node_modules/.pnpm/@radix-ui+react-use-layout-effect@1.1.0_@types+react@18.0.25_react@18.2.0/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
  var React9 = __toESM(require_react(), 1);
  var useLayoutEffect2 = Boolean(globalThis?.document) ? React9.useLayoutEffect : () => {
  };

  // ../../node_modules/.pnpm/@radix-ui+react-portal@1.1.1_@types+react-dom@18.0.9_@types+react@18.0.25_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@radix-ui/react-portal/dist/index.mjs
  var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
  var PORTAL_NAME = "Portal";
  var Portal = React10.forwardRef((props, forwardedRef) => {
    const { container: containerProp, ...portalProps } = props;
    const [mounted, setMounted] = React10.useState(false);
    useLayoutEffect2(() => setMounted(true), []);
    const container = containerProp || mounted && globalThis?.document?.body;
    return container ? import_react_dom2.default.createPortal(/* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
  });
  Portal.displayName = PORTAL_NAME;

  // ../../node_modules/.pnpm/@radix-ui+react-presence@1.1.0_@types+react-dom@18.0.9_@types+react@18.0.25_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@radix-ui/react-presence/dist/index.mjs
  var React22 = __toESM(require_react(), 1);
  var ReactDOM3 = __toESM(require_react_dom(), 1);
  var React11 = __toESM(require_react(), 1);
  function useStateMachine(initialState, machine) {
    return React11.useReducer((state, event) => {
      const nextState = machine[state][event];
      return nextState ?? state;
    }, initialState);
  }
  var Presence = (props) => {
    const { present, children } = props;
    const presence = usePresence(present);
    const child = typeof children === "function" ? children({ present: presence.isPresent }) : React22.Children.only(children);
    const ref = useComposedRefs(presence.ref, getElementRef2(child));
    const forceMount = typeof children === "function";
    return forceMount || presence.isPresent ? React22.cloneElement(child, { ref }) : null;
  };
  Presence.displayName = "Presence";
  function usePresence(present) {
    const [node, setNode] = React22.useState();
    const stylesRef = React22.useRef({});
    const prevPresentRef = React22.useRef(present);
    const prevAnimationNameRef = React22.useRef("none");
    const initialState = present ? "mounted" : "unmounted";
    const [state, send] = useStateMachine(initialState, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    React22.useEffect(() => {
      const currentAnimationName = getAnimationName(stylesRef.current);
      prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
    }, [state]);
    useLayoutEffect2(() => {
      const styles = stylesRef.current;
      const wasPresent = prevPresentRef.current;
      const hasPresentChanged = wasPresent !== present;
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.current;
        const currentAnimationName = getAnimationName(styles);
        if (present) {
          send("MOUNT");
        } else if (currentAnimationName === "none" || styles?.display === "none") {
          send("UNMOUNT");
        } else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (wasPresent && isAnimating) {
            send("ANIMATION_OUT");
          } else {
            send("UNMOUNT");
          }
        }
        prevPresentRef.current = present;
      }
    }, [present, send]);
    useLayoutEffect2(() => {
      if (node) {
        const handleAnimationEnd = (event) => {
          const currentAnimationName = getAnimationName(stylesRef.current);
          const isCurrentAnimation = currentAnimationName.includes(event.animationName);
          if (event.target === node && isCurrentAnimation) {
            ReactDOM3.flushSync(() => send("ANIMATION_END"));
          }
        };
        const handleAnimationStart = (event) => {
          if (event.target === node) {
            prevAnimationNameRef.current = getAnimationName(stylesRef.current);
          }
        };
        node.addEventListener("animationstart", handleAnimationStart);
        node.addEventListener("animationcancel", handleAnimationEnd);
        node.addEventListener("animationend", handleAnimationEnd);
        return () => {
          node.removeEventListener("animationstart", handleAnimationStart);
          node.removeEventListener("animationcancel", handleAnimationEnd);
          node.removeEventListener("animationend", handleAnimationEnd);
        };
      } else {
        send("ANIMATION_END");
      }
    }, [node, send]);
    return {
      isPresent: ["mounted", "unmountSuspended"].includes(state),
      ref: React22.useCallback((node2) => {
        if (node2) stylesRef.current = getComputedStyle(node2);
        setNode(node2);
      }, [])
    };
  }
  function getAnimationName(styles) {
    return styles?.animationName || "none";
  }
  function getElementRef2(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }

  // ../../node_modules/.pnpm/@radix-ui+react-use-controllable-state@1.1.0_@types+react@18.0.25_react@18.2.0/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  var React12 = __toESM(require_react(), 1);
  function useControllableState({
    prop,
    defaultProp,
    onChange = () => {
    }
  }) {
    const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
    const isControlled = prop !== void 0;
    const value = isControlled ? prop : uncontrolledProp;
    const handleChange = useCallbackRef(onChange);
    const setValue = React12.useCallback(
      (nextValue) => {
        if (isControlled) {
          const setter = nextValue;
          const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
          if (value2 !== prop) handleChange(value2);
        } else {
          setUncontrolledProp(nextValue);
        }
      },
      [isControlled, prop, setUncontrolledProp, handleChange]
    );
    return [value, setValue];
  }
  function useUncontrolledState({
    defaultProp,
    onChange
  }) {
    const uncontrolledState = React12.useState(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = React12.useRef(value);
    const handleChange = useCallbackRef(onChange);
    React12.useEffect(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [value, prevValueRef, handleChange]);
    return uncontrolledState;
  }

  // ../../node_modules/.pnpm/@radix-ui+react-visually-hidden@1.1.0_@types+react-dom@18.0.9_@types+react@18.0.25_react-dom@_cr4vsym6nmg4vrfbiyp67d4yle/node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
  var React13 = __toESM(require_react(), 1);
  var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
  var NAME = "VisuallyHidden";
  var VisuallyHidden = React13.forwardRef(
    (props, forwardedRef) => {
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
        Primitive.span,
        {
          ...props,
          ref: forwardedRef,
          style: {
            // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
            position: "absolute",
            border: 0,
            width: 1,
            height: 1,
            padding: 0,
            margin: -1,
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            wordWrap: "normal",
            ...props.style
          }
        }
      );
    }
  );
  VisuallyHidden.displayName = NAME;

  // ../../node_modules/.pnpm/@radix-ui+react-toast@1.2.1_@types+react-dom@18.0.9_@types+react@18.0.25_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@radix-ui/react-toast/dist/index.mjs
  var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
  var PROVIDER_NAME = "ToastProvider";
  var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
  var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope]);
  var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);
  var ToastProvider = (props) => {
    const {
      __scopeToast,
      label = "Notification",
      duration = 5e3,
      swipeDirection = "right",
      swipeThreshold = 50,
      children
    } = props;
    const [viewport, setViewport] = React14.useState(null);
    const [toastCount, setToastCount] = React14.useState(0);
    const isFocusedToastEscapeKeyDownRef = React14.useRef(false);
    const isClosePausedRef = React14.useRef(false);
    if (!label.trim()) {
      console.error(
        `Invalid prop \`label\` supplied to \`${PROVIDER_NAME}\`. Expected non-empty \`string\`.`
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Collection.Provider, { scope: __scopeToast, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      ToastProviderProvider,
      {
        scope: __scopeToast,
        label,
        duration,
        swipeDirection,
        swipeThreshold,
        toastCount,
        viewport,
        onViewportChange: setViewport,
        onToastAdd: React14.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
        onToastRemove: React14.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
        isFocusedToastEscapeKeyDownRef,
        isClosePausedRef,
        children
      }
    ) });
  };
  ToastProvider.displayName = PROVIDER_NAME;
  var VIEWPORT_NAME = "ToastViewport";
  var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
  var VIEWPORT_PAUSE = "toast.viewportPause";
  var VIEWPORT_RESUME = "toast.viewportResume";
  var ToastViewport = React14.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeToast,
        hotkey = VIEWPORT_DEFAULT_HOTKEY,
        label = "Notifications ({hotkey})",
        ...viewportProps
      } = props;
      const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
      const getItems = useCollection(__scopeToast);
      const wrapperRef = React14.useRef(null);
      const headFocusProxyRef = React14.useRef(null);
      const tailFocusProxyRef = React14.useRef(null);
      const ref = React14.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
      const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
      const hasToasts = context.toastCount > 0;
      React14.useEffect(() => {
        const handleKeyDown = (event) => {
          const isHotkeyPressed = hotkey.every((key) => event[key] || event.code === key);
          if (isHotkeyPressed) ref.current?.focus();
        };
        document.addEventListener("keydown", handleKeyDown);
        return () => document.removeEventListener("keydown", handleKeyDown);
      }, [hotkey]);
      React14.useEffect(() => {
        const wrapper = wrapperRef.current;
        const viewport = ref.current;
        if (hasToasts && wrapper && viewport) {
          const handlePause = () => {
            if (!context.isClosePausedRef.current) {
              const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
              viewport.dispatchEvent(pauseEvent);
              context.isClosePausedRef.current = true;
            }
          };
          const handleResume = () => {
            if (context.isClosePausedRef.current) {
              const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
              viewport.dispatchEvent(resumeEvent);
              context.isClosePausedRef.current = false;
            }
          };
          const handleFocusOutResume = (event) => {
            const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
            if (isFocusMovingOutside) handleResume();
          };
          const handlePointerLeaveResume = () => {
            const isFocusInside = wrapper.contains(document.activeElement);
            if (!isFocusInside) handleResume();
          };
          wrapper.addEventListener("focusin", handlePause);
          wrapper.addEventListener("focusout", handleFocusOutResume);
          wrapper.addEventListener("pointermove", handlePause);
          wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
          window.addEventListener("blur", handlePause);
          window.addEventListener("focus", handleResume);
          return () => {
            wrapper.removeEventListener("focusin", handlePause);
            wrapper.removeEventListener("focusout", handleFocusOutResume);
            wrapper.removeEventListener("pointermove", handlePause);
            wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
            window.removeEventListener("blur", handlePause);
            window.removeEventListener("focus", handleResume);
          };
        }
      }, [hasToasts, context.isClosePausedRef]);
      const getSortedTabbableCandidates = React14.useCallback(
        ({ tabbingDirection }) => {
          const toastItems = getItems();
          const tabbableCandidates = toastItems.map((toastItem) => {
            const toastNode = toastItem.ref.current;
            const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
            return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
          });
          return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
        },
        [getItems]
      );
      React14.useEffect(() => {
        const viewport = ref.current;
        if (viewport) {
          const handleKeyDown = (event) => {
            const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
            const isTabKey = event.key === "Tab" && !isMetaKey;
            if (isTabKey) {
              const focusedElement = document.activeElement;
              const isTabbingBackwards = event.shiftKey;
              const targetIsViewport = event.target === viewport;
              if (targetIsViewport && isTabbingBackwards) {
                headFocusProxyRef.current?.focus();
                return;
              }
              const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
              const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
              const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
              if (focusFirst(sortedCandidates.slice(index2 + 1))) {
                event.preventDefault();
              } else {
                isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();
              }
            }
          };
          viewport.addEventListener("keydown", handleKeyDown);
          return () => viewport.removeEventListener("keydown", handleKeyDown);
        }
      }, [getItems, getSortedTabbableCandidates]);
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
        Branch,
        {
          ref: wrapperRef,
          role: "region",
          "aria-label": label.replace("{hotkey}", hotkeyLabel),
          tabIndex: -1,
          style: { pointerEvents: hasToasts ? void 0 : "none" },
          children: [
            hasToasts && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
              FocusProxy,
              {
                ref: headFocusProxyRef,
                onFocusFromOutsideViewport: () => {
                  const tabbableCandidates = getSortedTabbableCandidates({
                    tabbingDirection: "forwards"
                  });
                  focusFirst(tabbableCandidates);
                }
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Collection.Slot, { scope: __scopeToast, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
            hasToasts && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
              FocusProxy,
              {
                ref: tailFocusProxyRef,
                onFocusFromOutsideViewport: () => {
                  const tabbableCandidates = getSortedTabbableCandidates({
                    tabbingDirection: "backwards"
                  });
                  focusFirst(tabbableCandidates);
                }
              }
            )
          ]
        }
      );
    }
  );
  ToastViewport.displayName = VIEWPORT_NAME;
  var FOCUS_PROXY_NAME = "ToastFocusProxy";
  var FocusProxy = React14.forwardRef(
    (props, forwardedRef) => {
      const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
      const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        VisuallyHidden,
        {
          "aria-hidden": true,
          tabIndex: 0,
          ...proxyProps,
          ref: forwardedRef,
          style: { position: "fixed" },
          onFocus: (event) => {
            const prevFocusedElement = event.relatedTarget;
            const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);
            if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
          }
        }
      );
    }
  );
  FocusProxy.displayName = FOCUS_PROXY_NAME;
  var TOAST_NAME = "Toast";
  var TOAST_SWIPE_START = "toast.swipeStart";
  var TOAST_SWIPE_MOVE = "toast.swipeMove";
  var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
  var TOAST_SWIPE_END = "toast.swipeEnd";
  var Toast = React14.forwardRef(
    (props, forwardedRef) => {
      const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
      const [open2 = true, setOpen] = useControllableState({
        prop: openProp,
        defaultProp: defaultOpen,
        onChange: onOpenChange
      });
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Presence, { present: forceMount || open2, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        ToastImpl,
        {
          open: open2,
          ...toastProps,
          ref: forwardedRef,
          onClose: () => setOpen(false),
          onPause: useCallbackRef(props.onPause),
          onResume: useCallbackRef(props.onResume),
          onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
            event.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
            const { x: x2, y: y2 } = event.detail.delta;
            event.currentTarget.setAttribute("data-swipe", "move");
            event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x2}px`);
            event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y2}px`);
          }),
          onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
            event.currentTarget.setAttribute("data-swipe", "cancel");
            event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
            event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
            event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
            event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
          }),
          onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
            const { x: x2, y: y2 } = event.detail.delta;
            event.currentTarget.setAttribute("data-swipe", "end");
            event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
            event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
            event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x2}px`);
            event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y2}px`);
            setOpen(false);
          })
        }
      ) });
    }
  );
  Toast.displayName = TOAST_NAME;
  var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
    onClose() {
    }
  });
  var ToastImpl = React14.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeToast,
        type = "foreground",
        duration: durationProp,
        open: open2,
        onClose,
        onEscapeKeyDown,
        onPause,
        onResume,
        onSwipeStart,
        onSwipeMove,
        onSwipeCancel,
        onSwipeEnd,
        ...toastProps
      } = props;
      const context = useToastProviderContext(TOAST_NAME, __scopeToast);
      const [node, setNode] = React14.useState(null);
      const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
      const pointerStartRef = React14.useRef(null);
      const swipeDeltaRef = React14.useRef(null);
      const duration = durationProp || context.duration;
      const closeTimerStartTimeRef = React14.useRef(0);
      const closeTimerRemainingTimeRef = React14.useRef(duration);
      const closeTimerRef = React14.useRef(0);
      const { onToastAdd, onToastRemove } = context;
      const handleClose = useCallbackRef(() => {
        const isFocusInToast = node?.contains(document.activeElement);
        if (isFocusInToast) context.viewport?.focus();
        onClose();
      });
      const startTimer = React14.useCallback(
        (duration2) => {
          if (!duration2 || duration2 === Infinity) return;
          window.clearTimeout(closeTimerRef.current);
          closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
          closeTimerRef.current = window.setTimeout(handleClose, duration2);
        },
        [handleClose]
      );
      React14.useEffect(() => {
        const viewport = context.viewport;
        if (viewport) {
          const handleResume = () => {
            startTimer(closeTimerRemainingTimeRef.current);
            onResume?.();
          };
          const handlePause = () => {
            const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
            closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
            window.clearTimeout(closeTimerRef.current);
            onPause?.();
          };
          viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.addEventListener(VIEWPORT_RESUME, handleResume);
          return () => {
            viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
            viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
          };
        }
      }, [context.viewport, duration, onPause, onResume, startTimer]);
      React14.useEffect(() => {
        if (open2 && !context.isClosePausedRef.current) startTimer(duration);
      }, [open2, duration, context.isClosePausedRef, startTimer]);
      React14.useEffect(() => {
        onToastAdd();
        return () => onToastRemove();
      }, [onToastAdd, onToastRemove]);
      const announceTextContent = React14.useMemo(() => {
        return node ? getAnnounceTextContent(node) : null;
      }, [node]);
      if (!context.viewport) return null;
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
        announceTextContent && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
          ToastAnnounce,
          {
            __scopeToast,
            role: "status",
            "aria-live": type === "foreground" ? "assertive" : "polite",
            "aria-atomic": true,
            children: announceTextContent
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: ReactDOM4.createPortal(
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
            Root,
            {
              asChild: true,
              onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
                if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
                context.isFocusedToastEscapeKeyDownRef.current = false;
              }),
              children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                Primitive.li,
                {
                  role: "status",
                  "aria-live": "off",
                  "aria-atomic": true,
                  tabIndex: 0,
                  "data-state": open2 ? "open" : "closed",
                  "data-swipe-direction": context.swipeDirection,
                  ...toastProps,
                  ref: composedRefs,
                  style: { userSelect: "none", touchAction: "none", ...props.style },
                  onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                    if (event.key !== "Escape") return;
                    onEscapeKeyDown?.(event.nativeEvent);
                    if (!event.nativeEvent.defaultPrevented) {
                      context.isFocusedToastEscapeKeyDownRef.current = true;
                      handleClose();
                    }
                  }),
                  onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                    if (event.button !== 0) return;
                    pointerStartRef.current = { x: event.clientX, y: event.clientY };
                  }),
                  onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                    if (!pointerStartRef.current) return;
                    const x2 = event.clientX - pointerStartRef.current.x;
                    const y2 = event.clientY - pointerStartRef.current.y;
                    const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                    const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                    const clamp2 = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                    const clampedX = isHorizontalSwipe ? clamp2(0, x2) : 0;
                    const clampedY = !isHorizontalSwipe ? clamp2(0, y2) : 0;
                    const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                    const delta = { x: clampedX, y: clampedY };
                    const eventDetail = { originalEvent: event, delta };
                    if (hasSwipeMoveStarted) {
                      swipeDeltaRef.current = delta;
                      handleAndDispatchCustomEvent2(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                        discrete: false
                      });
                    } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                      swipeDeltaRef.current = delta;
                      handleAndDispatchCustomEvent2(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                        discrete: false
                      });
                      event.target.setPointerCapture(event.pointerId);
                    } else if (Math.abs(x2) > moveStartBuffer || Math.abs(y2) > moveStartBuffer) {
                      pointerStartRef.current = null;
                    }
                  }),
                  onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                    const delta = swipeDeltaRef.current;
                    const target = event.target;
                    if (target.hasPointerCapture(event.pointerId)) {
                      target.releasePointerCapture(event.pointerId);
                    }
                    swipeDeltaRef.current = null;
                    pointerStartRef.current = null;
                    if (delta) {
                      const toast = event.currentTarget;
                      const eventDetail = { originalEvent: event, delta };
                      if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                        handleAndDispatchCustomEvent2(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                          discrete: true
                        });
                      } else {
                        handleAndDispatchCustomEvent2(
                          TOAST_SWIPE_CANCEL,
                          onSwipeCancel,
                          eventDetail,
                          {
                            discrete: true
                          }
                        );
                      }
                      toast.addEventListener("click", (event2) => event2.preventDefault(), {
                        once: true
                      });
                    }
                  })
                }
              )
            }
          ) }),
          context.viewport
        ) })
      ] });
    }
  );
  var ToastAnnounce = (props) => {
    const { __scopeToast, children, ...announceProps } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [renderAnnounceText, setRenderAnnounceText] = React14.useState(false);
    const [isAnnounced, setIsAnnounced] = React14.useState(false);
    useNextFrame(() => setRenderAnnounceText(true));
    React14.useEffect(() => {
      const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
      return () => window.clearTimeout(timer);
    }, []);
    return isAnnounced ? null : /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Portal, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(VisuallyHidden, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
      context.label,
      " ",
      children
    ] }) }) });
  };
  var TITLE_NAME = "ToastTitle";
  var ToastTitle = React14.forwardRef(
    (props, forwardedRef) => {
      const { __scopeToast, ...titleProps } = props;
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Primitive.div, { ...titleProps, ref: forwardedRef });
    }
  );
  ToastTitle.displayName = TITLE_NAME;
  var DESCRIPTION_NAME = "ToastDescription";
  var ToastDescription = React14.forwardRef(
    (props, forwardedRef) => {
      const { __scopeToast, ...descriptionProps } = props;
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Primitive.div, { ...descriptionProps, ref: forwardedRef });
    }
  );
  ToastDescription.displayName = DESCRIPTION_NAME;
  var ACTION_NAME = "ToastAction";
  var ToastAction = React14.forwardRef(
    (props, forwardedRef) => {
      const { altText, ...actionProps } = props;
      if (!altText.trim()) {
        console.error(
          `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
        );
        return null;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(ToastClose, { ...actionProps, ref: forwardedRef }) });
    }
  );
  ToastAction.displayName = ACTION_NAME;
  var CLOSE_NAME = "ToastClose";
  var ToastClose = React14.forwardRef(
    (props, forwardedRef) => {
      const { __scopeToast, ...closeProps } = props;
      const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        Primitive.button,
        {
          type: "button",
          ...closeProps,
          ref: forwardedRef,
          onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
        }
      ) });
    }
  );
  ToastClose.displayName = CLOSE_NAME;
  var ToastAnnounceExclude = React14.forwardRef((props, forwardedRef) => {
    const { __scopeToast, altText, ...announceExcludeProps } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      Primitive.div,
      {
        "data-radix-toast-announce-exclude": "",
        "data-radix-toast-announce-alt": altText || void 0,
        ...announceExcludeProps,
        ref: forwardedRef
      }
    );
  });
  function getAnnounceTextContent(container) {
    const textContent = [];
    const childNodes = Array.from(container.childNodes);
    childNodes.forEach((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
      if (isHTMLElement(node)) {
        const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
        const isExcluded = node.dataset.radixToastAnnounceExclude === "";
        if (!isHidden2) {
          if (isExcluded) {
            const altText = node.dataset.radixToastAnnounceAlt;
            if (altText) textContent.push(altText);
          } else {
            textContent.push(...getAnnounceTextContent(node));
          }
        }
      }
    });
    return textContent;
  }
  function handleAndDispatchCustomEvent2(name, handler, detail, { discrete }) {
    const currentTarget = detail.originalEvent.currentTarget;
    const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
    if (handler) currentTarget.addEventListener(name, handler, { once: true });
    if (discrete) {
      dispatchDiscreteCustomEvent(currentTarget, event);
    } else {
      currentTarget.dispatchEvent(event);
    }
  }
  var isDeltaInDirection = (delta, direction, threshold = 0) => {
    const deltaX = Math.abs(delta.x);
    const deltaY = Math.abs(delta.y);
    const isDeltaX = deltaX > deltaY;
    if (direction === "left" || direction === "right") {
      return isDeltaX && deltaX > threshold;
    } else {
      return !isDeltaX && deltaY > threshold;
    }
  };
  function useNextFrame(callback = () => {
  }) {
    const fn = useCallbackRef(callback);
    useLayoutEffect2(() => {
      let raf1 = 0;
      let raf2 = 0;
      raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
      return () => {
        window.cancelAnimationFrame(raf1);
        window.cancelAnimationFrame(raf2);
      };
    }, [fn]);
  }
  function isHTMLElement(node) {
    return node.nodeType === node.ELEMENT_NODE;
  }
  function getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode()) nodes.push(walker.currentNode);
    return nodes;
  }
  function focusFirst(candidates) {
    const previouslyFocusedElement = document.activeElement;
    return candidates.some((candidate) => {
      if (candidate === previouslyFocusedElement) return true;
      candidate.focus();
      return document.activeElement !== previouslyFocusedElement;
    });
  }
  var Provider = ToastProvider;
  var Viewport = ToastViewport;

  // ../react/build/index.js
  var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
  var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
  var import_copy_to_clipboard = __toESM(require_copy_to_clipboard(), 1);
  var import_react35 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/index.mjs
  var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
  var import_react16 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
  var import_react6 = __toESM(require_react(), 1);
  var MotionConfigContext = (0, import_react6.createContext)({
    transformPagePoint: (p2) => p2,
    isStatic: false,
    reducedMotion: "never"
  });

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
  var import_react7 = __toESM(require_react(), 1);
  var MotionContext = (0, import_react7.createContext)({});

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
  var import_react12 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/PresenceContext.mjs
  var import_react8 = __toESM(require_react(), 1);
  var PresenceContext = (0, import_react8.createContext)(null);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
  var import_react9 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/is-browser.mjs
  var isBrowser = typeof document !== "undefined";

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
  var useIsomorphicLayoutEffect = isBrowser ? import_react9.useLayoutEffect : import_react9.useEffect;

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/LazyContext.mjs
  var import_react10 = __toESM(require_react(), 1);
  var LazyContext = (0, import_react10.createContext)({ strict: false });

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
  var camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs
  var optimizedAppearDataId = "framerAppearId";
  var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/GlobalConfig.mjs
  var MotionGlobalConfig = {
    skipAnimations: false,
    useManualTiming: false
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/frameloop/render-step.mjs
  var Queue = class {
    constructor() {
      this.order = [];
      this.scheduled = /* @__PURE__ */ new Set();
    }
    add(process2) {
      if (!this.scheduled.has(process2)) {
        this.scheduled.add(process2);
        this.order.push(process2);
        return true;
      }
    }
    remove(process2) {
      const index2 = this.order.indexOf(process2);
      if (index2 !== -1) {
        this.order.splice(index2, 1);
        this.scheduled.delete(process2);
      }
    }
    clear() {
      this.order.length = 0;
      this.scheduled.clear();
    }
  };
  function createRenderStep(runNextFrame) {
    let thisFrame = new Queue();
    let nextFrame = new Queue();
    let numToRun = 0;
    let isProcessing = false;
    let flushNextFrame = false;
    const toKeepAlive = /* @__PURE__ */ new WeakSet();
    const step = {
      /**
       * Schedule a process to run on the next frame.
       */
      schedule: (callback, keepAlive = false, immediate = false) => {
        const addToCurrentFrame = immediate && isProcessing;
        const queue = addToCurrentFrame ? thisFrame : nextFrame;
        if (keepAlive)
          toKeepAlive.add(callback);
        if (queue.add(callback) && addToCurrentFrame && isProcessing) {
          numToRun = thisFrame.order.length;
        }
        return callback;
      },
      /**
       * Cancel the provided callback from running on the next frame.
       */
      cancel: (callback) => {
        nextFrame.remove(callback);
        toKeepAlive.delete(callback);
      },
      /**
       * Execute all schedule callbacks.
       */
      process: (frameData2) => {
        if (isProcessing) {
          flushNextFrame = true;
          return;
        }
        isProcessing = true;
        [thisFrame, nextFrame] = [nextFrame, thisFrame];
        nextFrame.clear();
        numToRun = thisFrame.order.length;
        if (numToRun) {
          for (let i2 = 0; i2 < numToRun; i2++) {
            const callback = thisFrame.order[i2];
            if (toKeepAlive.has(callback)) {
              step.schedule(callback);
              runNextFrame();
            }
            callback(frameData2);
          }
        }
        isProcessing = false;
        if (flushNextFrame) {
          flushNextFrame = false;
          step.process(frameData2);
        }
      }
    };
    return step;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/frameloop/batcher.mjs
  var stepsOrder = [
    "read",
    // Read
    "resolveKeyframes",
    // Write/Read/Write/Read
    "update",
    // Compute
    "preRender",
    // Compute
    "render",
    // Write
    "postRender"
    // Compute
  ];
  var maxElapsed = 40;
  function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
    let runNextFrame = false;
    let useDefaultElapsed = true;
    const state = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    const flagRunNextFrame = () => runNextFrame = true;
    const steps2 = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(flagRunNextFrame);
      return acc;
    }, {});
    const { read, resolveKeyframes, update: update2, preRender, render, postRender } = steps2;
    const processBatch = () => {
      const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
      runNextFrame = false;
      state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
      state.timestamp = timestamp;
      state.isProcessing = true;
      read.process(state);
      resolveKeyframes.process(state);
      update2.process(state);
      preRender.process(state);
      render.process(state);
      postRender.process(state);
      state.isProcessing = false;
      if (runNextFrame && allowKeepAlive) {
        useDefaultElapsed = false;
        scheduleNextBatch(processBatch);
      }
    };
    const wake = () => {
      runNextFrame = true;
      useDefaultElapsed = true;
      if (!state.isProcessing) {
        scheduleNextBatch(processBatch);
      }
    };
    const schedule = stepsOrder.reduce((acc, key) => {
      const step = steps2[key];
      acc[key] = (process2, keepAlive = false, immediate = false) => {
        if (!runNextFrame)
          wake();
        return step.schedule(process2, keepAlive, immediate);
      };
      return acc;
    }, {});
    const cancel = (process2) => {
      for (let i2 = 0; i2 < stepsOrder.length; i2++) {
        steps2[stepsOrder[i2]].cancel(process2);
      }
    };
    return { schedule, cancel, state, steps: steps2 };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/frameloop/microtask.mjs
  var { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
  function isRefObject(ref) {
    return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
  var import_react11 = __toESM(require_react(), 1);
  var SwitchLayoutGroupContext = (0, import_react11.createContext)({});

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
  var scheduleHandoffComplete = false;
  function useVisualElement(Component3, visualState, props, createVisualElement, ProjectionNodeConstructor) {
    const { visualElement: parent } = (0, import_react12.useContext)(MotionContext);
    const lazyContext = (0, import_react12.useContext)(LazyContext);
    const presenceContext = (0, import_react12.useContext)(PresenceContext);
    const reducedMotionConfig = (0, import_react12.useContext)(MotionConfigContext).reducedMotion;
    const visualElementRef = (0, import_react12.useRef)();
    createVisualElement = createVisualElement || lazyContext.renderer;
    if (!visualElementRef.current && createVisualElement) {
      visualElementRef.current = createVisualElement(Component3, {
        visualState,
        parent,
        props,
        presenceContext,
        blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
        reducedMotionConfig
      });
    }
    const visualElement = visualElementRef.current;
    const initialLayoutGroupConfig = (0, import_react12.useContext)(SwitchLayoutGroupContext);
    if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
      createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
    }
    (0, import_react12.useInsertionEffect)(() => {
      visualElement && visualElement.update(props, presenceContext);
    });
    const wantsHandoff = (0, import_react12.useRef)(Boolean(props[optimizedAppearDataAttribute] && !window.HandoffComplete));
    useIsomorphicLayoutEffect(() => {
      if (!visualElement)
        return;
      visualElement.updateFeatures();
      microtask.render(visualElement.render);
      if (wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
    });
    (0, import_react12.useEffect)(() => {
      if (!visualElement)
        return;
      if (!wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
      if (wantsHandoff.current) {
        wantsHandoff.current = false;
        if (!scheduleHandoffComplete) {
          scheduleHandoffComplete = true;
          queueMicrotask(completeHandoff);
        }
      }
    });
    return visualElement;
  }
  function completeHandoff() {
    window.HandoffComplete = true;
  }
  function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
    const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = props;
    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
    visualElement.projection.setOptions({
      layoutId,
      layout: layout2,
      alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
      visualElement,
      scheduleRender: () => visualElement.scheduleRender(),
      /**
       * TODO: Update options in an effect. This could be tricky as it'll be too late
       * to update by the time layout animations run.
       * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
       * ensuring it gets called if there's no potential layout animations.
       *
       */
      animationType: typeof layout2 === "string" ? layout2 : "both",
      initialPromotionConfig,
      layoutScroll,
      layoutRoot
    });
  }
  function getClosestProjectingNode(visualElement) {
    if (!visualElement)
      return void 0;
    return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
  var import_react13 = __toESM(require_react(), 1);
  function useMotionRef(visualState, visualElement, externalRef) {
    return (0, import_react13.useCallback)(
      (instance) => {
        instance && visualState.mount && visualState.mount(instance);
        if (visualElement) {
          if (instance) {
            visualElement.mount(instance);
          } else {
            visualElement.unmount();
          }
        }
        if (externalRef) {
          if (typeof externalRef === "function") {
            externalRef(instance);
          } else if (isRefObject(externalRef)) {
            externalRef.current = instance;
          }
        }
      },
      /**
       * Only pass a new ref callback to React if we've received a visual element
       * factory. Otherwise we'll be mounting/remounting every time externalRef
       * or other dependencies change.
       */
      [visualElement]
    );
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
  var import_react14 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs
  function isVariantLabel(v2) {
    return typeof v2 === "string" || Array.isArray(v2);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
  function isAnimationControls(v2) {
    return v2 !== null && typeof v2 === "object" && typeof v2.start === "function";
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/variant-props.mjs
  var variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit"
  ];
  var variantProps = ["initial", ...variantPriorityOrder];

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs
  function isControllingVariants(props) {
    return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
  }
  function isVariantNode(props) {
    return Boolean(isControllingVariants(props) || props.variants);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
  function getCurrentTreeVariants(props, context) {
    if (isControllingVariants(props)) {
      const { initial, animate } = props;
      return {
        initial: initial === false || isVariantLabel(initial) ? initial : void 0,
        animate: isVariantLabel(animate) ? animate : void 0
      };
    }
    return props.inherit !== false ? context : {};
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
  function useCreateMotionContext(props) {
    const { initial, animate } = getCurrentTreeVariants(props, (0, import_react14.useContext)(MotionContext));
    return (0, import_react14.useMemo)(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
  }
  function variantLabelsAsDependency(prop) {
    return Array.isArray(prop) ? prop.join(" ") : prop;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/definitions.mjs
  var featureProps = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag"
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
  };
  var featureDefinitions = {};
  for (const key in featureProps) {
    featureDefinitions[key] = {
      isEnabled: (props) => featureProps[key].some((name) => !!props[name])
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/load-features.mjs
  function loadFeatures(features) {
    for (const key in features) {
      featureDefinitions[key] = {
        ...featureDefinitions[key],
        ...features[key]
      };
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
  var import_react15 = __toESM(require_react(), 1);
  var LayoutGroupContext = (0, import_react15.createContext)({});

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/symbol.mjs
  var motionComponentSymbol = Symbol.for("motionComponentSymbol");

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/noop.mjs
  var noop = (any) => any;

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/errors.mjs
  var warning = noop;
  var invariant = noop;
  if (false) {
    warning = (check, message) => {
      if (!check && typeof console !== "undefined") {
        console.warn(message);
      }
    };
    invariant = (check, message) => {
      if (!check) {
        throw new Error(message);
      }
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/index.mjs
  function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement, useRender, useVisualState, Component: Component3 }) {
    preloadedFeatures2 && loadFeatures(preloadedFeatures2);
    function MotionComponent(props, externalRef) {
      let MeasureLayout2;
      const configAndProps = {
        ...(0, import_react16.useContext)(MotionConfigContext),
        ...props,
        layoutId: useLayoutId(props)
      };
      const { isStatic } = configAndProps;
      const context = useCreateMotionContext(props);
      const visualState = useVisualState(props, isStatic);
      if (!isStatic && isBrowser) {
        useStrictMode(configAndProps, preloadedFeatures2);
        const layoutProjection = getProjectionFunctionality(configAndProps);
        MeasureLayout2 = layoutProjection.MeasureLayout;
        context.visualElement = useVisualElement(Component3, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
      }
      return (0, import_jsx_runtime10.jsxs)(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? (0, import_jsx_runtime10.jsx)(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component3, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
    }
    const ForwardRefComponent = (0, import_react16.forwardRef)(MotionComponent);
    ForwardRefComponent[motionComponentSymbol] = Component3;
    return ForwardRefComponent;
  }
  function useLayoutId({ layoutId }) {
    const layoutGroupId = (0, import_react16.useContext)(LayoutGroupContext).id;
    return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
  }
  function useStrictMode(configAndProps, preloadedFeatures2) {
    const isStrict = (0, import_react16.useContext)(LazyContext).strict;
    if (false) {
      const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      configAndProps.ignoreStrict ? warning(false, strictMessage) : invariant(false, strictMessage);
    }
  }
  function getProjectionFunctionality(props) {
    const { drag: drag2, layout: layout2 } = featureDefinitions;
    if (!drag2 && !layout2)
      return {};
    const combined = { ...drag2, ...layout2 };
    return {
      MeasureLayout: (drag2 === null || drag2 === void 0 ? void 0 : drag2.isEnabled(props)) || (layout2 === null || layout2 === void 0 ? void 0 : layout2.isEnabled(props)) ? combined.MeasureLayout : void 0,
      ProjectionNode: combined.ProjectionNode
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs
  function createMotionProxy(createConfig) {
    function custom(Component3, customMotionComponentConfig = {}) {
      return createMotionComponent(createConfig(Component3, customMotionComponentConfig));
    }
    if (typeof Proxy === "undefined") {
      return custom;
    }
    const componentCache = /* @__PURE__ */ new Map();
    return new Proxy(custom, {
      /**
       * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
       * The prop name is passed through as `key` and we can use that to generate a `motion`
       * DOM component with that name.
       */
      get: (_target, key) => {
        if (!componentCache.has(key)) {
          componentCache.set(key, custom(key));
        }
        return componentCache.get(key);
      }
    });
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
  var lowercaseSVGElements = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "switch",
    "symbol",
    "svg",
    "text",
    "tspan",
    "use",
    "view"
  ];

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
  function isSVGComponent(Component3) {
    if (
      /**
       * If it's not a string, it's a custom React component. Currently we only support
       * HTML custom React components.
       */
      typeof Component3 !== "string" || /**
       * If it contains a dash, the element is a custom HTML webcomponent.
       */
      Component3.includes("-")
    ) {
      return false;
    } else if (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      lowercaseSVGElements.indexOf(Component3) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(Component3)
    ) {
      return true;
    }
    return false;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/use-render.mjs
  var import_react19 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/use-props.mjs
  var import_react17 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
  var scaleCorrectors = {};
  function addScaleCorrector(correctors) {
    Object.assign(scaleCorrectors, correctors);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/transform.mjs
  var transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY"
  ];
  var transformProps = new Set(transformPropOrder);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
  function isForcedMotionValue(key, { layout: layout2, layoutId }) {
    return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs
  var isMotionValue = (value) => Boolean(value && value.getVelocity);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
  var translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  var numTransforms = transformPropOrder.length;
  function buildTransform(transform, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {
    let transformString = "";
    for (let i2 = 0; i2 < numTransforms; i2++) {
      const key = transformPropOrder[i2];
      if (transform[key] !== void 0) {
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${transform[key]}) `;
      }
    }
    if (enableHardwareAcceleration && !transform.z) {
      transformString += "translateZ(0)";
    }
    transformString = transformString.trim();
    if (transformTemplate) {
      transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
    } else if (allowTransformNone && transformIsDefault) {
      transformString = "none";
    }
    return transformString;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs
  var checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
  var isCSSVariableName = checkStringStartsWith("--");
  var startsAsVariableToken = checkStringStartsWith("var(--");
  var isCSSVariableToken = (value) => {
    const startsWithToken = startsAsVariableToken(value);
    if (!startsWithToken)
      return false;
    return singleCssVariableRegex.test(value.split("/*")[0].trim());
  };
  var singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs
  var getValueAsType = (value, type) => {
    return type && typeof value === "number" ? type.transform(value) : value;
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/clamp.mjs
  var clamp = (min, max, v2) => {
    if (v2 > max)
      return max;
    if (v2 < min)
      return min;
    return v2;
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/numbers/index.mjs
  var number2 = {
    test: (v2) => typeof v2 === "number",
    parse: parseFloat,
    transform: (v2) => v2
  };
  var alpha = {
    ...number2,
    transform: (v2) => clamp(0, 1, v2)
  };
  var scale = {
    ...number2,
    default: 1
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/utils.mjs
  var sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;
  var floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
  var colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
  var singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
  function isString(v2) {
    return typeof v2 === "string";
  }
  function isNullish(v2) {
    return v2 == null;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/numbers/units.mjs
  var createUnitType = (unit) => ({
    test: (v2) => isString(v2) && v2.endsWith(unit) && v2.split(" ").length === 1,
    parse: parseFloat,
    transform: (v2) => `${v2}${unit}`
  });
  var degrees = createUnitType("deg");
  var percent = createUnitType("%");
  var px = createUnitType("px");
  var vh = createUnitType("vh");
  var vw = createUnitType("vw");
  var progressPercentage = {
    ...percent,
    parse: (v2) => percent.parse(v2) / 100,
    transform: (v2) => percent.transform(v2 * 100)
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs
  var int = {
    ...number2,
    transform: Math.round
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs
  var numberValueTypes = {
    // Border props
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    // Positioning props
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    size: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    // Spacing props
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    // Transform props
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px,
    // Misc
    zIndex: int,
    backgroundPositionX: px,
    backgroundPositionY: px,
    // SVG
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
  function buildHTMLStyles(state, latestValues, options, transformTemplate) {
    const { style, vars, transform, transformOrigin } = state;
    let hasTransform2 = false;
    let hasTransformOrigin = false;
    let transformIsNone = true;
    for (const key in latestValues) {
      const value = latestValues[key];
      if (isCSSVariableName(key)) {
        vars[key] = value;
        continue;
      }
      const valueType = numberValueTypes[key];
      const valueAsType = getValueAsType(value, valueType);
      if (transformProps.has(key)) {
        hasTransform2 = true;
        transform[key] = valueAsType;
        if (!transformIsNone)
          continue;
        if (value !== (valueType.default || 0))
          transformIsNone = false;
      } else if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
    if (!latestValues.transform) {
      if (hasTransform2 || transformTemplate) {
        style.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);
      } else if (style.transform) {
        style.transform = "none";
      }
    }
    if (hasTransformOrigin) {
      const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
      style.transformOrigin = `${originX} ${originY} ${originZ}`;
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
  var createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
  });

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/use-props.mjs
  function copyRawValuesOnly(target, source, props) {
    for (const key in source) {
      if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
        target[key] = source[key];
      }
    }
  }
  function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
    return (0, import_react17.useMemo)(() => {
      const state = createHtmlRenderState();
      buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
      return Object.assign({}, state.vars, state.style);
    }, [visualState]);
  }
  function useStyle(props, visualState, isStatic) {
    const styleProp = props.style || {};
    const style = {};
    copyRawValuesOnly(style, styleProp, props);
    Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
    return style;
  }
  function useHTMLProps(props, visualState, isStatic) {
    const htmlProps = {};
    const style = useStyle(props, visualState, isStatic);
    if (props.drag && props.dragListener !== false) {
      htmlProps.draggable = false;
      style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
      style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
    }
    if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
      htmlProps.tabIndex = 0;
    }
    htmlProps.style = style;
    return htmlProps;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
  var validMotionProps = /* @__PURE__ */ new Set([
    "animate",
    "exit",
    "variants",
    "initial",
    "style",
    "values",
    "variants",
    "transition",
    "transformTemplate",
    "custom",
    "inherit",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "_dragX",
    "_dragY",
    "onHoverStart",
    "onHoverEnd",
    "onViewportEnter",
    "onViewportLeave",
    "globalTapTarget",
    "ignoreStrict",
    "viewport"
  ]);
  function isValidMotionProp(key) {
    return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
  var shouldForward = (key) => !isValidMotionProp(key);
  function loadExternalIsValidProp(isValidProp) {
    if (!isValidProp)
      return;
    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  }
  try {
    loadExternalIsValidProp((init_is_prop_valid_esm(), __toCommonJS(is_prop_valid_esm_exports)).default);
  } catch (_a) {
  }
  function filterProps(props, isDom, forwardMotionProps) {
    const filteredProps = {};
    for (const key in props) {
      if (key === "values" && typeof props.values === "object")
        continue;
      if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
      props["draggable"] && key.startsWith("onDrag")) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/use-props.mjs
  var import_react18 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs
  function calcOrigin(origin, offset, size3) {
    return typeof origin === "string" ? origin : px.transform(offset + size3 * origin);
  }
  function calcSVGTransformOrigin(dimensions, originX, originY) {
    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
    return `${pxOriginX} ${pxOriginY}`;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
  var dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  };
  var camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
    attrs.pathLength = 1;
    const keys = useDashCase ? dashKeys : camelKeys;
    attrs[keys.offset] = px.transform(-offset);
    const pathLength = px.transform(length);
    const pathSpacing = px.transform(spacing);
    attrs[keys.array] = `${pathLength} ${pathSpacing}`;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
  function buildSVGAttrs(state, {
    attrX,
    attrY,
    attrScale,
    originX,
    originY,
    pathLength,
    pathSpacing = 1,
    pathOffset = 0,
    // This is object creation, which we try to avoid per-frame.
    ...latest
  }, options, isSVGTag2, transformTemplate) {
    buildHTMLStyles(state, latest, options, transformTemplate);
    if (isSVGTag2) {
      if (state.style.viewBox) {
        state.attrs.viewBox = state.style.viewBox;
      }
      return;
    }
    state.attrs = state.style;
    state.style = {};
    const { attrs, style, dimensions } = state;
    if (attrs.transform) {
      if (dimensions)
        style.transform = attrs.transform;
      delete attrs.transform;
    }
    if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
      style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
    }
    if (attrX !== void 0)
      attrs.x = attrX;
    if (attrY !== void 0)
      attrs.y = attrY;
    if (attrScale !== void 0)
      attrs.scale = attrScale;
    if (pathLength !== void 0) {
      buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
  var createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {}
  });

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs
  var isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/use-props.mjs
  function useSVGProps(props, visualState, _isStatic, Component3) {
    const visualProps = (0, import_react18.useMemo)(() => {
      const state = createSvgRenderState();
      buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component3), props.transformTemplate);
      return {
        ...state.attrs,
        style: { ...state.style }
      };
    }, [visualState]);
    if (props.style) {
      const rawStyles = {};
      copyRawValuesOnly(rawStyles, props.style, props);
      visualProps.style = { ...rawStyles, ...visualProps.style };
    }
    return visualProps;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/use-render.mjs
  function createUseRender(forwardMotionProps = false) {
    const useRender = (Component3, props, ref, { latestValues }, isStatic) => {
      const useVisualProps = isSVGComponent(Component3) ? useSVGProps : useHTMLProps;
      const visualProps = useVisualProps(props, latestValues, isStatic, Component3);
      const filteredProps = filterProps(props, typeof Component3 === "string", forwardMotionProps);
      const elementProps = Component3 !== import_react19.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
      const { children } = props;
      const renderedChildren = (0, import_react19.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);
      return (0, import_react19.createElement)(Component3, {
        ...elementProps,
        children: renderedChildren
      });
    };
    return useRender;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/render.mjs
  function renderHTML(element, { style, vars }, styleProp, projection) {
    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
    for (const key in vars) {
      element.style.setProperty(key, vars[key]);
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
  var camelCaseAttributes = /* @__PURE__ */ new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust"
  ]);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
  function renderSVG(element, renderState, _styleProp, projection) {
    renderHTML(element, renderState, void 0, projection);
    for (const key in renderState.attrs) {
      element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
  function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    var _a;
    const { style } = props;
    const newValues = {};
    for (const key in style) {
      if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== void 0) {
        newValues[key] = style[key];
      }
    }
    return newValues;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
  function scrapeMotionValuesFromProps2(props, prevProps, visualElement) {
    const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);
    for (const key in props) {
      if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
        const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
        newValues[targetKey] = props[key];
      }
    }
    return newValues;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
  var import_react21 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs
  function getValueState(visualElement) {
    const state = [{}, {}];
    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {
      state[0][key] = value.get();
      state[1][key] = value.getVelocity();
    });
    return state;
  }
  function resolveVariantFromProps(props, definition, custom, visualElement) {
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    if (typeof definition === "string") {
      definition = props.variants && props.variants[definition];
    }
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    return definition;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-constant.mjs
  var import_react20 = __toESM(require_react(), 1);
  function useConstant(init2) {
    const ref = (0, import_react20.useRef)(null);
    if (ref.current === null) {
      ref.current = init2();
    }
    return ref.current;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
  var isKeyframesTarget = (v2) => {
    return Array.isArray(v2);
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/resolve-value.mjs
  var isCustomValue = (v2) => {
    return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
  };
  var resolveFinalValueInKeyframes = (v2) => {
    return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
  function resolveMotionValue(value) {
    const unwrappedValue = isMotionValue(value) ? value.get() : value;
    return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
  function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount }, props, context, presenceContext) {
    const state = {
      latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
      renderState: createRenderState()
    };
    if (onMount) {
      state.mount = (instance) => onMount(props, instance, state);
    }
    return state;
  }
  var makeUseVisualState = (config) => (props, isStatic) => {
    const context = (0, import_react21.useContext)(MotionContext);
    const presenceContext = (0, import_react21.useContext)(PresenceContext);
    const make = () => makeState(config, props, context, presenceContext);
    return isStatic ? make() : useConstant(make);
  };
  function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
    const values = {};
    const motionValues = scrapeMotionValues(props, {});
    for (const key in motionValues) {
      values[key] = resolveMotionValue(motionValues[key]);
    }
    let { initial, animate } = props;
    const isControllingVariants$1 = isControllingVariants(props);
    const isVariantNode$1 = isVariantNode(props);
    if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
      if (initial === void 0)
        initial = context.initial;
      if (animate === void 0)
        animate = context.animate;
    }
    let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
    const variantToSet = isInitialAnimationBlocked ? animate : initial;
    if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
      const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
      list.forEach((definition) => {
        const resolved = resolveVariantFromProps(props, definition);
        if (!resolved)
          return;
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index2];
          }
          if (valueTarget !== null) {
            values[key] = valueTarget;
          }
        }
        for (const key in transitionEnd)
          values[key] = transitionEnd[key];
      });
    }
    return values;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/frameloop/frame.mjs
  var { schedule: frame, cancel: cancelFrame, state: frameData, steps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/config-motion.mjs
  var svgMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
      createRenderState: createSvgRenderState,
      onMount: (props, instance, { renderState, latestValues }) => {
        frame.read(() => {
          try {
            renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
          } catch (e2) {
            renderState.dimensions = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
          }
        });
        frame.render(() => {
          buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance.tagName), props.transformTemplate);
          renderSVG(instance, renderState);
        });
      }
    })
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/config-motion.mjs
  var htmlMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps,
      createRenderState: createHtmlRenderState
    })
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs
  function createDomMotionConfig(Component3, { forwardMotionProps = false }, preloadedFeatures2, createVisualElement) {
    const baseConfig = isSVGComponent(Component3) ? svgMotionConfig : htmlMotionConfig;
    return {
      ...baseConfig,
      preloadedFeatures: preloadedFeatures2,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component: Component3
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/events/add-dom-event.mjs
  function addDomEvent(target, eventName, handler, options = { passive: true }) {
    target.addEventListener(eventName, handler, options);
    return () => target.removeEventListener(eventName, handler);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/events/utils/is-primary-pointer.mjs
  var isPrimaryPointer = (event) => {
    if (event.pointerType === "mouse") {
      return typeof event.button !== "number" || event.button <= 0;
    } else {
      return event.isPrimary !== false;
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/events/event-info.mjs
  function extractEventInfo(event, pointType = "page") {
    return {
      point: {
        x: event[`${pointType}X`],
        y: event[`${pointType}Y`]
      }
    };
  }
  var addPointerInfo = (handler) => {
    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/events/add-pointer-event.mjs
  function addPointerEvent(target, eventName, handler, options) {
    return addDomEvent(target, eventName, addPointerInfo(handler), options);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/pipe.mjs
  var combineFunctions = (a2, b2) => (v2) => b2(a2(v2));
  var pipe = (...transformers) => transformers.reduce(combineFunctions);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs
  function createLock(name) {
    let lock = null;
    return () => {
      const openLock = () => {
        lock = null;
      };
      if (lock === null) {
        lock = name;
        return openLock;
      }
      return false;
    };
  }
  var globalHorizontalLock = createLock("dragHorizontal");
  var globalVerticalLock = createLock("dragVertical");
  function getGlobalLock(drag2) {
    let lock = false;
    if (drag2 === "y") {
      lock = globalVerticalLock();
    } else if (drag2 === "x") {
      lock = globalHorizontalLock();
    } else {
      const openHorizontal = globalHorizontalLock();
      const openVertical = globalVerticalLock();
      if (openHorizontal && openVertical) {
        lock = () => {
          openHorizontal();
          openVertical();
        };
      } else {
        if (openHorizontal)
          openHorizontal();
        if (openVertical)
          openVertical();
      }
    }
    return lock;
  }
  function isDragActive() {
    const openGestureLock = getGlobalLock(true);
    if (!openGestureLock)
      return true;
    openGestureLock();
    return false;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/Feature.mjs
  var Feature = class {
    constructor(node) {
      this.isMounted = false;
      this.node = node;
    }
    update() {
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/hover.mjs
  function addHoverEvent(node, isActive) {
    const eventName = isActive ? "pointerenter" : "pointerleave";
    const callbackName = isActive ? "onHoverStart" : "onHoverEnd";
    const handleEvent = (event, info) => {
      if (event.pointerType === "touch" || isDragActive())
        return;
      const props = node.getProps();
      if (node.animationState && props.whileHover) {
        node.animationState.setActive("whileHover", isActive);
      }
      const callback = props[callbackName];
      if (callback) {
        frame.postRender(() => callback(event, info));
      }
    };
    return addPointerEvent(node.current, eventName, handleEvent, {
      passive: !node.getProps()[callbackName]
    });
  }
  var HoverGesture = class extends Feature {
    mount() {
      this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
    }
    unmount() {
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/focus.mjs
  var FocusGesture = class extends Feature {
    constructor() {
      super(...arguments);
      this.isActive = false;
    }
    onFocus() {
      let isFocusVisible = false;
      try {
        isFocusVisible = this.node.current.matches(":focus-visible");
      } catch (e2) {
        isFocusVisible = true;
      }
      if (!isFocusVisible || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", true);
      this.isActive = true;
    }
    onBlur() {
      if (!this.isActive || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", false);
      this.isActive = false;
    }
    mount() {
      this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
    }
    unmount() {
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs
  var isNodeOrChild = (parent, child) => {
    if (!child) {
      return false;
    } else if (parent === child) {
      return true;
    } else {
      return isNodeOrChild(parent, child.parentElement);
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/press.mjs
  function fireSyntheticPointerEvent(name, handler) {
    if (!handler)
      return;
    const syntheticPointerEvent = new PointerEvent("pointer" + name);
    handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
  }
  var PressGesture = class extends Feature {
    constructor() {
      super(...arguments);
      this.removeStartListeners = noop;
      this.removeEndListeners = noop;
      this.removeAccessibleListeners = noop;
      this.startPointerPress = (startEvent, startInfo) => {
        if (this.isPressing)
          return;
        this.removeEndListeners();
        const props = this.node.getProps();
        const endPointerPress = (endEvent, endInfo) => {
          if (!this.checkPressEnd())
            return;
          const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();
          const handler = !globalTapTarget && !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel : onTap;
          if (handler) {
            frame.update(() => handler(endEvent, endInfo));
          }
        };
        const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, {
          passive: !(props.onTap || props["onPointerUp"])
        });
        const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), {
          passive: !(props.onTapCancel || props["onPointerCancel"])
        });
        this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
        this.startPress(startEvent, startInfo);
      };
      this.startAccessiblePress = () => {
        const handleKeydown = (keydownEvent) => {
          if (keydownEvent.key !== "Enter" || this.isPressing)
            return;
          const handleKeyup = (keyupEvent) => {
            if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
              return;
            fireSyntheticPointerEvent("up", (event, info) => {
              const { onTap } = this.node.getProps();
              if (onTap) {
                frame.postRender(() => onTap(event, info));
              }
            });
          };
          this.removeEndListeners();
          this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
          fireSyntheticPointerEvent("down", (event, info) => {
            this.startPress(event, info);
          });
        };
        const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
        const handleBlur = () => {
          if (!this.isPressing)
            return;
          fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
        };
        const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
        this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
      };
    }
    startPress(event, info) {
      this.isPressing = true;
      const { onTapStart, whileTap } = this.node.getProps();
      if (whileTap && this.node.animationState) {
        this.node.animationState.setActive("whileTap", true);
      }
      if (onTapStart) {
        frame.postRender(() => onTapStart(event, info));
      }
    }
    checkPressEnd() {
      this.removeEndListeners();
      this.isPressing = false;
      const props = this.node.getProps();
      if (props.whileTap && this.node.animationState) {
        this.node.animationState.setActive("whileTap", false);
      }
      return !isDragActive();
    }
    cancelPress(event, info) {
      if (!this.checkPressEnd())
        return;
      const { onTapCancel } = this.node.getProps();
      if (onTapCancel) {
        frame.postRender(() => onTapCancel(event, info));
      }
    }
    mount() {
      const props = this.node.getProps();
      const removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
        passive: !(props.onTapStart || props["onPointerStart"])
      });
      const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
      this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
    }
    unmount() {
      this.removeStartListeners();
      this.removeEndListeners();
      this.removeAccessibleListeners();
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
  var observerCallbacks = /* @__PURE__ */ new WeakMap();
  var observers = /* @__PURE__ */ new WeakMap();
  var fireObserverCallback = (entry) => {
    const callback = observerCallbacks.get(entry.target);
    callback && callback(entry);
  };
  var fireAllObserverCallbacks = (entries) => {
    entries.forEach(fireObserverCallback);
  };
  function initIntersectionObserver({ root: root2, ...options }) {
    const lookupRoot = root2 || document;
    if (!observers.has(lookupRoot)) {
      observers.set(lookupRoot, {});
    }
    const rootObservers = observers.get(lookupRoot);
    const key = JSON.stringify(options);
    if (!rootObservers[key]) {
      rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options });
    }
    return rootObservers[key];
  }
  function observeIntersection(element, options, callback) {
    const rootInteresectionObserver = initIntersectionObserver(options);
    observerCallbacks.set(element, callback);
    rootInteresectionObserver.observe(element);
    return () => {
      observerCallbacks.delete(element);
      rootInteresectionObserver.unobserve(element);
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs
  var thresholdNames = {
    some: 0,
    all: 1
  };
  var InViewFeature = class extends Feature {
    constructor() {
      super(...arguments);
      this.hasEnteredView = false;
      this.isInView = false;
    }
    startObserver() {
      this.unmount();
      const { viewport = {} } = this.node.getProps();
      const { root: root2, margin: rootMargin, amount = "some", once } = viewport;
      const options = {
        root: root2 ? root2.current : void 0,
        rootMargin,
        threshold: typeof amount === "number" ? amount : thresholdNames[amount]
      };
      const onIntersectionUpdate = (entry) => {
        const { isIntersecting } = entry;
        if (this.isInView === isIntersecting)
          return;
        this.isInView = isIntersecting;
        if (once && !isIntersecting && this.hasEnteredView) {
          return;
        } else if (isIntersecting) {
          this.hasEnteredView = true;
        }
        if (this.node.animationState) {
          this.node.animationState.setActive("whileInView", isIntersecting);
        }
        const { onViewportEnter, onViewportLeave } = this.node.getProps();
        const callback = isIntersecting ? onViewportEnter : onViewportLeave;
        callback && callback(entry);
      };
      return observeIntersection(this.node.current, options, onIntersectionUpdate);
    }
    mount() {
      this.startObserver();
    }
    update() {
      if (typeof IntersectionObserver === "undefined")
        return;
      const { props, prevProps } = this.node;
      const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
      if (hasOptionsChanged) {
        this.startObserver();
      }
    }
    unmount() {
    }
  };
  function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
    return (name) => viewport[name] !== prevViewport[name];
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/gestures.mjs
  var gestureAnimations = {
    inView: {
      Feature: InViewFeature
    },
    tap: {
      Feature: PressGesture
    },
    focus: {
      Feature: FocusGesture
    },
    hover: {
      Feature: HoverGesture
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
  function shallowCompare(next, prev) {
    if (!Array.isArray(prev))
      return false;
    const prevLength = prev.length;
    if (prevLength !== next.length)
      return false;
    for (let i2 = 0; i2 < prevLength; i2++) {
      if (prev[i2] !== next[i2])
        return false;
    }
    return true;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs
  function resolveVariant(visualElement, definition, custom) {
    const props = visualElement.getProps();
    return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/time-conversion.mjs
  var secondsToMilliseconds = (seconds) => seconds * 1e3;
  var millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
  var underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
  var criticallyDampedSpring = (target) => ({
    type: "spring",
    stiffness: 550,
    damping: target === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  });
  var keyframesTransition = {
    type: "keyframes",
    duration: 0.8
  };
  var ease = {
    type: "keyframes",
    ease: [0.25, 0.1, 0.35, 1],
    duration: 0.3
  };
  var getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
    if (keyframes2.length > 2) {
      return keyframesTransition;
    } else if (transformProps.has(valueKey)) {
      return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
    }
    return ease;
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/transitions.mjs
  function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from6, elapsed, ...transition }) {
    return !!Object.keys(transition).length;
  }
  function getValueTransition(transition, key) {
    return transition[key] || transition["default"] || transition;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs
  var instantAnimationState = {
    current: false
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs
  var isNotNull = (value) => value !== null;
  function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
    const resolvedKeyframes = keyframes2.filter(isNotNull);
    const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
    return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/frameloop/sync-time.mjs
  var now;
  function clearTime() {
    now = void 0;
  }
  var time = {
    now: () => {
      if (now === void 0) {
        time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
      }
      return now;
    },
    set: (newTime) => {
      now = newTime;
      queueMicrotask(clearTime);
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs
  var isZeroValueString = (v2) => /^0[^.\s]+$/u.test(v2);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/is-none.mjs
  function isNone(value) {
    if (typeof value === "number") {
      return value === 0;
    } else if (value !== null) {
      return value === "none" || value === "0" || isZeroValueString(value);
    } else {
      return true;
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs
  var isNumericalString = (v2) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v2);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs
  var splitCSSVariableRegex = (
    // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
    /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
  );
  function parseCSSVariable(current) {
    const match = splitCSSVariableRegex.exec(current);
    if (!match)
      return [,];
    const [, token1, token2, fallback] = match;
    return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];
  }
  var maxDepth = 4;
  function getVariableValue(current, element, depth = 1) {
    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
    const [token, fallback] = parseCSSVariable(current);
    if (!token)
      return;
    const resolved = window.getComputedStyle(element).getPropertyValue(token);
    if (resolved) {
      const trimmed = resolved.trim();
      return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
    }
    return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs
  var positionalKeys = /* @__PURE__ */ new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y",
    "translateX",
    "translateY"
  ]);
  var isNumOrPxType = (v2) => v2 === number2 || v2 === px;
  var getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
  var getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
    if (transform === "none" || !transform)
      return 0;
    const matrix3d = transform.match(/^matrix3d\((.+)\)$/u);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      const matrix = transform.match(/^matrix\((.+)\)$/u);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
  var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
  var nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
  function removeNonTranslationalTransform(visualElement) {
    const removedTransforms = [];
    nonTranslationalTransformKeys.forEach((key) => {
      const value = visualElement.getValue(key);
      if (value !== void 0) {
        removedTransforms.push([key, value.get()]);
        value.set(key.startsWith("scale") ? 1 : 0);
      }
    });
    return removedTransforms;
  }
  var positionalValues = {
    // Dimensions
    width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
    height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
    top: (_bbox, { top }) => parseFloat(top),
    left: (_bbox, { left }) => parseFloat(left),
    bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
    right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
    // Transform
    x: getTranslateFromMatrix(4, 13),
    y: getTranslateFromMatrix(5, 14)
  };
  positionalValues.translateX = positionalValues.x;
  positionalValues.translateY = positionalValues.y;

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs
  var testValueType = (v2) => (type) => type.test(v2);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs
  var auto = {
    test: (v2) => v2 === "auto",
    parse: (v2) => v2
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs
  var dimensionValueTypes = [number2, px, percent, degrees, vw, vh, auto];
  var findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs
  var toResolve = /* @__PURE__ */ new Set();
  var isScheduled = false;
  var anyNeedsMeasurement = false;
  function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
      const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
      const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
      const transformsToRestore = /* @__PURE__ */ new Map();
      elementsToMeasure.forEach((element) => {
        const removedTransforms = removeNonTranslationalTransform(element);
        if (!removedTransforms.length)
          return;
        transformsToRestore.set(element, removedTransforms);
        element.render();
      });
      resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
      elementsToMeasure.forEach((element) => {
        element.render();
        const restore = transformsToRestore.get(element);
        if (restore) {
          restore.forEach(([key, value]) => {
            var _a;
            (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);
          });
        }
      });
      resolversToMeasure.forEach((resolver) => resolver.measureEndState());
      resolversToMeasure.forEach((resolver) => {
        if (resolver.suspendedScrollY !== void 0) {
          window.scrollTo(0, resolver.suspendedScrollY);
        }
      });
    }
    anyNeedsMeasurement = false;
    isScheduled = false;
    toResolve.forEach((resolver) => resolver.complete());
    toResolve.clear();
  }
  function readAllKeyframes() {
    toResolve.forEach((resolver) => {
      resolver.readKeyframes();
      if (resolver.needsMeasurement) {
        anyNeedsMeasurement = true;
      }
    });
  }
  function flushKeyframeResolvers() {
    readAllKeyframes();
    measureAllKeyframes();
  }
  var KeyframeResolver = class {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
      this.isComplete = false;
      this.isAsync = false;
      this.needsMeasurement = false;
      this.isScheduled = false;
      this.unresolvedKeyframes = [...unresolvedKeyframes];
      this.onComplete = onComplete;
      this.name = name;
      this.motionValue = motionValue2;
      this.element = element;
      this.isAsync = isAsync;
    }
    scheduleResolve() {
      this.isScheduled = true;
      if (this.isAsync) {
        toResolve.add(this);
        if (!isScheduled) {
          isScheduled = true;
          frame.read(readAllKeyframes);
          frame.resolveKeyframes(measureAllKeyframes);
        }
      } else {
        this.readKeyframes();
        this.complete();
      }
    }
    readKeyframes() {
      const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        if (unresolvedKeyframes[i2] === null) {
          if (i2 === 0) {
            const currentValue = motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.get();
            const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
            if (currentValue !== void 0) {
              unresolvedKeyframes[0] = currentValue;
            } else if (element && name) {
              const valueAsRead = element.readValue(name, finalKeyframe);
              if (valueAsRead !== void 0 && valueAsRead !== null) {
                unresolvedKeyframes[0] = valueAsRead;
              }
            }
            if (unresolvedKeyframes[0] === void 0) {
              unresolvedKeyframes[0] = finalKeyframe;
            }
            if (motionValue2 && currentValue === void 0) {
              motionValue2.set(unresolvedKeyframes[0]);
            }
          } else {
            unresolvedKeyframes[i2] = unresolvedKeyframes[i2 - 1];
          }
        }
      }
    }
    setFinalKeyframe() {
    }
    measureInitialState() {
    }
    renderEndStyles() {
    }
    measureEndState() {
    }
    complete() {
      this.isComplete = true;
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
      toResolve.delete(this);
    }
    cancel() {
      if (!this.isComplete) {
        this.isScheduled = false;
        toResolve.delete(this);
      }
    }
    resume() {
      if (!this.isComplete)
        this.scheduleResolve();
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/color/utils.mjs
  var isColorString = (type, testProp) => (v2) => {
    return Boolean(isString(v2) && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && !isNullish(v2) && Object.prototype.hasOwnProperty.call(v2, testProp));
  };
  var splitColor = (aName, bName, cName) => (v2) => {
    if (!isString(v2))
      return v2;
    const [a2, b2, c2, alpha2] = v2.match(floatRegex);
    return {
      [aName]: parseFloat(a2),
      [bName]: parseFloat(b2),
      [cName]: parseFloat(c2),
      alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
    };
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/color/rgba.mjs
  var clampRgbUnit = (v2) => clamp(0, 255, v2);
  var rgbUnit = {
    ...number2,
    transform: (v2) => Math.round(clampRgbUnit(v2))
  };
  var rgba = {
    test: isColorString("rgb", "red"),
    parse: splitColor("red", "green", "blue"),
    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/color/hex.mjs
  function parseHex(v2) {
    let r3 = "";
    let g2 = "";
    let b2 = "";
    let a2 = "";
    if (v2.length > 5) {
      r3 = v2.substring(1, 3);
      g2 = v2.substring(3, 5);
      b2 = v2.substring(5, 7);
      a2 = v2.substring(7, 9);
    } else {
      r3 = v2.substring(1, 2);
      g2 = v2.substring(2, 3);
      b2 = v2.substring(3, 4);
      a2 = v2.substring(4, 5);
      r3 += r3;
      g2 += g2;
      b2 += b2;
      a2 += a2;
    }
    return {
      red: parseInt(r3, 16),
      green: parseInt(g2, 16),
      blue: parseInt(b2, 16),
      alpha: a2 ? parseInt(a2, 16) / 255 : 1
    };
  }
  var hex = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/color/hsla.mjs
  var hsla = {
    test: isColorString("hsl", "hue"),
    parse: splitColor("hue", "saturation", "lightness"),
    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
      return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/color/index.mjs
  var color = {
    test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
    parse: (v2) => {
      if (rgba.test(v2)) {
        return rgba.parse(v2);
      } else if (hsla.test(v2)) {
        return hsla.parse(v2);
      } else {
        return hex.parse(v2);
      }
    },
    transform: (v2) => {
      return isString(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/complex/index.mjs
  function test(v2) {
    var _a, _b;
    return isNaN(v2) && isString(v2) && (((_a = v2.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v2.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
  }
  var NUMBER_TOKEN = "number";
  var COLOR_TOKEN = "color";
  var VAR_TOKEN = "var";
  var VAR_FUNCTION_TOKEN = "var(";
  var SPLIT_TOKEN = "${}";
  var complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
  function analyseComplexValue(value) {
    const originalValue = value.toString();
    const values = [];
    const indexes = {
      color: [],
      number: [],
      var: []
    };
    const types = [];
    let i2 = 0;
    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
      if (color.test(parsedValue)) {
        indexes.color.push(i2);
        types.push(COLOR_TOKEN);
        values.push(color.parse(parsedValue));
      } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
        indexes.var.push(i2);
        types.push(VAR_TOKEN);
        values.push(parsedValue);
      } else {
        indexes.number.push(i2);
        types.push(NUMBER_TOKEN);
        values.push(parseFloat(parsedValue));
      }
      ++i2;
      return SPLIT_TOKEN;
    });
    const split2 = tokenised.split(SPLIT_TOKEN);
    return { values, split: split2, indexes, types };
  }
  function parseComplexValue(v2) {
    return analyseComplexValue(v2).values;
  }
  function createTransformer(source) {
    const { split: split2, types } = analyseComplexValue(source);
    const numSections = split2.length;
    return (v2) => {
      let output2 = "";
      for (let i2 = 0; i2 < numSections; i2++) {
        output2 += split2[i2];
        if (v2[i2] !== void 0) {
          const type = types[i2];
          if (type === NUMBER_TOKEN) {
            output2 += sanitize(v2[i2]);
          } else if (type === COLOR_TOKEN) {
            output2 += color.transform(v2[i2]);
          } else {
            output2 += v2[i2];
          }
        }
      }
      return output2;
    };
  }
  var convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
  function getAnimatableNone(v2) {
    const parsed = parseComplexValue(v2);
    const transformer = createTransformer(v2);
    return transformer(parsed.map(convertNumbersToZero));
  }
  var complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/complex/filter.mjs
  var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
  function applyDefaultFilter(v2) {
    const [name, value] = v2.slice(0, -1).split("(");
    if (name === "drop-shadow")
      return v2;
    const [number3] = value.match(floatRegex) || [];
    if (!number3)
      return v2;
    const unit = value.replace(number3, "");
    let defaultValue = maxDefaults.has(name) ? 1 : 0;
    if (number3 !== value)
      defaultValue *= 100;
    return name + "(" + defaultValue + unit + ")";
  }
  var functionRegex = /\b([a-z-]*)\(.*?\)/gu;
  var filter = {
    ...complex,
    getAnimatableNone: (v2) => {
      const functions = v2.match(functionRegex);
      return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs
  var defaultValueTypes = {
    ...numberValueTypes,
    // Color props
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    // Border props
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter
  };
  var getDefaultValueType = (key) => defaultValueTypes[key];

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs
  function getAnimatableNone2(key, value) {
    let defaultValueType = getDefaultValueType(key);
    if (defaultValueType !== filter)
      defaultValueType = complex;
    return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/make-none-animatable.mjs
  var invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
  function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
    let i2 = 0;
    let animatableTemplate = void 0;
    while (i2 < unresolvedKeyframes.length && !animatableTemplate) {
      const keyframe = unresolvedKeyframes[i2];
      if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
        animatableTemplate = unresolvedKeyframes[i2];
      }
      i2++;
    }
    if (animatableTemplate && name) {
      for (const noneIndex of noneKeyframeIndexes) {
        unresolvedKeyframes[noneIndex] = getAnimatableNone2(name, animatableTemplate);
      }
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs
  var DOMKeyframesResolver = class extends KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2) {
      super(unresolvedKeyframes, onComplete, name, motionValue2, motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.owner, true);
    }
    readKeyframes() {
      const { unresolvedKeyframes, element, name } = this;
      if (!element.current)
        return;
      super.readKeyframes();
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        let keyframe = unresolvedKeyframes[i2];
        if (typeof keyframe === "string") {
          keyframe = keyframe.trim();
          if (isCSSVariableToken(keyframe)) {
            const resolved = getVariableValue(keyframe, element.current);
            if (resolved !== void 0) {
              unresolvedKeyframes[i2] = resolved;
            }
            if (i2 === unresolvedKeyframes.length - 1) {
              this.finalKeyframe = keyframe;
            }
          }
        }
      }
      this.resolveNoneKeyframes();
      if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
        return;
      }
      const [origin, target] = unresolvedKeyframes;
      const originType = findDimensionValueType(origin);
      const targetType = findDimensionValueType(target);
      if (originType === targetType)
        return;
      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
        for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
          const value = unresolvedKeyframes[i2];
          if (typeof value === "string") {
            unresolvedKeyframes[i2] = parseFloat(value);
          }
        }
      } else {
        this.needsMeasurement = true;
      }
    }
    resolveNoneKeyframes() {
      const { unresolvedKeyframes, name } = this;
      const noneKeyframeIndexes = [];
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        if (isNone(unresolvedKeyframes[i2])) {
          noneKeyframeIndexes.push(i2);
        }
      }
      if (noneKeyframeIndexes.length) {
        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
      }
    }
    measureInitialState() {
      const { element, unresolvedKeyframes, name } = this;
      if (!element.current)
        return;
      if (name === "height") {
        this.suspendedScrollY = window.pageYOffset;
      }
      this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      unresolvedKeyframes[0] = this.measuredOrigin;
      const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (measureKeyframe !== void 0) {
        element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
      }
    }
    measureEndState() {
      var _a;
      const { element, name, unresolvedKeyframes } = this;
      if (!element.current)
        return;
      const value = element.getValue(name);
      value && value.jump(this.measuredOrigin, false);
      const finalKeyframeIndex = unresolvedKeyframes.length - 1;
      const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      if (finalKeyframe !== null && this.finalKeyframe === void 0) {
        this.finalKeyframe = finalKeyframe;
      }
      if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {
        this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
          element.getValue(unsetTransformName).set(unsetTransformValue);
        });
      }
      this.resolveNoneKeyframes();
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/memo.mjs
  function memo2(callback) {
    let result;
    return () => {
      if (result === void 0)
        result = callback();
      return result;
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs
  var isAnimatable = (value, name) => {
    if (name === "zIndex")
      return false;
    if (typeof value === "number" || Array.isArray(value))
      return true;
    if (typeof value === "string" && // It's animatable if we have a string
    (complex.test(value) || value === "0") && // And it contains numbers and/or colors
    !value.startsWith("url(")) {
      return true;
    }
    return false;
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/utils/can-animate.mjs
  function hasKeyframesChanged(keyframes2) {
    const current = keyframes2[0];
    if (keyframes2.length === 1)
      return true;
    for (let i2 = 0; i2 < keyframes2.length; i2++) {
      if (keyframes2[i2] !== current)
        return true;
    }
  }
  function canAnimate(keyframes2, name, type, velocity) {
    const originKeyframe = keyframes2[0];
    if (originKeyframe === null)
      return false;
    if (name === "display" || name === "visibility")
      return true;
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(originKeyframe, name);
    const isTargetAnimatable = isAnimatable(targetKeyframe, name);
    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
    if (!isOriginAnimatable || !isTargetAnimatable) {
      return false;
    }
    return hasKeyframesChanged(keyframes2) || type === "spring" && velocity;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs
  var BaseAnimation = class {
    constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {
      this.isStopped = false;
      this.hasAttemptedResolve = false;
      this.options = {
        autoplay,
        delay: delay2,
        type,
        repeat,
        repeatDelay,
        repeatType,
        ...options
      };
      this.updateFinishedPromise();
    }
    /**
     * A getter for resolved data. If keyframes are not yet resolved, accessing
     * this.resolved will synchronously flush all pending keyframe resolvers.
     * This is a deoptimisation, but at its worst still batches read/writes.
     */
    get resolved() {
      if (!this._resolved && !this.hasAttemptedResolve) {
        flushKeyframeResolvers();
      }
      return this._resolved;
    }
    /**
     * A method to be called when the keyframes resolver completes. This method
     * will check if its possible to run the animation and, if not, skip it.
     * Otherwise, it will call initPlayback on the implementing class.
     */
    onKeyframesResolved(keyframes2, finalKeyframe) {
      this.hasAttemptedResolve = true;
      const { name, type, velocity, delay: delay2, onComplete, onUpdate, isGenerator } = this.options;
      if (!isGenerator && !canAnimate(keyframes2, name, type, velocity)) {
        if (instantAnimationState.current || !delay2) {
          onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes2, this.options, finalKeyframe));
          onComplete === null || onComplete === void 0 ? void 0 : onComplete();
          this.resolveFinishedPromise();
          return;
        } else {
          this.options.duration = 0;
        }
      }
      const resolvedAnimation = this.initPlayback(keyframes2, finalKeyframe);
      if (resolvedAnimation === false)
        return;
      this._resolved = {
        keyframes: keyframes2,
        finalKeyframe,
        ...resolvedAnimation
      };
      this.onPostResolved();
    }
    onPostResolved() {
    }
    /**
     * Allows the returned animation to be awaited or promise-chained. Currently
     * resolves when the animation finishes at all but in a future update could/should
     * reject if its cancels.
     */
    then(resolve, reject) {
      return this.currentFinishedPromise.then(resolve, reject);
    }
    updateFinishedPromise() {
      this.currentFinishedPromise = new Promise((resolve) => {
        this.resolveFinishedPromise = resolve;
      });
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs
  function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1e3 / frameDuration) : 0;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs
  var velocitySampleDuration = 5;
  function calcGeneratorVelocity(resolveValue, t2, current) {
    const prevT = Math.max(t2 - velocitySampleDuration, 0);
    return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs
  var safeMin = 1e-3;
  var minDuration = 0.01;
  var maxDuration = 10;
  var minDamping = 0.05;
  var maxDamping = 1;
  function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
    let envelope;
    let derivative;
    warning(duration <= secondsToMilliseconds(maxDuration), "Spring duration must be 10 seconds or less");
    let dampingRatio = 1 - bounce;
    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
    duration = clamp(minDuration, maxDuration, millisecondsToSeconds(duration));
    if (dampingRatio < 1) {
      envelope = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const a2 = exponentialDecay - velocity;
        const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
        const c2 = Math.exp(-delta);
        return safeMin - a2 / b2 * c2;
      };
      derivative = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const d2 = delta * velocity + velocity;
        const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
        const f3 = Math.exp(-delta);
        const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
        const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
        return factor * ((d2 - e2) * f3) / g2;
      };
    } else {
      envelope = (undampedFreq2) => {
        const a2 = Math.exp(-undampedFreq2 * duration);
        const b2 = (undampedFreq2 - velocity) * duration + 1;
        return -safeMin + a2 * b2;
      };
      derivative = (undampedFreq2) => {
        const a2 = Math.exp(-undampedFreq2 * duration);
        const b2 = (velocity - undampedFreq2) * (duration * duration);
        return a2 * b2;
      };
    }
    const initialGuess = 5 / duration;
    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
    duration = secondsToMilliseconds(duration);
    if (isNaN(undampedFreq)) {
      return {
        stiffness: 100,
        damping: 10,
        duration
      };
    } else {
      const stiffness = Math.pow(undampedFreq, 2) * mass;
      return {
        stiffness,
        damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
        duration
      };
    }
  }
  var rootIterations = 12;
  function approximateRoot(envelope, derivative, initialGuess) {
    let result = initialGuess;
    for (let i2 = 1; i2 < rootIterations; i2++) {
      result = result - envelope(result) / derivative(result);
    }
    return result;
  }
  function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs
  var durationKeys = ["duration", "bounce"];
  var physicsKeys = ["stiffness", "damping", "mass"];
  function isSpringType(options, keys) {
    return keys.some((key) => options[key] !== void 0);
  }
  function getSpringOptions(options) {
    let springOptions = {
      velocity: 0,
      stiffness: 100,
      damping: 10,
      mass: 1,
      isResolvedFromDuration: false,
      ...options
    };
    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: 1
      };
      springOptions.isResolvedFromDuration = true;
    }
    return springOptions;
  }
  function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options }) {
    const origin = keyframes2[0];
    const target = keyframes2[keyframes2.length - 1];
    const state = { done: false, value: origin };
    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
      ...options,
      velocity: -millisecondsToSeconds(options.velocity || 0)
    });
    const initialVelocity = velocity || 0;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const initialDelta = target - origin;
    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
    restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
    let resolveSpring;
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        const freqForT = Math.min(dampedAngularFreq * t2, 300);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
    return {
      calculatedDuration: isResolvedFromDuration ? duration || null : null,
      next: (t2) => {
        const current = resolveSpring(t2);
        if (!isResolvedFromDuration) {
          let currentVelocity = initialVelocity;
          if (t2 !== 0) {
            if (dampingRatio < 1) {
              currentVelocity = calcGeneratorVelocity(resolveSpring, t2, current);
            } else {
              currentVelocity = 0;
            }
          }
          const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
          const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
          state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        } else {
          state.done = t2 >= duration;
        }
        state.value = state.done ? target : current;
        return state;
      }
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/generators/inertia.mjs
  function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
    const origin = keyframes2[0];
    const state = {
      done: false,
      value: origin
    };
    const isOutOfBounds = (v2) => min !== void 0 && v2 < min || max !== void 0 && v2 > max;
    const nearestBoundary = (v2) => {
      if (min === void 0)
        return max;
      if (max === void 0)
        return min;
      return Math.abs(min - v2) < Math.abs(max - v2) ? min : max;
    };
    let amplitude = power * velocity;
    const ideal = origin + amplitude;
    const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
    if (target !== ideal)
      amplitude = target - origin;
    const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant);
    const calcLatest = (t2) => target + calcDelta(t2);
    const applyFriction = (t2) => {
      const delta = calcDelta(t2);
      const latest = calcLatest(t2);
      state.done = Math.abs(delta) <= restDelta;
      state.value = state.done ? target : latest;
    };
    let timeReachedBoundary;
    let spring$1;
    const checkCatchBoundary = (t2) => {
      if (!isOutOfBounds(state.value))
        return;
      timeReachedBoundary = t2;
      spring$1 = spring({
        keyframes: [state.value, nearestBoundary(state.value)],
        velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
        // TODO: This should be passing * 1000
        damping: bounceDamping,
        stiffness: bounceStiffness,
        restDelta,
        restSpeed
      });
    };
    checkCatchBoundary(0);
    return {
      calculatedDuration: null,
      next: (t2) => {
        let hasUpdatedFrame = false;
        if (!spring$1 && timeReachedBoundary === void 0) {
          hasUpdatedFrame = true;
          applyFriction(t2);
          checkCatchBoundary(t2);
        }
        if (timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary) {
          return spring$1.next(t2 - timeReachedBoundary);
        } else {
          !hasUpdatedFrame && applyFriction(t2);
          return state;
        }
      }
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs
  var calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
  var subdivisionPrecision = 1e-7;
  var subdivisionMaxIterations = 12;
  function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i2 = 0;
    do {
      currentT = lowerBound + (upperBound - lowerBound) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - x2;
      if (currentX > 0) {
        upperBound = currentT;
      } else {
        lowerBound = currentT;
      }
    } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
    return currentT;
  }
  function cubicBezier(mX1, mY1, mX2, mY2) {
    if (mX1 === mY1 && mX2 === mY2)
      return noop;
    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
    return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/ease.mjs
  var easeIn = cubicBezier(0.42, 0, 1, 1);
  var easeOut = cubicBezier(0, 0, 0.58, 1);
  var easeInOut = cubicBezier(0.42, 0, 0.58, 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs
  var isEasingArray = (ease2) => {
    return Array.isArray(ease2) && typeof ease2[0] !== "number";
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs
  var mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs
  var reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/circ.mjs
  var circIn = (p2) => 1 - Math.sin(Math.acos(p2));
  var circOut = reverseEasing(circIn);
  var circInOut = mirrorEasing(circIn);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/back.mjs
  var backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
  var backIn = reverseEasing(backOut);
  var backInOut = mirrorEasing(backIn);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/anticipate.mjs
  var anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/utils/map.mjs
  var easingLookup = {
    linear: noop,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
  };
  var easingDefinitionToFunction = (definition) => {
    if (Array.isArray(definition)) {
      invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
      const [x1, y1, x2, y2] = definition;
      return cubicBezier(x1, y1, x2, y2);
    } else if (typeof definition === "string") {
      invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);
      return easingLookup[definition];
    }
    return definition;
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/progress.mjs
  var progress = (from6, to, value) => {
    const toFromDifference = to - from6;
    return toFromDifference === 0 ? 1 : (value - from6) / toFromDifference;
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/mix/number.mjs
  var mixNumber = (from6, to, progress2) => {
    return from6 + (to - from6) * progress2;
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs
  function hueToRgb(p2, q, t2) {
    if (t2 < 0)
      t2 += 1;
    if (t2 > 1)
      t2 -= 1;
    if (t2 < 1 / 6)
      return p2 + (q - p2) * 6 * t2;
    if (t2 < 1 / 2)
      return q;
    if (t2 < 2 / 3)
      return p2 + (q - p2) * (2 / 3 - t2) * 6;
    return p2;
  }
  function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
    hue /= 360;
    saturation /= 100;
    lightness /= 100;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (!saturation) {
      red = green = blue = lightness;
    } else {
      const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
      const p2 = 2 * lightness - q;
      red = hueToRgb(p2, q, hue + 1 / 3);
      green = hueToRgb(p2, q, hue);
      blue = hueToRgb(p2, q, hue - 1 / 3);
    }
    return {
      red: Math.round(red * 255),
      green: Math.round(green * 255),
      blue: Math.round(blue * 255),
      alpha: alpha2
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/mix/immediate.mjs
  function mixImmediate(a2, b2) {
    return (p2) => p2 > 0 ? b2 : a2;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/mix/color.mjs
  var mixLinearColor = (from6, to, v2) => {
    const fromExpo = from6 * from6;
    const expo = v2 * (to * to - fromExpo) + fromExpo;
    return expo < 0 ? 0 : Math.sqrt(expo);
  };
  var colorTypes = [hex, rgba, hsla];
  var getColorType = (v2) => colorTypes.find((type) => type.test(v2));
  function asRGBA(color2) {
    const type = getColorType(color2);
    warning(Boolean(type), `'${color2}' is not an animatable color. Use the equivalent color code instead.`);
    if (!Boolean(type))
      return false;
    let model = type.parse(color2);
    if (type === hsla) {
      model = hslaToRgba(model);
    }
    return model;
  }
  var mixColor = (from6, to) => {
    const fromRGBA = asRGBA(from6);
    const toRGBA = asRGBA(to);
    if (!fromRGBA || !toRGBA) {
      return mixImmediate(from6, to);
    }
    const blended = { ...fromRGBA };
    return (v2) => {
      blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
      blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
      blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
      blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v2);
      return rgba.transform(blended);
    };
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/mix/visibility.mjs
  var invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
  function mixVisibility(origin, target) {
    if (invisibleValues.has(origin)) {
      return (p2) => p2 <= 0 ? origin : target;
    } else {
      return (p2) => p2 >= 1 ? target : origin;
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/mix/complex.mjs
  function mixNumber2(a2, b2) {
    return (p2) => mixNumber(a2, b2, p2);
  }
  function getMixer(a2) {
    if (typeof a2 === "number") {
      return mixNumber2;
    } else if (typeof a2 === "string") {
      return isCSSVariableToken(a2) ? mixImmediate : color.test(a2) ? mixColor : mixComplex;
    } else if (Array.isArray(a2)) {
      return mixArray;
    } else if (typeof a2 === "object") {
      return color.test(a2) ? mixColor : mixObject;
    }
    return mixImmediate;
  }
  function mixArray(a2, b2) {
    const output2 = [...a2];
    const numValues = output2.length;
    const blendValue = a2.map((v2, i2) => getMixer(v2)(v2, b2[i2]));
    return (p2) => {
      for (let i2 = 0; i2 < numValues; i2++) {
        output2[i2] = blendValue[i2](p2);
      }
      return output2;
    };
  }
  function mixObject(a2, b2) {
    const output2 = { ...a2, ...b2 };
    const blendValue = {};
    for (const key in output2) {
      if (a2[key] !== void 0 && b2[key] !== void 0) {
        blendValue[key] = getMixer(a2[key])(a2[key], b2[key]);
      }
    }
    return (v2) => {
      for (const key in blendValue) {
        output2[key] = blendValue[key](v2);
      }
      return output2;
    };
  }
  function matchOrder(origin, target) {
    var _a;
    const orderedOrigin = [];
    const pointers = { color: 0, var: 0, number: 0 };
    for (let i2 = 0; i2 < target.values.length; i2++) {
      const type = target.types[i2];
      const originIndex = origin.indexes[type][pointers[type]];
      const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;
      orderedOrigin[i2] = originValue;
      pointers[type]++;
    }
    return orderedOrigin;
  }
  var mixComplex = (origin, target) => {
    const template = complex.createTransformer(target);
    const originStats = analyseComplexValue(origin);
    const targetStats = analyseComplexValue(target);
    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
    if (canInterpolate) {
      if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
        return mixVisibility(origin, target);
      }
      return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
    } else {
      warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
      return mixImmediate(origin, target);
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/mix/index.mjs
  function mix(from6, to, p2) {
    if (typeof from6 === "number" && typeof to === "number" && typeof p2 === "number") {
      return mixNumber(from6, to, p2);
    }
    const mixer = getMixer(from6);
    return mixer(from6, to);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/interpolate.mjs
  function createMixers(output2, ease2, customMixer) {
    const mixers = [];
    const mixerFactory = customMixer || mix;
    const numMixers = output2.length - 1;
    for (let i2 = 0; i2 < numMixers; i2++) {
      let mixer = mixerFactory(output2[i2], output2[i2 + 1]);
      if (ease2) {
        const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop : ease2;
        mixer = pipe(easingFunction, mixer);
      }
      mixers.push(mixer);
    }
    return mixers;
  }
  function interpolate(input, output2, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
    const inputLength = input.length;
    invariant(inputLength === output2.length, "Both input and output ranges must be the same length");
    if (inputLength === 1)
      return () => output2[0];
    if (inputLength === 2 && input[0] === input[1])
      return () => output2[1];
    if (input[0] > input[inputLength - 1]) {
      input = [...input].reverse();
      output2 = [...output2].reverse();
    }
    const mixers = createMixers(output2, ease2, mixer);
    const numMixers = mixers.length;
    const interpolator = (v2) => {
      let i2 = 0;
      if (numMixers > 1) {
        for (; i2 < input.length - 2; i2++) {
          if (v2 < input[i2 + 1])
            break;
        }
      }
      const progressInRange = progress(input[i2], input[i2 + 1], v2);
      return mixers[i2](progressInRange);
    };
    return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/offsets/fill.mjs
  function fillOffset(offset, remaining) {
    const min = offset[offset.length - 1];
    for (let i2 = 1; i2 <= remaining; i2++) {
      const offsetProgress = progress(0, remaining, i2);
      offset.push(mixNumber(min, 1, offsetProgress));
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/offsets/default.mjs
  function defaultOffset(arr) {
    const offset = [0];
    fillOffset(offset, arr.length - 1);
    return offset;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/offsets/time.mjs
  function convertOffsetToTimes(offset, duration) {
    return offset.map((o2) => o2 * duration);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs
  function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
  }
  function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
    const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
    const state = {
      done: false,
      value: keyframeValues[0]
    };
    const absoluteTimes = convertOffsetToTimes(
      // Only use the provided offsets if they're the correct length
      // TODO Maybe we should warn here if there's a length mismatch
      times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
      duration
    );
    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
    });
    return {
      calculatedDuration: duration,
      next: (t2) => {
        state.value = mapTimeToKeyframe(t2);
        state.done = t2 >= duration;
        return state;
      }
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/generators/utils/calc-duration.mjs
  var maxGeneratorDuration = 2e4;
  function calcGeneratorDuration(generator) {
    let duration = 0;
    const timeStep = 50;
    let state = generator.next(duration);
    while (!state.done && duration < maxGeneratorDuration) {
      duration += timeStep;
      state = generator.next(duration);
    }
    return duration >= maxGeneratorDuration ? Infinity : duration;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs
  var frameloopDriver = (update2) => {
    const passTimestamp = ({ timestamp }) => update2(timestamp);
    return {
      start: () => frame.update(passTimestamp, true),
      stop: () => cancelFrame(passTimestamp),
      /**
       * If we're processing this frame we can use the
       * framelocked timestamp to keep things in sync.
       */
      now: () => frameData.isProcessing ? frameData.timestamp : time.now()
    };
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs
  var generators = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring
  };
  var percentToProgress = (percent2) => percent2 / 100;
  var MainThreadAnimation = class extends BaseAnimation {
    constructor({ KeyframeResolver: KeyframeResolver$1 = KeyframeResolver, ...options }) {
      super(options);
      this.holdTime = null;
      this.startTime = null;
      this.cancelTime = null;
      this.currentTime = 0;
      this.playbackSpeed = 1;
      this.pendingPlayState = "running";
      this.state = "idle";
      this.stop = () => {
        this.resolver.cancel();
        this.isStopped = true;
        if (this.state === "idle")
          return;
        this.teardown();
        const { onStop } = this.options;
        onStop && onStop();
      };
      const { name, motionValue: motionValue2, keyframes: keyframes2 } = this.options;
      const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
      if (name && motionValue2 && motionValue2.owner) {
        this.resolver = motionValue2.owner.resolveKeyframes(keyframes2, onResolved, name, motionValue2);
      } else {
        this.resolver = new KeyframeResolver$1(keyframes2, onResolved, name, motionValue2);
      }
      this.resolver.scheduleResolve();
    }
    initPlayback(keyframes$1) {
      const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options;
      const generatorFactory = generators[type] || keyframes;
      let mapPercentToKeyframes;
      let mirroredGenerator;
      if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
        if (false) {
          invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
        }
        mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
        keyframes$1 = [0, 100];
      }
      const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });
      if (repeatType === "mirror") {
        mirroredGenerator = generatorFactory({
          ...this.options,
          keyframes: [...keyframes$1].reverse(),
          velocity: -velocity
        });
      }
      if (generator.calculatedDuration === null) {
        generator.calculatedDuration = calcGeneratorDuration(generator);
      }
      const { calculatedDuration } = generator;
      const resolvedDuration = calculatedDuration + repeatDelay;
      const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
      return {
        generator,
        mirroredGenerator,
        mapPercentToKeyframes,
        calculatedDuration,
        resolvedDuration,
        totalDuration
      };
    }
    onPostResolved() {
      const { autoplay = true } = this.options;
      this.play();
      if (this.pendingPlayState === "paused" || !autoplay) {
        this.pause();
      } else {
        this.state = this.pendingPlayState;
      }
    }
    tick(timestamp, sample = false) {
      const { resolved } = this;
      if (!resolved) {
        const { keyframes: keyframes3 } = this.options;
        return { done: true, value: keyframes3[keyframes3.length - 1] };
      }
      const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes2, calculatedDuration, totalDuration, resolvedDuration } = resolved;
      if (this.startTime === null)
        return generator.next(0);
      const { delay: delay2, repeat, repeatType, repeatDelay, onUpdate } = this.options;
      if (this.speed > 0) {
        this.startTime = Math.min(this.startTime, timestamp);
      } else if (this.speed < 0) {
        this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
      }
      if (sample) {
        this.currentTime = timestamp;
      } else if (this.holdTime !== null) {
        this.currentTime = this.holdTime;
      } else {
        this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
      }
      const timeWithoutDelay = this.currentTime - delay2 * (this.speed >= 0 ? 1 : -1);
      const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
      this.currentTime = Math.max(timeWithoutDelay, 0);
      if (this.state === "finished" && this.holdTime === null) {
        this.currentTime = totalDuration;
      }
      let elapsed = this.currentTime;
      let frameGenerator = generator;
      if (repeat) {
        const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
        let currentIteration = Math.floor(progress2);
        let iterationProgress = progress2 % 1;
        if (!iterationProgress && progress2 >= 1) {
          iterationProgress = 1;
        }
        iterationProgress === 1 && currentIteration--;
        currentIteration = Math.min(currentIteration, repeat + 1);
        const isOddIteration = Boolean(currentIteration % 2);
        if (isOddIteration) {
          if (repeatType === "reverse") {
            iterationProgress = 1 - iterationProgress;
            if (repeatDelay) {
              iterationProgress -= repeatDelay / resolvedDuration;
            }
          } else if (repeatType === "mirror") {
            frameGenerator = mirroredGenerator;
          }
        }
        elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
      }
      const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
      if (mapPercentToKeyframes) {
        state.value = mapPercentToKeyframes(state.value);
      }
      let { done } = state;
      if (!isInDelayPhase && calculatedDuration !== null) {
        done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
      }
      const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
      if (isAnimationFinished && finalKeyframe !== void 0) {
        state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe);
      }
      if (onUpdate) {
        onUpdate(state.value);
      }
      if (isAnimationFinished) {
        this.finish();
      }
      return state;
    }
    get duration() {
      const { resolved } = this;
      return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;
    }
    get time() {
      return millisecondsToSeconds(this.currentTime);
    }
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime);
      this.currentTime = newTime;
      if (this.holdTime !== null || this.speed === 0) {
        this.holdTime = newTime;
      } else if (this.driver) {
        this.startTime = this.driver.now() - newTime / this.speed;
      }
    }
    get speed() {
      return this.playbackSpeed;
    }
    set speed(newSpeed) {
      const hasChanged = this.playbackSpeed !== newSpeed;
      this.playbackSpeed = newSpeed;
      if (hasChanged) {
        this.time = millisecondsToSeconds(this.currentTime);
      }
    }
    play() {
      if (!this.resolver.isScheduled) {
        this.resolver.resume();
      }
      if (!this._resolved) {
        this.pendingPlayState = "running";
        return;
      }
      if (this.isStopped)
        return;
      const { driver = frameloopDriver, onPlay } = this.options;
      if (!this.driver) {
        this.driver = driver((timestamp) => this.tick(timestamp));
      }
      onPlay && onPlay();
      const now2 = this.driver.now();
      if (this.holdTime !== null) {
        this.startTime = now2 - this.holdTime;
      } else if (!this.startTime || this.state === "finished") {
        this.startTime = now2;
      }
      if (this.state === "finished") {
        this.updateFinishedPromise();
      }
      this.cancelTime = this.startTime;
      this.holdTime = null;
      this.state = "running";
      this.driver.start();
    }
    pause() {
      var _a;
      if (!this._resolved) {
        this.pendingPlayState = "paused";
        return;
      }
      this.state = "paused";
      this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;
    }
    complete() {
      if (this.state !== "running") {
        this.play();
      }
      this.pendingPlayState = this.state = "finished";
      this.holdTime = null;
    }
    finish() {
      this.teardown();
      this.state = "finished";
      const { onComplete } = this.options;
      onComplete && onComplete();
    }
    cancel() {
      if (this.cancelTime !== null) {
        this.tick(this.cancelTime);
      }
      this.teardown();
      this.updateFinishedPromise();
    }
    teardown() {
      this.state = "idle";
      this.stopDriver();
      this.resolveFinishedPromise();
      this.updateFinishedPromise();
      this.startTime = this.cancelTime = null;
      this.resolver.cancel();
    }
    stopDriver() {
      if (!this.driver)
        return;
      this.driver.stop();
      this.driver = void 0;
    }
    sample(time2) {
      this.startTime = 0;
      return this.tick(time2, true);
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/utils/is-bezier-definition.mjs
  var isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/waapi/easing.mjs
  function isWaapiSupportedEasing(easing) {
    return Boolean(!easing || typeof easing === "string" && easing in supportedWaapiEasing || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
  }
  var cubicBezierAsString = ([a2, b2, c2, d2]) => `cubic-bezier(${a2}, ${b2}, ${c2}, ${d2})`;
  var supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
  };
  function mapEasingToNativeEasingWithDefault(easing) {
    return mapEasingToNativeEasing(easing) || supportedWaapiEasing.easeOut;
  }
  function mapEasingToNativeEasing(easing) {
    if (!easing) {
      return void 0;
    } else if (isBezierDefinition(easing)) {
      return cubicBezierAsString(easing);
    } else if (Array.isArray(easing)) {
      return easing.map(mapEasingToNativeEasingWithDefault);
    } else {
      return supportedWaapiEasing[easing];
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs
  function animateStyle(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2, times } = {}) {
    const keyframeOptions = { [valueName]: keyframes2 };
    if (times)
      keyframeOptions.offset = times;
    const easing = mapEasingToNativeEasing(ease2);
    if (Array.isArray(easing))
      keyframeOptions.easing = easing;
    return element.animate(keyframeOptions, {
      delay: delay2,
      duration,
      easing: !Array.isArray(easing) ? easing : "linear",
      fill: "both",
      iterations: repeat + 1,
      direction: repeatType === "reverse" ? "alternate" : "normal"
    });
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs
  var supportsWaapi = memo2(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
  var acceleratedValues = /* @__PURE__ */ new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform"
    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
    // or until we implement support for linear() easing.
    // "background-color"
  ]);
  var sampleDelta = 10;
  var maxDuration2 = 2e4;
  function requiresPregeneratedKeyframes(options) {
    return options.type === "spring" || options.name === "backgroundColor" || !isWaapiSupportedEasing(options.ease);
  }
  function pregenerateKeyframes(keyframes2, options) {
    const sampleAnimation = new MainThreadAnimation({
      ...options,
      keyframes: keyframes2,
      repeat: 0,
      delay: 0,
      isGenerator: true
    });
    let state = { done: false, value: keyframes2[0] };
    const pregeneratedKeyframes = [];
    let t2 = 0;
    while (!state.done && t2 < maxDuration2) {
      state = sampleAnimation.sample(t2);
      pregeneratedKeyframes.push(state.value);
      t2 += sampleDelta;
    }
    return {
      times: void 0,
      keyframes: pregeneratedKeyframes,
      duration: t2 - sampleDelta,
      ease: "linear"
    };
  }
  var AcceleratedAnimation = class extends BaseAnimation {
    constructor(options) {
      super(options);
      const { name, motionValue: motionValue2, keyframes: keyframes2 } = this.options;
      this.resolver = new DOMKeyframesResolver(keyframes2, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue2);
      this.resolver.scheduleResolve();
    }
    initPlayback(keyframes2, finalKeyframe) {
      var _a;
      let { duration = 300, times, ease: ease2, type, motionValue: motionValue2, name } = this.options;
      if (!((_a = motionValue2.owner) === null || _a === void 0 ? void 0 : _a.current)) {
        return false;
      }
      if (requiresPregeneratedKeyframes(this.options)) {
        const { onComplete, onUpdate, motionValue: motionValue3, ...options } = this.options;
        const pregeneratedAnimation = pregenerateKeyframes(keyframes2, options);
        keyframes2 = pregeneratedAnimation.keyframes;
        if (keyframes2.length === 1) {
          keyframes2[1] = keyframes2[0];
        }
        duration = pregeneratedAnimation.duration;
        times = pregeneratedAnimation.times;
        ease2 = pregeneratedAnimation.ease;
        type = "keyframes";
      }
      const animation = animateStyle(motionValue2.owner.current, name, keyframes2, { ...this.options, duration, times, ease: ease2 });
      animation.startTime = time.now();
      if (this.pendingTimeline) {
        animation.timeline = this.pendingTimeline;
        this.pendingTimeline = void 0;
      } else {
        animation.onfinish = () => {
          const { onComplete } = this.options;
          motionValue2.set(getFinalKeyframe(keyframes2, this.options, finalKeyframe));
          onComplete && onComplete();
          this.cancel();
          this.resolveFinishedPromise();
        };
      }
      return {
        animation,
        duration,
        times,
        type,
        ease: ease2,
        keyframes: keyframes2
      };
    }
    get duration() {
      const { resolved } = this;
      if (!resolved)
        return 0;
      const { duration } = resolved;
      return millisecondsToSeconds(duration);
    }
    get time() {
      const { resolved } = this;
      if (!resolved)
        return 0;
      const { animation } = resolved;
      return millisecondsToSeconds(animation.currentTime || 0);
    }
    set time(newTime) {
      const { resolved } = this;
      if (!resolved)
        return;
      const { animation } = resolved;
      animation.currentTime = secondsToMilliseconds(newTime);
    }
    get speed() {
      const { resolved } = this;
      if (!resolved)
        return 1;
      const { animation } = resolved;
      return animation.playbackRate;
    }
    set speed(newSpeed) {
      const { resolved } = this;
      if (!resolved)
        return;
      const { animation } = resolved;
      animation.playbackRate = newSpeed;
    }
    get state() {
      const { resolved } = this;
      if (!resolved)
        return "idle";
      const { animation } = resolved;
      return animation.playState;
    }
    /**
     * Replace the default DocumentTimeline with another AnimationTimeline.
     * Currently used for scroll animations.
     */
    attachTimeline(timeline) {
      if (!this._resolved) {
        this.pendingTimeline = timeline;
      } else {
        const { resolved } = this;
        if (!resolved)
          return noop;
        const { animation } = resolved;
        animation.timeline = timeline;
        animation.onfinish = null;
      }
      return noop;
    }
    play() {
      if (this.isStopped)
        return;
      const { resolved } = this;
      if (!resolved)
        return;
      const { animation } = resolved;
      if (animation.playState === "finished") {
        this.updateFinishedPromise();
      }
      animation.play();
    }
    pause() {
      const { resolved } = this;
      if (!resolved)
        return;
      const { animation } = resolved;
      animation.pause();
    }
    stop() {
      this.resolver.cancel();
      this.isStopped = true;
      if (this.state === "idle")
        return;
      const { resolved } = this;
      if (!resolved)
        return;
      const { animation, keyframes: keyframes2, duration, type, ease: ease2, times } = resolved;
      if (animation.playState === "idle" || animation.playState === "finished") {
        return;
      }
      if (this.time) {
        const { motionValue: motionValue2, onUpdate, onComplete, ...options } = this.options;
        const sampleAnimation = new MainThreadAnimation({
          ...options,
          keyframes: keyframes2,
          duration,
          type,
          ease: ease2,
          times,
          isGenerator: true
        });
        const sampleTime = secondsToMilliseconds(this.time);
        motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
      }
      this.cancel();
    }
    complete() {
      const { resolved } = this;
      if (!resolved)
        return;
      resolved.animation.finish();
    }
    cancel() {
      const { resolved } = this;
      if (!resolved)
        return;
      resolved.animation.cancel();
    }
    static supports(options) {
      const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
      return supportsWaapi() && name && acceleratedValues.has(name) && motionValue2 && motionValue2.owner && motionValue2.owner.current instanceof HTMLElement && /**
       * If we're outputting values to onUpdate then we can't use WAAPI as there's
       * no way to read the value from WAAPI every frame.
       */
      !motionValue2.owner.getProps().onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/observe.mjs
  function observeTimeline(update2, timeline) {
    let prevProgress;
    const onFrame = () => {
      const { currentTime } = timeline;
      const percentage = currentTime === null ? 0 : currentTime.value;
      const progress2 = percentage / 100;
      if (prevProgress !== progress2) {
        update2(progress2);
      }
      prevProgress = progress2;
    };
    frame.update(onFrame, true);
    return () => cancelFrame(onFrame);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/supports.mjs
  var supportsScrollTimeline = memo2(() => window.ScrollTimeline !== void 0);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/GroupPlaybackControls.mjs
  var GroupPlaybackControls = class {
    constructor(animations2) {
      this.stop = () => this.runAll("stop");
      this.animations = animations2.filter(Boolean);
    }
    then(onResolve, onReject) {
      return Promise.all(this.animations).then(onResolve).catch(onReject);
    }
    /**
     * TODO: Filter out cancelled or stopped animations before returning
     */
    getAll(propName) {
      return this.animations[0][propName];
    }
    setAll(propName, newValue) {
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        this.animations[i2][propName] = newValue;
      }
    }
    attachTimeline(timeline) {
      const cancelAll = this.animations.map((animation) => {
        if (supportsScrollTimeline() && animation.attachTimeline) {
          animation.attachTimeline(timeline);
        } else {
          animation.pause();
          return observeTimeline((progress2) => {
            animation.time = animation.duration * progress2;
          }, timeline);
        }
      });
      return () => {
        cancelAll.forEach((cancelTimeline, i2) => {
          if (cancelTimeline)
            cancelTimeline();
          this.animations[i2].stop();
        });
      };
    }
    get time() {
      return this.getAll("time");
    }
    set time(time2) {
      this.setAll("time", time2);
    }
    get speed() {
      return this.getAll("speed");
    }
    set speed(speed) {
      this.setAll("speed", speed);
    }
    get duration() {
      let max = 0;
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        max = Math.max(max, this.animations[i2].duration);
      }
      return max;
    }
    runAll(methodName) {
      this.animations.forEach((controls) => controls[methodName]());
    }
    play() {
      this.runAll("play");
    }
    pause() {
      this.runAll("pause");
    }
    cancel() {
      this.runAll("cancel");
    }
    complete() {
      this.runAll("complete");
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs
  var animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
    const valueTransition = getValueTransition(transition, name) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    let options = {
      keyframes: Array.isArray(target) ? target : [null, target],
      ease: "easeOut",
      velocity: value.getVelocity(),
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v2) => {
        value.set(v2);
        valueTransition.onUpdate && valueTransition.onUpdate(v2);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      },
      name,
      motionValue: value,
      element: isHandoff ? void 0 : element
    };
    if (!isTransitionDefined(valueTransition)) {
      options = {
        ...options,
        ...getDefaultTransition(name, options)
      };
    }
    if (options.duration) {
      options.duration = secondsToMilliseconds(options.duration);
    }
    if (options.repeatDelay) {
      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
    }
    if (options.from !== void 0) {
      options.keyframes[0] = options.from;
    }
    let shouldSkip = false;
    if (options.type === false || options.duration === 0 && !options.repeatDelay) {
      options.duration = 0;
      if (options.delay === 0) {
        shouldSkip = true;
      }
    }
    if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {
      shouldSkip = true;
      options.duration = 0;
      options.delay = 0;
    }
    if (shouldSkip && !isHandoff && value.get() !== void 0) {
      const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
      if (finalKeyframe !== void 0) {
        frame.update(() => {
          options.onUpdate(finalKeyframe);
          options.onComplete();
        });
        return new GroupPlaybackControls([]);
      }
    }
    if (!isHandoff && AcceleratedAnimation.supports(options)) {
      return new AcceleratedAnimation(options);
    } else {
      return new MainThreadAnimation(options);
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-will-change/is.mjs
  function isWillChangeMotionValue(value) {
    return Boolean(isMotionValue(value) && value.add);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/array.mjs
  function addUniqueItem(arr, item) {
    if (arr.indexOf(item) === -1)
      arr.push(item);
  }
  function removeItem(arr, item) {
    const index2 = arr.indexOf(item);
    if (index2 > -1)
      arr.splice(index2, 1);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/subscription-manager.mjs
  var SubscriptionManager = class {
    constructor() {
      this.subscriptions = [];
    }
    add(handler) {
      addUniqueItem(this.subscriptions, handler);
      return () => removeItem(this.subscriptions, handler);
    }
    notify(a2, b2, c2) {
      const numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a2, b2, c2);
      } else {
        for (let i2 = 0; i2 < numSubscriptions; i2++) {
          const handler = this.subscriptions[i2];
          handler && handler(a2, b2, c2);
        }
      }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/index.mjs
  var MAX_VELOCITY_DELTA = 30;
  var isFloat = (value) => {
    return !isNaN(parseFloat(value));
  };
  var collectMotionValues = {
    current: void 0
  };
  var MotionValue = class {
    /**
     * @param init - The initiating value
     * @param config - Optional configuration options
     *
     * -  `transformer`: A function to transform incoming values with.
     *
     * @internal
     */
    constructor(init2, options = {}) {
      this.version = "11.2.14";
      this.canTrackVelocity = null;
      this.events = {};
      this.updateAndNotify = (v2, render = true) => {
        const currentTime = time.now();
        if (this.updatedAt !== currentTime) {
          this.setPrevFrameValue();
        }
        this.prev = this.current;
        this.setCurrent(v2);
        if (this.current !== this.prev && this.events.change) {
          this.events.change.notify(this.current);
        }
        if (render && this.events.renderRequest) {
          this.events.renderRequest.notify(this.current);
        }
      };
      this.hasAnimated = false;
      this.setCurrent(init2);
      this.owner = options.owner;
    }
    setCurrent(current) {
      this.current = current;
      this.updatedAt = time.now();
      if (this.canTrackVelocity === null && current !== void 0) {
        this.canTrackVelocity = isFloat(this.current);
      }
    }
    setPrevFrameValue(prevFrameValue = this.current) {
      this.prevFrameValue = prevFrameValue;
      this.prevUpdatedAt = this.updatedAt;
    }
    /**
     * Adds a function that will be notified when the `MotionValue` is updated.
     *
     * It returns a function that, when called, will cancel the subscription.
     *
     * When calling `onChange` inside a React component, it should be wrapped with the
     * `useEffect` hook. As it returns an unsubscribe function, this should be returned
     * from the `useEffect` function to ensure you don't add duplicate subscribers..
     *
     * ```jsx
     * export const MyComponent = () => {
     *   const x = useMotionValue(0)
     *   const y = useMotionValue(0)
     *   const opacity = useMotionValue(1)
     *
     *   useEffect(() => {
     *     function updateOpacity() {
     *       const maxXY = Math.max(x.get(), y.get())
     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
     *       opacity.set(newOpacity)
     *     }
     *
     *     const unsubscribeX = x.on("change", updateOpacity)
     *     const unsubscribeY = y.on("change", updateOpacity)
     *
     *     return () => {
     *       unsubscribeX()
     *       unsubscribeY()
     *     }
     *   }, [])
     *
     *   return <motion.div style={{ x }} />
     * }
     * ```
     *
     * @param subscriber - A function that receives the latest value.
     * @returns A function that, when called, will cancel this subscription.
     *
     * @deprecated
     */
    onChange(subscription) {
      if (false) {
        warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
      }
      return this.on("change", subscription);
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      const unsubscribe = this.events[eventName].add(callback);
      if (eventName === "change") {
        return () => {
          unsubscribe();
          frame.read(() => {
            if (!this.events.change.getSize()) {
              this.stop();
            }
          });
        };
      }
      return unsubscribe;
    }
    clearListeners() {
      for (const eventManagers in this.events) {
        this.events[eventManagers].clear();
      }
    }
    /**
     * Attaches a passive effect to the `MotionValue`.
     *
     * @internal
     */
    attach(passiveEffect, stopPassiveEffect) {
      this.passiveEffect = passiveEffect;
      this.stopPassiveEffect = stopPassiveEffect;
    }
    /**
     * Sets the state of the `MotionValue`.
     *
     * @remarks
     *
     * ```jsx
     * const x = useMotionValue(0)
     * x.set(10)
     * ```
     *
     * @param latest - Latest value to set.
     * @param render - Whether to notify render subscribers. Defaults to `true`
     *
     * @public
     */
    set(v2, render = true) {
      if (!render || !this.passiveEffect) {
        this.updateAndNotify(v2, render);
      } else {
        this.passiveEffect(v2, this.updateAndNotify);
      }
    }
    setWithVelocity(prev, current, delta) {
      this.set(current);
      this.prev = void 0;
      this.prevFrameValue = prev;
      this.prevUpdatedAt = this.updatedAt - delta;
    }
    /**
     * Set the state of the `MotionValue`, stopping any active animations,
     * effects, and resets velocity to `0`.
     */
    jump(v2, endAnimation = true) {
      this.updateAndNotify(v2);
      this.prev = v2;
      this.prevUpdatedAt = this.prevFrameValue = void 0;
      endAnimation && this.stop();
      if (this.stopPassiveEffect)
        this.stopPassiveEffect();
    }
    /**
     * Returns the latest state of `MotionValue`
     *
     * @returns - The latest state of `MotionValue`
     *
     * @public
     */
    get() {
      if (collectMotionValues.current) {
        collectMotionValues.current.push(this);
      }
      return this.current;
    }
    /**
     * @public
     */
    getPrevious() {
      return this.prev;
    }
    /**
     * Returns the latest velocity of `MotionValue`
     *
     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
     *
     * @public
     */
    getVelocity() {
      const currentTime = time.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
        return 0;
      }
      const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
      return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
    }
    /**
     * Registers a new animation to control this `MotionValue`. Only one
     * animation can drive a `MotionValue` at one time.
     *
     * ```jsx
     * value.start()
     * ```
     *
     * @param animation - A function that starts the provided animation
     *
     * @internal
     */
    start(startAnimation) {
      this.stop();
      return new Promise((resolve) => {
        this.hasAnimated = true;
        this.animation = startAnimation(resolve);
        if (this.events.animationStart) {
          this.events.animationStart.notify();
        }
      }).then(() => {
        if (this.events.animationComplete) {
          this.events.animationComplete.notify();
        }
        this.clearAnimation();
      });
    }
    /**
     * Stop the currently active animation.
     *
     * @public
     */
    stop() {
      if (this.animation) {
        this.animation.stop();
        if (this.events.animationCancel) {
          this.events.animationCancel.notify();
        }
      }
      this.clearAnimation();
    }
    /**
     * Returns `true` if this value is currently animating.
     *
     * @public
     */
    isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
    /**
     * Destroy and clean up subscribers to this `MotionValue`.
     *
     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
     * created a `MotionValue` via the `motionValue` function.
     *
     * @public
     */
    destroy() {
      this.clearListeners();
      this.stop();
      if (this.stopPassiveEffect) {
        this.stopPassiveEffect();
      }
    }
  };
  function motionValue(init2, options) {
    return new MotionValue(init2, options);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/setters.mjs
  function setMotionValue(visualElement, key, value) {
    if (visualElement.hasValue(key)) {
      visualElement.getValue(key).set(value);
    } else {
      visualElement.addValue(key, motionValue(value));
    }
  }
  function setTarget(visualElement, definition) {
    const resolved = resolveVariant(visualElement, definition);
    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
    target = { ...target, ...transitionEnd };
    for (const key in target) {
      const value = resolveFinalValueInKeyframes(target[key]);
      setMotionValue(visualElement, key, value);
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs
  function getOptimisedAppearId(visualElement) {
    return visualElement.getProps()[optimizedAppearDataAttribute];
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs
  function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
    needsAnimating[key] = false;
    return shouldBlock;
  }
  function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
    var _a;
    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
    const willChange = visualElement.getValue("willChange");
    if (transitionOverride)
      transition = transitionOverride;
    const animations2 = [];
    const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
    for (const key in target) {
      const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);
      const valueTarget = target[key];
      if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
        continue;
      }
      const valueTransition = {
        delay: delay2,
        elapsed: 0,
        ...getValueTransition(transition || {}, key)
      };
      let isHandoff = false;
      if (window.HandoffAppearAnimations) {
        const appearId = getOptimisedAppearId(visualElement);
        if (appearId) {
          const elapsed = window.HandoffAppearAnimations(appearId, key, value, frame);
          if (elapsed !== null) {
            valueTransition.elapsed = elapsed;
            isHandoff = true;
          }
        }
      }
      value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
      const animation = value.animation;
      if (animation) {
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key);
          animation.then(() => willChange.remove(key));
        }
        animations2.push(animation);
      }
    }
    if (transitionEnd) {
      Promise.all(animations2).then(() => {
        frame.update(() => {
          transitionEnd && setTarget(visualElement, transitionEnd);
        });
      });
    }
    return animations2;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs
  function animateVariant(visualElement, variant, options = {}) {
    var _a;
    const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : void 0);
    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
    if (options.transitionOverride) {
      transition = options.transitionOverride;
    }
    const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
      const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
      return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
    } : () => Promise.resolve();
    const { when } = transition;
    if (when) {
      const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
      return first().then(() => last());
    } else {
      return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
    }
  }
  function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
    const animations2 = [];
    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
    const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;
    Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
      child.notify("AnimationStart", variant);
      animations2.push(animateVariant(child, variant, {
        ...options,
        delay: delayChildren + generateStaggerDuration(i2)
      }).then(() => child.notify("AnimationComplete", variant)));
    });
    return Promise.all(animations2);
  }
  function sortByTreeOrder(a2, b2) {
    return a2.sortNodePosition(b2);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs
  function animateVisualElement(visualElement, definition, options = {}) {
    visualElement.notify("AnimationStart", definition);
    let animation;
    if (Array.isArray(definition)) {
      const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
      animation = Promise.all(animations2);
    } else if (typeof definition === "string") {
      animation = animateVariant(visualElement, definition, options);
    } else {
      const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
      animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
    }
    return animation.then(() => {
      frame.postRender(() => {
        visualElement.notify("AnimationComplete", definition);
      });
    });
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
  var reversePriorityOrder = [...variantPriorityOrder].reverse();
  var numAnimationTypes = variantPriorityOrder.length;
  function animateList(visualElement) {
    return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
  }
  function createAnimationState(visualElement) {
    let animate = animateList(visualElement);
    let state = createState();
    let isInitialRender = true;
    const buildResolvedTypeValues = (type) => (acc, definition) => {
      var _a;
      const resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : void 0);
      if (resolved) {
        const { transition, transitionEnd, ...target } = resolved;
        acc = { ...acc, ...target, ...transitionEnd };
      }
      return acc;
    };
    function setAnimateFunction(makeAnimator) {
      animate = makeAnimator(visualElement);
    }
    function animateChanges(changedActiveType) {
      const props = visualElement.getProps();
      const context = visualElement.getVariantContext(true) || {};
      const animations2 = [];
      const removedKeys = /* @__PURE__ */ new Set();
      let encounteredKeys = {};
      let removedVariantIndex = Infinity;
      for (let i2 = 0; i2 < numAnimationTypes; i2++) {
        const type = reversePriorityOrder[i2];
        const typeState = state[type];
        const prop = props[type] !== void 0 ? props[type] : context[type];
        const propIsVariant = isVariantLabel(prop);
        const activeDelta = type === changedActiveType ? typeState.isActive : null;
        if (activeDelta === false)
          removedVariantIndex = i2;
        let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
        if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
          isInherited = false;
        }
        typeState.protectedKeys = { ...encounteredKeys };
        if (
          // If it isn't active and hasn't *just* been set as inactive
          !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
          !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
          isAnimationControls(prop) || typeof prop === "boolean"
        ) {
          continue;
        }
        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
        let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
        type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
        i2 > removedVariantIndex && propIsVariant;
        let handledRemovedValues = false;
        const definitionList = Array.isArray(prop) ? prop : [prop];
        let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
        if (activeDelta === false)
          resolvedValues = {};
        const { prevResolvedValues = {} } = typeState;
        const allKeys = {
          ...prevResolvedValues,
          ...resolvedValues
        };
        const markToAnimate = (key) => {
          shouldAnimateType = true;
          if (removedKeys.has(key)) {
            handledRemovedValues = true;
            removedKeys.delete(key);
          }
          typeState.needsAnimating[key] = true;
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = false;
        };
        for (const key in allKeys) {
          const next = resolvedValues[key];
          const prev = prevResolvedValues[key];
          if (encounteredKeys.hasOwnProperty(key))
            continue;
          let valueHasChanged = false;
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            valueHasChanged = !shallowCompare(next, prev);
          } else {
            valueHasChanged = next !== prev;
          }
          if (valueHasChanged) {
            if (next !== void 0 && next !== null) {
              markToAnimate(key);
            } else {
              removedKeys.add(key);
            }
          } else if (next !== void 0 && removedKeys.has(key)) {
            markToAnimate(key);
          } else {
            typeState.protectedKeys[key] = true;
          }
        }
        typeState.prevProp = prop;
        typeState.prevResolvedValues = resolvedValues;
        if (typeState.isActive) {
          encounteredKeys = { ...encounteredKeys, ...resolvedValues };
        }
        if (isInitialRender && visualElement.blockInitialAnimation) {
          shouldAnimateType = false;
        }
        if (shouldAnimateType && (!isInherited || handledRemovedValues)) {
          animations2.push(...definitionList.map((animation) => ({
            animation,
            options: { type }
          })));
        }
      }
      if (removedKeys.size) {
        const fallbackAnimation = {};
        removedKeys.forEach((key) => {
          const fallbackTarget = visualElement.getBaseTarget(key);
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = true;
          fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;
        });
        animations2.push({ animation: fallbackAnimation });
      }
      let shouldAnimate = Boolean(animations2.length);
      if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
        shouldAnimate = false;
      }
      isInitialRender = false;
      return shouldAnimate ? animate(animations2) : Promise.resolve();
    }
    function setActive(type, isActive) {
      var _a;
      if (state[type].isActive === isActive)
        return Promise.resolve();
      (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
        var _a2;
        return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
      });
      state[type].isActive = isActive;
      const animations2 = animateChanges(type);
      for (const key in state) {
        state[key].protectedKeys = {};
      }
      return animations2;
    }
    return {
      animateChanges,
      setActive,
      setAnimateFunction,
      getState: () => state,
      reset: () => {
        state = createState();
        isInitialRender = true;
      }
    };
  }
  function checkVariantsDidChange(prev, next) {
    if (typeof next === "string") {
      return next !== prev;
    } else if (Array.isArray(next)) {
      return !shallowCompare(next, prev);
    }
    return false;
  }
  function createTypeState(isActive = false) {
    return {
      isActive,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function createState() {
    return {
      animate: createTypeState(true),
      whileInView: createTypeState(),
      whileHover: createTypeState(),
      whileTap: createTypeState(),
      whileDrag: createTypeState(),
      whileFocus: createTypeState(),
      exit: createTypeState()
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/animation/index.mjs
  var AnimationFeature = class extends Feature {
    /**
     * We dynamically generate the AnimationState manager as it contains a reference
     * to the underlying animation library. We only want to load that if we load this,
     * so people can optionally code split it out using the `m` component.
     */
    constructor(node) {
      super(node);
      node.animationState || (node.animationState = createAnimationState(node));
    }
    updateAnimationControlsSubscription() {
      const { animate } = this.node.getProps();
      if (isAnimationControls(animate)) {
        this.unmountControls = animate.subscribe(this.node);
      }
    }
    /**
     * Subscribe any provided AnimationControls to the component's VisualElement
     */
    mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const { animate } = this.node.getProps();
      const { animate: prevAnimate } = this.node.prevProps || {};
      if (animate !== prevAnimate) {
        this.updateAnimationControlsSubscription();
      }
    }
    unmount() {
      var _a;
      this.node.animationState.reset();
      (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs
  var id = 0;
  var ExitAnimationFeature = class extends Feature {
    constructor() {
      super(...arguments);
      this.id = id++;
    }
    update() {
      if (!this.node.presenceContext)
        return;
      const { isPresent, onExitComplete } = this.node.presenceContext;
      const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || isPresent === prevIsPresent) {
        return;
      }
      const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
      if (onExitComplete && !isPresent) {
        exitAnimation.then(() => onExitComplete(this.id));
      }
    }
    mount() {
      const { register } = this.node.presenceContext || {};
      if (register) {
        this.unmount = register(this.id);
      }
    }
    unmount() {
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/animations.mjs
  var animations = {
    animation: {
      Feature: AnimationFeature
    },
    exit: {
      Feature: ExitAnimationFeature
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/distance.mjs
  var distance = (a2, b2) => Math.abs(a2 - b2);
  function distance2D(a2, b2) {
    const xDelta = distance(a2.x, b2.x);
    const yDelta = distance(a2.y, b2.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs
  var PanSession = class {
    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.contextWindow = window;
      this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
        const isPanStarted = this.startEvent !== null;
        const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        const { point: point2 } = info2;
        const { timestamp: timestamp2 } = frameData;
        this.history.push({ ...point2, timestamp: timestamp2 });
        const { onStart, onMove } = this.handlers;
        if (!isPanStarted) {
          onStart && onStart(this.lastMoveEvent, info2);
          this.startEvent = this.lastMoveEvent;
        }
        onMove && onMove(this.lastMoveEvent, info2);
      };
      this.handlePointerMove = (event2, info2) => {
        this.lastMoveEvent = event2;
        this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
        frame.update(this.updatePoint, true);
      };
      this.handlePointerUp = (event2, info2) => {
        this.end();
        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
        if (this.dragSnapToOrigin)
          resumeAnimation && resumeAnimation();
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
        if (this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (!isPrimaryPointer(event))
        return;
      this.dragSnapToOrigin = dragSnapToOrigin;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      this.contextWindow = contextWindow || window;
      const info = extractEventInfo(event);
      const initialInfo = transformPoint(info, this.transformPagePoint);
      const { point } = initialInfo;
      const { timestamp } = frameData;
      this.history = [{ ...point, timestamp }];
      const { onSessionStart } = handlers;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
    }
    updateHandlers(handlers) {
      this.handlers = handlers;
    }
    end() {
      this.removeListeners && this.removeListeners();
      cancelFrame(this.updatePoint);
    }
  };
  function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
  }
  function subtractPoint(a2, b2) {
    return { x: a2.x - b2.x, y: a2.y - b2.y };
  }
  function getPanInfo({ point }, history) {
    return {
      point,
      delta: subtractPoint(point, lastDevicePoint(history)),
      offset: subtractPoint(point, startDevicePoint(history)),
      velocity: getVelocity(history, 0.1)
    };
  }
  function startDevicePoint(history) {
    return history[0];
  }
  function lastDevicePoint(history) {
    return history[history.length - 1];
  }
  function getVelocity(history, timeDelta) {
    if (history.length < 2) {
      return { x: 0, y: 0 };
    }
    let i2 = history.length - 1;
    let timestampedPoint = null;
    const lastPoint = lastDevicePoint(history);
    while (i2 >= 0) {
      timestampedPoint = history[i2];
      if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
        break;
      }
      i2--;
    }
    if (!timestampedPoint) {
      return { x: 0, y: 0 };
    }
    const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
    if (time2 === 0) {
      return { x: 0, y: 0 };
    }
    const currentVelocity = {
      x: (lastPoint.x - timestampedPoint.x) / time2,
      y: (lastPoint.y - timestampedPoint.y) / time2
    };
    if (currentVelocity.x === Infinity) {
      currentVelocity.x = 0;
    }
    if (currentVelocity.y === Infinity) {
      currentVelocity.y = 0;
    }
    return currentVelocity;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
  function calcLength(axis) {
    return axis.max - axis.min;
  }
  function isNear(value, target = 0, maxDistance = 0.01) {
    return Math.abs(value - target) <= maxDistance;
  }
  function calcAxisDelta(delta, source, target, origin = 0.5) {
    delta.origin = origin;
    delta.originPoint = mixNumber(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
      delta.scale = 1;
    delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
    if (isNear(delta.translate) || isNaN(delta.translate))
      delta.translate = 0;
  }
  function calcBoxDelta(delta, source, target, origin) {
    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
  }
  function calcRelativeAxis(target, relative, parent) {
    target.min = parent.min + relative.min;
    target.max = target.min + calcLength(relative);
  }
  function calcRelativeBox(target, relative, parent) {
    calcRelativeAxis(target.x, relative.x, parent.x);
    calcRelativeAxis(target.y, relative.y, parent.y);
  }
  function calcRelativeAxisPosition(target, layout2, parent) {
    target.min = layout2.min - parent.min;
    target.max = target.min + calcLength(layout2);
  }
  function calcRelativePosition(target, layout2, parent) {
    calcRelativeAxisPosition(target.x, layout2.x, parent.x);
    calcRelativeAxisPosition(target.y, layout2.y, parent.y);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
  function applyConstraints(point, { min, max }, elastic) {
    if (min !== void 0 && point < min) {
      point = elastic ? mixNumber(min, point, elastic.min) : Math.max(point, min);
    } else if (max !== void 0 && point > max) {
      point = elastic ? mixNumber(max, point, elastic.max) : Math.min(point, max);
    }
    return point;
  }
  function calcRelativeAxisConstraints(axis, min, max) {
    return {
      min: min !== void 0 ? axis.min + min : void 0,
      max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
    };
  }
  function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
    return {
      x: calcRelativeAxisConstraints(layoutBox.x, left, right),
      y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
    };
  }
  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    let min = constraintsAxis.min - layoutAxis.min;
    let max = constraintsAxis.max - layoutAxis.max;
    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
      [min, max] = [max, min];
    }
    return { min, max };
  }
  function calcViewportConstraints(layoutBox, constraintsBox) {
    return {
      x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
      y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
    };
  }
  function calcOrigin2(source, target) {
    let origin = 0.5;
    const sourceLength = calcLength(source);
    const targetLength = calcLength(target);
    if (targetLength > sourceLength) {
      origin = progress(target.min, target.max - sourceLength, source.min);
    } else if (sourceLength > targetLength) {
      origin = progress(source.min, source.max - targetLength, target.min);
    }
    return clamp(0, 1, origin);
  }
  function rebaseAxisConstraints(layout2, constraints) {
    const relativeConstraints = {};
    if (constraints.min !== void 0) {
      relativeConstraints.min = constraints.min - layout2.min;
    }
    if (constraints.max !== void 0) {
      relativeConstraints.max = constraints.max - layout2.min;
    }
    return relativeConstraints;
  }
  var defaultElastic = 0.35;
  function resolveDragElastic(dragElastic = defaultElastic) {
    if (dragElastic === false) {
      dragElastic = 0;
    } else if (dragElastic === true) {
      dragElastic = defaultElastic;
    }
    return {
      x: resolveAxisElastic(dragElastic, "left", "right"),
      y: resolveAxisElastic(dragElastic, "top", "bottom")
    };
  }
  function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
    return {
      min: resolvePointElastic(dragElastic, minLabel),
      max: resolvePointElastic(dragElastic, maxLabel)
    };
  }
  function resolvePointElastic(dragElastic, label) {
    return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/models.mjs
  var createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  });
  var createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta()
  });
  var createAxis = () => ({ min: 0, max: 0 });
  var createBox = () => ({
    x: createAxis(),
    y: createAxis()
  });

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
  function eachAxis(callback) {
    return [callback("x"), callback("y")];
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
  function convertBoundingBoxToBox({ top, left, right, bottom }) {
    return {
      x: { min: left, max: right },
      y: { min: top, max: bottom }
    };
  }
  function convertBoxToBoundingBox({ x: x2, y: y2 }) {
    return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
  }
  function transformBoxPoints(point, transformPoint2) {
    if (!transformPoint2)
      return point;
    const topLeft = transformPoint2({ x: point.left, y: point.top });
    const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
    return {
      top: topLeft.y,
      left: topLeft.x,
      bottom: bottomRight.y,
      right: bottomRight.x
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
  function isIdentityScale(scale2) {
    return scale2 === void 0 || scale2 === 1;
  }
  function hasScale({ scale: scale2, scaleX, scaleY }) {
    return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
  }
  function hasTransform(values) {
    return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
  }
  function has2DTranslate(values) {
    return is2DTranslate(values.x) || is2DTranslate(values.y);
  }
  function is2DTranslate(value) {
    return value && value !== "0%";
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
  function scalePoint(point, scale2, originPoint) {
    const distanceFromOrigin = point - originPoint;
    const scaled = scale2 * distanceFromOrigin;
    return originPoint + scaled;
  }
  function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
    if (boxScale !== void 0) {
      point = scalePoint(point, boxScale, originPoint);
    }
    return scalePoint(point, scale2, originPoint) + translate;
  }
  function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
    axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function applyBoxDelta(box, { x: x2, y: y2 }) {
    applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
    applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
  }
  function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
    const treeLength = treePath.length;
    if (!treeLength)
      return;
    treeScale.x = treeScale.y = 1;
    let node;
    let delta;
    for (let i2 = 0; i2 < treeLength; i2++) {
      node = treePath[i2];
      delta = node.projectionDelta;
      const instance = node.instance;
      if (instance && instance.style && instance.style.display === "contents") {
        continue;
      }
      if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
        transformBox(box, {
          x: -node.scroll.offset.x,
          y: -node.scroll.offset.y
        });
      }
      if (delta) {
        treeScale.x *= delta.x.scale;
        treeScale.y *= delta.y.scale;
        applyBoxDelta(box, delta);
      }
      if (isSharedTransition && hasTransform(node.latestValues)) {
        transformBox(box, node.latestValues);
      }
    }
    treeScale.x = snapToDefault(treeScale.x);
    treeScale.y = snapToDefault(treeScale.y);
  }
  function snapToDefault(scale2) {
    if (Number.isInteger(scale2))
      return scale2;
    return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
  }
  function translateAxis(axis, distance2) {
    axis.min = axis.min + distance2;
    axis.max = axis.max + distance2;
  }
  function transformAxis(axis, transforms, [key, scaleKey, originKey]) {
    const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);
    applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
  }
  var xKeys = ["x", "scaleX", "originX"];
  var yKeys = ["y", "scaleY", "originY"];
  function transformBox(box, transform) {
    transformAxis(box.x, transform, xKeys);
    transformAxis(box.y, transform, yKeys);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/utils/measure.mjs
  function measureViewportBox(instance, transformPoint2) {
    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
  }
  function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
    const viewportBox = measureViewportBox(element, transformPagePoint);
    const { scroll } = rootProjectionNode2;
    if (scroll) {
      translateAxis(viewportBox.x, scroll.offset.x);
      translateAxis(viewportBox.y, scroll.offset.y);
    }
    return viewportBox;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/get-context-window.mjs
  var getContextWindow = ({ current }) => {
    return current ? current.ownerDocument.defaultView : null;
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
  var elementDragControls = /* @__PURE__ */ new WeakMap();
  var VisualElementDragControls = class {
    constructor(visualElement) {
      this.openGlobalLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.visualElement = visualElement;
    }
    start(originEvent, { snapToCursor = false } = {}) {
      const { presenceContext } = this.visualElement;
      if (presenceContext && presenceContext.isPresent === false)
        return;
      const onSessionStart = (event) => {
        const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
        dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
        if (snapToCursor) {
          this.snapToCursor(extractEventInfo(event, "page").point);
        }
      };
      const onStart = (event, info) => {
        const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
        if (drag2 && !dragPropagation) {
          if (this.openGlobalLock)
            this.openGlobalLock();
          this.openGlobalLock = getGlobalLock(drag2);
          if (!this.openGlobalLock)
            return;
        }
        this.isDragging = true;
        this.currentDirection = null;
        this.resolveConstraints();
        if (this.visualElement.projection) {
          this.visualElement.projection.isAnimationBlocked = true;
          this.visualElement.projection.target = void 0;
        }
        eachAxis((axis) => {
          let current = this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            const { projection } = this.visualElement;
            if (projection && projection.layout) {
              const measuredAxis = projection.layout.layoutBox[axis];
              if (measuredAxis) {
                const length = calcLength(measuredAxis);
                current = length * (parseFloat(current) / 100);
              }
            }
          }
          this.originPoint[axis] = current;
        });
        if (onDragStart) {
          frame.postRender(() => onDragStart(event, info));
        }
        const { animationState } = this.visualElement;
        animationState && animationState.setActive("whileDrag", true);
      };
      const onMove = (event, info) => {
        const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
        if (!dragPropagation && !this.openGlobalLock)
          return;
        const { offset } = info;
        if (dragDirectionLock && this.currentDirection === null) {
          this.currentDirection = getCurrentDirection(offset);
          if (this.currentDirection !== null) {
            onDirectionLock && onDirectionLock(this.currentDirection);
          }
          return;
        }
        this.updateAxis("x", info.point, offset);
        this.updateAxis("y", info.point, offset);
        this.visualElement.render();
        onDrag && onDrag(event, info);
      };
      const onSessionEnd = (event, info) => this.stop(event, info);
      const resumeAnimation = () => eachAxis((axis) => {
        var _a;
        return this.getAnimationState(axis) === "paused" && ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());
      });
      const { dragSnapToOrigin } = this.getProps();
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd,
        resumeAnimation
      }, {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin,
        contextWindow: getContextWindow(this.visualElement)
      });
    }
    stop(event, info) {
      const isDragging = this.isDragging;
      this.cancel();
      if (!isDragging)
        return;
      const { velocity } = info;
      this.startAnimation(velocity);
      const { onDragEnd } = this.getProps();
      if (onDragEnd) {
        frame.postRender(() => onDragEnd(event, info));
      }
    }
    cancel() {
      this.isDragging = false;
      const { projection, animationState } = this.visualElement;
      if (projection) {
        projection.isAnimationBlocked = false;
      }
      this.panSession && this.panSession.end();
      this.panSession = void 0;
      const { dragPropagation } = this.getProps();
      if (!dragPropagation && this.openGlobalLock) {
        this.openGlobalLock();
        this.openGlobalLock = null;
      }
      animationState && animationState.setActive("whileDrag", false);
    }
    updateAxis(axis, _point, offset) {
      const { drag: drag2 } = this.getProps();
      if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      let next = this.originPoint[axis] + offset[axis];
      if (this.constraints && this.constraints[axis]) {
        next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next);
    }
    resolveConstraints() {
      var _a;
      const { dragConstraints, dragElastic } = this.getProps();
      const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;
      const prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout2) {
          this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
        eachAxis((axis) => {
          if (this.constraints !== false && this.getAxisMotionValue(axis)) {
            this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
          }
        });
      }
    }
    resolveRefConstraints() {
      const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
      if (!constraints || !isRefObject(constraints))
        return false;
      const constraintsElement = constraints.current;
      invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
      const { projection } = this.visualElement;
      if (!projection || !projection.layout)
        return false;
      const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
      if (onMeasureDragConstraints) {
        const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    }
    startAnimation(velocity) {
      const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
      const constraints = this.constraints || {};
      const momentumAnimations = eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, this.currentDirection)) {
          return;
        }
        let transition = constraints && constraints[axis] || {};
        if (dragSnapToOrigin)
          transition = { min: 0, max: 0 };
        const bounceStiffness = dragElastic ? 200 : 1e6;
        const bounceDamping = dragElastic ? 40 : 1e7;
        const inertia2 = {
          type: "inertia",
          velocity: dragMomentum ? velocity[axis] : 0,
          bounceStiffness,
          bounceDamping,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10,
          ...dragTransition,
          ...transition
        };
        return this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    }
    startAxisValueAnimation(axis, transition) {
      const axisValue = this.getAxisMotionValue(axis);
      return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement));
    }
    stopAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).stop());
    }
    pauseAnimation() {
      eachAxis((axis) => {
        var _a;
        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause();
      });
    }
    getAnimationState(axis) {
      var _a;
      return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;
    }
    /**
     * Drag works differently depending on which props are provided.
     *
     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
     * - Otherwise, we apply the delta to the x/y motion values.
     */
    getAxisMotionValue(axis) {
      const dragKey = `_drag${axis.toUpperCase()}`;
      const props = this.visualElement.getProps();
      const externalMotionValue = props[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
    }
    snapToCursor(point) {
      eachAxis((axis) => {
        const { drag: drag2 } = this.getProps();
        if (!shouldDrag(axis, drag2, this.currentDirection))
          return;
        const { projection } = this.visualElement;
        const axisValue = this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          const { min, max } = projection.layout.layoutBox[axis];
          axisValue.set(point[axis] - mixNumber(min, max, 0.5));
        }
      });
    }
    /**
     * When the viewport resizes we want to check if the measured constraints
     * have changed and, if so, reposition the element within those new constraints
     * relative to where it was before the resize.
     */
    scalePositionWithinConstraints() {
      if (!this.visualElement.current)
        return;
      const { drag: drag2, dragConstraints } = this.getProps();
      const { projection } = this.visualElement;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints)
        return;
      this.stopAnimation();
      const boxProgress = { x: 0, y: 0 };
      eachAxis((axis) => {
        const axisValue = this.getAxisMotionValue(axis);
        if (axisValue && this.constraints !== false) {
          const latest = axisValue.get();
          boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);
        }
      });
      const { transformTemplate } = this.visualElement.getProps();
      this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, null))
          return;
        const axisValue = this.getAxisMotionValue(axis);
        const { min, max } = this.constraints[axis];
        axisValue.set(mixNumber(min, max, boxProgress[axis]));
      });
    }
    addListeners() {
      if (!this.visualElement.current)
        return;
      elementDragControls.set(this.visualElement, this);
      const element = this.visualElement.current;
      const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
        const { drag: drag2, dragListener = true } = this.getProps();
        drag2 && dragListener && this.start(event);
      });
      const measureDragConstraints = () => {
        const { dragConstraints } = this.getProps();
        if (isRefObject(dragConstraints) && dragConstraints.current) {
          this.constraints = this.resolveRefConstraints();
        }
      };
      const { projection } = this.visualElement;
      const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
      }
      frame.read(measureDragConstraints);
      const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
      const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
        if (this.isDragging && hasLayoutChanged) {
          eachAxis((axis) => {
            const motionValue2 = this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          this.visualElement.render();
        }
      });
      return () => {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
        stopLayoutUpdateListener && stopLayoutUpdateListener();
      };
    }
    getProps() {
      const props = this.visualElement.getProps();
      const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
      return {
        ...props,
        drag: drag2,
        dragDirectionLock,
        dragPropagation,
        dragConstraints,
        dragElastic,
        dragMomentum
      };
    }
  };
  function shouldDrag(direction, drag2, currentDirection) {
    return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
  }
  function getCurrentDirection(offset, lockThreshold = 10) {
    let direction = null;
    if (Math.abs(offset.y) > lockThreshold) {
      direction = "y";
    } else if (Math.abs(offset.x) > lockThreshold) {
      direction = "x";
    }
    return direction;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/drag/index.mjs
  var DragGesture = class extends Feature {
    constructor(node) {
      super(node);
      this.removeGroupControls = noop;
      this.removeListeners = noop;
      this.controls = new VisualElementDragControls(node);
    }
    mount() {
      const { dragControls } = this.node.getProps();
      if (dragControls) {
        this.removeGroupControls = dragControls.subscribe(this.controls);
      }
      this.removeListeners = this.controls.addListeners() || noop;
    }
    unmount() {
      this.removeGroupControls();
      this.removeListeners();
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/pan/index.mjs
  var asyncHandler = (handler) => (event, info) => {
    if (handler) {
      frame.postRender(() => handler(event, info));
    }
  };
  var PanGesture = class extends Feature {
    constructor() {
      super(...arguments);
      this.removePointerDownListener = noop;
    }
    onPointerDown(pointerDownEvent) {
      this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
        transformPagePoint: this.node.getTransformPagePoint(),
        contextWindow: getContextWindow(this.node)
      });
    }
    createPanHandlers() {
      const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
      return {
        onSessionStart: asyncHandler(onPanSessionStart),
        onStart: asyncHandler(onPanStart),
        onMove: onPan,
        onEnd: (event, info) => {
          delete this.session;
          if (onPanEnd) {
            frame.postRender(() => onPanEnd(event, info));
          }
        }
      };
    }
    mount() {
      this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener();
      this.session && this.session.end();
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
  var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
  var import_react23 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
  var import_react22 = __toESM(require_react(), 1);
  function usePresence2() {
    const context = (0, import_react22.useContext)(PresenceContext);
    if (context === null)
      return [true, null];
    const { isPresent, onExitComplete, register } = context;
    const id3 = (0, import_react22.useId)();
    (0, import_react22.useEffect)(() => register(id3), []);
    const safeToRemove = () => onExitComplete && onExitComplete(id3);
    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/node/state.mjs
  var globalProjectionState = {
    /**
     * Global flag as to whether the tree has animated since the last time
     * we resized the window
     */
    hasAnimatedSinceResize: true,
    /**
     * We set this to true once, on the first update. Any nodes added to the tree beyond that
     * update will be given a `data-projection-id` attribute.
     */
    hasEverUpdated: false
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
  function pixelsToPercent(pixels, axis) {
    if (axis.max === axis.min)
      return 0;
    return pixels / (axis.max - axis.min) * 100;
  }
  var correctBorderRadius = {
    correct: (latest, node) => {
      if (!node.target)
        return latest;
      if (typeof latest === "string") {
        if (px.test(latest)) {
          latest = parseFloat(latest);
        } else {
          return latest;
        }
      }
      const x2 = pixelsToPercent(latest, node.target.x);
      const y2 = pixelsToPercent(latest, node.target.y);
      return `${x2}% ${y2}%`;
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
  var correctBoxShadow = {
    correct: (latest, { treeScale, projectionDelta }) => {
      const original = latest;
      const shadow = complex.parse(latest);
      if (shadow.length > 5)
        return original;
      const template = complex.createTransformer(latest);
      const offset = typeof shadow[0] !== "number" ? 1 : 0;
      const xScale = projectionDelta.x.scale * treeScale.x;
      const yScale = projectionDelta.y.scale * treeScale.y;
      shadow[0 + offset] /= xScale;
      shadow[1 + offset] /= yScale;
      const averageScale = mixNumber(xScale, yScale, 0.5);
      if (typeof shadow[2 + offset] === "number")
        shadow[2 + offset] /= averageScale;
      if (typeof shadow[3 + offset] === "number")
        shadow[3 + offset] /= averageScale;
      return template(shadow);
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
  var MeasureLayoutWithContext = class extends import_react23.Component {
    /**
     * This only mounts projection nodes for components that
     * need measuring, we might want to do it for all components
     * in order to incorporate transforms
     */
    componentDidMount() {
      const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
      const { projection } = visualElement;
      addScaleCorrector(defaultScaleCorrectors);
      if (projection) {
        if (layoutGroup.group)
          layoutGroup.group.add(projection);
        if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
          switchLayoutGroup.register(projection);
        }
        projection.root.didUpdate();
        projection.addEventListener("animationComplete", () => {
          this.safeToRemove();
        });
        projection.setOptions({
          ...projection.options,
          onExitComplete: () => this.safeToRemove()
        });
      }
      globalProjectionState.hasEverUpdated = true;
    }
    getSnapshotBeforeUpdate(prevProps) {
      const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
      const projection = visualElement.projection;
      if (!projection)
        return null;
      projection.isPresent = isPresent;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent) {
        if (isPresent) {
          projection.promote();
        } else if (!projection.relegate()) {
          frame.postRender(() => {
            const stack = projection.getStack();
            if (!stack || !stack.members.length) {
              this.safeToRemove();
            }
          });
        }
      }
      return null;
    }
    componentDidUpdate() {
      const { projection } = this.props.visualElement;
      if (projection) {
        projection.root.didUpdate();
        microtask.postRender(() => {
          if (!projection.currentAnimation && projection.isLead()) {
            this.safeToRemove();
          }
        });
      }
    }
    componentWillUnmount() {
      const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
      const { projection } = visualElement;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup && layoutGroup.group)
          layoutGroup.group.remove(projection);
        if (promoteContext && promoteContext.deregister)
          promoteContext.deregister(projection);
      }
    }
    safeToRemove() {
      const { safeToRemove } = this.props;
      safeToRemove && safeToRemove();
    }
    render() {
      return null;
    }
  };
  function MeasureLayout(props) {
    const [isPresent, safeToRemove] = usePresence2();
    const layoutGroup = (0, import_react23.useContext)(LayoutGroupContext);
    return (0, import_jsx_runtime11.jsx)(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: (0, import_react23.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove });
  }
  var defaultScaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
  var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
  var numBorders = borders.length;
  var asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
  var isPx = (value) => typeof value === "number" || px.test(value);
  function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
    if (shouldCrossfadeOpacity) {
      target.opacity = mixNumber(
        0,
        // TODO Reinstate this if only child
        lead.opacity !== void 0 ? lead.opacity : 1,
        easeCrossfadeIn(progress2)
      );
      target.opacityExit = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
    } else if (isOnlyMember) {
      target.opacity = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
    }
    for (let i2 = 0; i2 < numBorders; i2++) {
      const borderLabel = `border${borders[i2]}Radius`;
      let followRadius = getRadius(follow, borderLabel);
      let leadRadius = getRadius(lead, borderLabel);
      if (followRadius === void 0 && leadRadius === void 0)
        continue;
      followRadius || (followRadius = 0);
      leadRadius || (leadRadius = 0);
      const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
      if (canMix) {
        target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
        if (percent.test(leadRadius) || percent.test(followRadius)) {
          target[borderLabel] += "%";
        }
      } else {
        target[borderLabel] = leadRadius;
      }
    }
    if (follow.rotate || lead.rotate) {
      target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2);
    }
  }
  function getRadius(values, radiusName) {
    return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
  }
  var easeCrossfadeIn = compress2(0, 0.5, circOut);
  var easeCrossfadeOut = compress2(0.5, 0.95, noop);
  function compress2(min, max, easing) {
    return (p2) => {
      if (p2 < min)
        return 0;
      if (p2 > max)
        return 1;
      return easing(progress(min, max, p2));
    };
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
  function copyAxisInto(axis, originAxis) {
    axis.min = originAxis.min;
    axis.max = originAxis.max;
  }
  function copyBoxInto(box, originBox) {
    copyAxisInto(box.x, originBox.x);
    copyAxisInto(box.y, originBox.y);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
  function removePointDelta(point, translate, scale2, originPoint, boxScale) {
    point -= translate;
    point = scalePoint(point, 1 / scale2, originPoint);
    if (boxScale !== void 0) {
      point = scalePoint(point, 1 / boxScale, originPoint);
    }
    return point;
  }
  function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
    if (percent.test(translate)) {
      translate = parseFloat(translate);
      const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
      translate = relativeProgress - sourceAxis.min;
    }
    if (typeof translate !== "number")
      return;
    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);
    if (axis === originAxis)
      originPoint -= translate;
    axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
  }
  var xKeys2 = ["x", "scaleX", "originX"];
  var yKeys2 = ["y", "scaleY", "originY"];
  function removeBoxTransforms(box, transforms, originBox, sourceBox) {
    removeAxisTransforms(box.x, transforms, xKeys2, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
    removeAxisTransforms(box.y, transforms, yKeys2, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
  function isAxisDeltaZero(delta) {
    return delta.translate === 0 && delta.scale === 1;
  }
  function isDeltaZero(delta) {
    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
  }
  function boxEquals(a2, b2) {
    return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;
  }
  function boxEqualsRounded(a2, b2) {
    return Math.round(a2.x.min) === Math.round(b2.x.min) && Math.round(a2.x.max) === Math.round(b2.x.max) && Math.round(a2.y.min) === Math.round(b2.y.min) && Math.round(a2.y.max) === Math.round(b2.y.max);
  }
  function aspectRatio(box) {
    return calcLength(box.x) / calcLength(box.y);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/shared/stack.mjs
  var NodeStack = class {
    constructor() {
      this.members = [];
    }
    add(node) {
      addUniqueItem(this.members, node);
      node.scheduleRender();
    }
    remove(node) {
      removeItem(this.members, node);
      if (node === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node === this.lead) {
        const prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    }
    relegate(node) {
      const indexOfNode = this.members.findIndex((member) => node === member);
      if (indexOfNode === 0)
        return false;
      let prevLead;
      for (let i2 = indexOfNode; i2 >= 0; i2--) {
        const member = this.members[i2];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    }
    promote(node, preserveFollowOpacity) {
      const prevLead = this.lead;
      if (node === prevLead)
        return;
      this.prevLead = prevLead;
      this.lead = node;
      node.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node.scheduleRender();
        node.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node.snapshot = prevLead.snapshot;
          node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        }
        if (node.root && node.root.isUpdating) {
          node.isLayoutDirty = true;
        }
        const { crossfade } = node.options;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    }
    exitAnimationComplete() {
      this.members.forEach((node) => {
        const { options, resumingFrom } = node;
        options.onExitComplete && options.onExitComplete();
        if (resumingFrom) {
          resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
        }
      });
    }
    scheduleRender() {
      this.members.forEach((node) => {
        node.instance && node.scheduleRender(false);
      });
    }
    /**
     * Clear any leads that have been removed this render to prevent them from being
     * used in future animations and to prevent memory leaks
     */
    removeLeadSnapshot() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/styles/transform.mjs
  function buildProjectionTransform(delta, treeScale, latestTransform) {
    let transform = "";
    const xTranslate = delta.x.translate / treeScale.x;
    const yTranslate = delta.y.translate / treeScale.y;
    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;
    if (xTranslate || yTranslate || zTranslate) {
      transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
    }
    if (treeScale.x !== 1 || treeScale.y !== 1) {
      transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
    }
    if (latestTransform) {
      const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
      if (transformPerspective)
        transform = `perspective(${transformPerspective}px) ${transform}`;
      if (rotate)
        transform += `rotate(${rotate}deg) `;
      if (rotateX)
        transform += `rotateX(${rotateX}deg) `;
      if (rotateY)
        transform += `rotateY(${rotateY}deg) `;
      if (skewX)
        transform += `skewX(${skewX}deg) `;
      if (skewY)
        transform += `skewY(${skewY}deg) `;
    }
    const elementScaleX = delta.x.scale * treeScale.x;
    const elementScaleY = delta.y.scale * treeScale.y;
    if (elementScaleX !== 1 || elementScaleY !== 1) {
      transform += `scale(${elementScaleX}, ${elementScaleY})`;
    }
    return transform || "none";
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
  var compareByDepth = (a2, b2) => a2.depth - b2.depth;

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
  var FlatTree = class {
    constructor() {
      this.children = [];
      this.isDirty = false;
    }
    add(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    }
    remove(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    }
    forEach(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/delay.mjs
  function delay(callback, timeout) {
    const start = time.now();
    const checkElapsed = ({ timestamp }) => {
      const elapsed = timestamp - start;
      if (elapsed >= timeout) {
        cancelFrame(checkElapsed);
        callback(elapsed - timeout);
      }
    };
    frame.read(checkElapsed, true);
    return () => cancelFrame(checkElapsed);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/debug/record.mjs
  function record(data) {
    if (window.MotionDebug) {
      window.MotionDebug.record(data);
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs
  function isSVGElement(element) {
    return element instanceof SVGElement && element.tagName !== "svg";
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/interfaces/single-value.mjs
  function animateSingleValue(value, keyframes2, options) {
    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
    return motionValue$1.animation;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
  var transformAxes = ["", "X", "Y", "Z"];
  var hiddenVisibility = { visibility: "hidden" };
  var animationTarget = 1e3;
  var id2 = 0;
  var projectionFrameData = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
  };
  function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
    const { latestValues } = visualElement;
    if (latestValues[key]) {
      values[key] = latestValues[key];
      visualElement.setStaticValue(key, 0);
      if (sharedAnimationValues) {
        sharedAnimationValues[key] = 0;
      }
    }
  }
  function isOptimisedAppearTree(projectionNode) {
    projectionNode.hasCheckedOptimisedAppear = true;
    if (projectionNode.root === projectionNode)
      return false;
    const { visualElement } = projectionNode.options;
    if (!visualElement) {
      return false;
    } else if (getOptimisedAppearId(visualElement)) {
      return true;
    } else if (projectionNode.parent && !projectionNode.parent.hasCheckedOptimisedAppear) {
      return isOptimisedAppearTree(projectionNode.parent);
    } else {
      return false;
    }
  }
  function createProjectionNode2({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
    return class ProjectionNode {
      constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
        this.id = id2++;
        this.animationId = 0;
        this.children = /* @__PURE__ */ new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.isProjectionDirty = false;
        this.isSharedProjectionDirty = false;
        this.isTransformDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.hasCheckedOptimisedAppear = false;
        this.treeScale = { x: 1, y: 1 };
        this.eventHandlers = /* @__PURE__ */ new Map();
        this.hasTreeAnimated = false;
        this.updateScheduled = false;
        this.scheduleUpdate = () => this.update();
        this.projectionUpdateScheduled = false;
        this.checkUpdateFailed = () => {
          if (this.isUpdating) {
            this.isUpdating = false;
            this.clearAllSnapshots();
          }
        };
        this.updateProjection = () => {
          this.projectionUpdateScheduled = false;
          projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0;
          this.nodes.forEach(propagateDirtyNodes);
          this.nodes.forEach(resolveTargetDelta);
          this.nodes.forEach(calcProjection);
          this.nodes.forEach(cleanDirtyNodes);
          record(projectionFrameData);
        };
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = /* @__PURE__ */ new Map();
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? [...parent.path, parent] : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        for (let i2 = 0; i2 < this.path.length; i2++) {
          this.path[i2].shouldResetTransform = true;
        }
        if (this.root === this)
          this.nodes = new FlatTree();
      }
      addEventListener(name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      }
      notifyListeners(name, ...args) {
        const subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager && subscriptionManager.notify(...args);
      }
      hasListeners(name) {
        return this.eventHandlers.has(name);
      }
      /**
       * Lifecycles
       */
      mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
        if (this.instance)
          return;
        this.isSVG = isSVGElement(instance);
        this.instance = instance;
        const { layoutId, layout: layout2, visualElement } = this.options;
        if (visualElement && !visualElement.current) {
          visualElement.mount(instance);
        }
        this.root.nodes.add(this);
        this.parent && this.parent.children.add(this);
        if (isLayoutDirty && (layout2 || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          let cancelDelay;
          const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
          attachResizeListener(instance, () => {
            this.root.updateBlockedByResize = true;
            cancelDelay && cancelDelay();
            cancelDelay = delay(resizeUnblockUpdate, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
          this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
            if (this.isTreeAnimationBlocked()) {
              this.target = void 0;
              this.relativeTarget = void 0;
              return;
            }
            const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
            const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
            const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
            const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
            if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
              if (this.resumeFrom) {
                this.resumingFrom = this.resumeFrom;
                this.resumingFrom.resumingFrom = void 0;
              }
              this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
              const animationOptions = {
                ...getValueTransition(layoutTransition, "layout"),
                onPlay: onLayoutAnimationStart,
                onComplete: onLayoutAnimationComplete
              };
              if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              this.startAnimation(animationOptions);
            } else {
              if (!hasLayoutChanged) {
                finishAnimation(this);
              }
              if (this.isLead() && this.options.onExitComplete) {
                this.options.onExitComplete();
              }
            }
            this.targetLayout = newLayout;
          });
        }
      }
      unmount() {
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        const stack = this.getStack();
        stack && stack.remove(this);
        this.parent && this.parent.children.delete(this);
        this.instance = void 0;
        cancelFrame(this.updateProjection);
      }
      // only on the root
      blockUpdate() {
        this.updateManuallyBlocked = true;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = false;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
      }
      // Note: currently only running on root node
      startUpdate() {
        if (this.isUpdateBlocked())
          return;
        this.isUpdating = true;
        this.nodes && this.nodes.forEach(resetSkewAndRotation);
        this.animationId++;
      }
      getTransformTemplate() {
        const { visualElement } = this.options;
        return visualElement && visualElement.getProps().transformTemplate;
      }
      willUpdate(shouldNotifyListeners = true) {
        this.root.hasTreeAnimated = true;
        if (this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
          return;
        }
        if (window.HandoffCancelAllAnimations && isOptimisedAppearTree(this)) {
          window.HandoffCancelAllAnimations();
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty)
          return;
        this.isLayoutDirty = true;
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          node.shouldResetTransform = true;
          node.updateScroll("snapshot");
          if (node.options.layoutRoot) {
            node.willUpdate(false);
          }
        }
        const { layoutId, layout: layout2 } = this.options;
        if (layoutId === void 0 && !layout2)
          return;
        const transformTemplate = this.getTransformTemplate();
        this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      }
      update() {
        this.updateScheduled = false;
        const updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (!this.isUpdating) {
          this.nodes.forEach(clearIsLayoutDirty);
        }
        this.isUpdating = false;
        this.nodes.forEach(resetTransformStyle);
        this.nodes.forEach(updateLayout);
        this.nodes.forEach(notifyLayoutUpdate);
        this.clearAllSnapshots();
        const now2 = time.now();
        frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
        frameData.timestamp = now2;
        frameData.isProcessing = true;
        steps.update.process(frameData);
        steps.preRender.process(frameData);
        steps.render.process(frameData);
        frameData.isProcessing = false;
      }
      didUpdate() {
        if (!this.updateScheduled) {
          this.updateScheduled = true;
          microtask.read(this.scheduleUpdate);
        }
      }
      clearAllSnapshots() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      }
      scheduleUpdateProjection() {
        if (!this.projectionUpdateScheduled) {
          this.projectionUpdateScheduled = true;
          frame.preRender(this.updateProjection, false, true);
        }
      }
      scheduleCheckAfterUnmount() {
        frame.postRender(() => {
          if (this.isLayoutDirty) {
            this.root.didUpdate();
          } else {
            this.root.checkUpdateFailed();
          }
        });
      }
      /**
       * Update measurements
       */
      updateSnapshot() {
        if (this.snapshot || !this.instance)
          return;
        this.snapshot = this.measure();
      }
      updateLayout() {
        if (!this.instance)
          return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (let i2 = 0; i2 < this.path.length; i2++) {
            const node = this.path[i2];
            node.updateScroll();
          }
        }
        const prevLayout = this.layout;
        this.layout = this.measure(false);
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.layoutBox);
        const { visualElement } = this.options;
        visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
      }
      updateScroll(phase = "measure") {
        let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
          needsMeasurement = false;
        }
        if (needsMeasurement) {
          this.scroll = {
            animationId: this.root.animationId,
            phase,
            isRoot: checkIsScrollRoot(this.instance),
            offset: measureScroll(this.instance)
          };
        }
      }
      resetTransform() {
        if (!resetTransform)
          return;
        const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
        const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        const transformTemplate = this.getTransformTemplate();
        const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      }
      measure(removeTransform = true) {
        const pageBox = this.measurePageBox();
        let layoutBox = this.removeElementScroll(pageBox);
        if (removeTransform) {
          layoutBox = this.removeTransform(layoutBox);
        }
        roundBox(layoutBox);
        return {
          animationId: this.root.animationId,
          measuredBox: pageBox,
          layoutBox,
          latestValues: {},
          source: this.id
        };
      }
      measurePageBox() {
        const { visualElement } = this.options;
        if (!visualElement)
          return createBox();
        const box = visualElement.measureViewportBox();
        const { scroll } = this.root;
        if (scroll) {
          translateAxis(box.x, scroll.offset.x);
          translateAxis(box.y, scroll.offset.y);
        }
        return box;
      }
      removeElementScroll(box) {
        const boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          const { scroll, options } = node;
          if (node !== this.root && scroll && options.layoutScroll) {
            if (scroll.isRoot) {
              copyBoxInto(boxWithoutScroll, box);
              const { scroll: rootScroll } = this.root;
              if (rootScroll) {
                translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
                translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
              }
            }
            translateAxis(boxWithoutScroll.x, scroll.offset.x);
            translateAxis(boxWithoutScroll.y, scroll.offset.y);
          }
        }
        return boxWithoutScroll;
      }
      applyTransform(box, transformOnly = false) {
        const withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
            transformBox(withTransforms, {
              x: -node.scroll.offset.x,
              y: -node.scroll.offset.y
            });
          }
          if (!hasTransform(node.latestValues))
            continue;
          transformBox(withTransforms, node.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      }
      removeTransform(box) {
        const boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          if (!node.instance)
            continue;
          if (!hasTransform(node.latestValues))
            continue;
          hasScale(node.latestValues) && node.updateSnapshot();
          const sourceBox = createBox();
          const nodeBox = node.measurePageBox();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      }
      setTargetDelta(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
        this.isProjectionDirty = true;
      }
      setOptions(options) {
        this.options = {
          ...this.options,
          ...options,
          crossfade: options.crossfade !== void 0 ? options.crossfade : true
        };
      }
      clearMeasurements() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      }
      forceRelativeParentToResolveTarget() {
        if (!this.relativeParent)
          return;
        if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
          this.relativeParent.resolveTargetDelta(true);
        }
      }
      resolveTargetDelta(forceRecalculation = false) {
        var _a;
        const lead = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
        this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget);
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        if (!this.layout || !(layout2 || layoutId))
          return;
        this.resolvedRelativeTargetAt = frameData.timestamp;
        if (!this.targetDelta && !this.relativeTarget) {
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
        if (!this.relativeTarget && !this.targetDelta)
          return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
          this.forceRelativeParentToResolveTarget();
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.layoutBox);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
        projectionFrameData.resolvedTargetDeltas++;
      }
      getClosestProjectingParent() {
        if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
          return void 0;
        }
        if (this.parent.isProjecting()) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      }
      isProjecting() {
        return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
      }
      calcProjection() {
        var _a;
        const lead = this.getLead();
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        let canSkip = true;
        if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
          canSkip = false;
        }
        if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
          canSkip = false;
        }
        if (this.resolvedRelativeTargetAt === frameData.timestamp) {
          canSkip = false;
        }
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout2 || layoutId))
          return;
        copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
        const prevTreeScaleX = this.treeScale.x;
        const prevTreeScaleY = this.treeScale.y;
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
        if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
          lead.target = lead.layout.layoutBox;
          lead.targetWithTransforms = createBox();
        }
        const { target } = lead;
        if (!target) {
          if (this.projectionTransform) {
            this.projectionDelta = createDelta();
            this.projectionTransform = "none";
            this.scheduleRender();
          }
          return;
        }
        if (!this.projectionDelta) {
          this.projectionDelta = createDelta();
          this.projectionDeltaWithTransform = createDelta();
        }
        const prevProjectionTransform = this.projectionTransform;
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
        if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
        projectionFrameData.recalculatedProjection++;
      }
      hide() {
        this.isVisible = false;
      }
      show() {
        this.isVisible = true;
      }
      scheduleRender(notifyAll = true) {
        this.options.scheduleRender && this.options.scheduleRender();
        if (notifyAll) {
          const stack = this.getStack();
          stack && stack.scheduleRender();
        }
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      }
      setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
        const snapshot = this.snapshot;
        const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
        const mixedValues = { ...this.latestValues };
        const targetDelta = createDelta();
        if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
          this.relativeTarget = this.relativeTargetOrigin = void 0;
        }
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        const relativeLayout = createBox();
        const snapshotSource = snapshot ? snapshot.source : void 0;
        const layoutSource = this.layout ? this.layout.source : void 0;
        const isSharedLayoutAnimation = snapshotSource !== layoutSource;
        const stack = this.getStack();
        const isOnlyMember = !stack || stack.members.length <= 1;
        const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        let prevRelativeTarget;
        this.mixTargetDelta = (latest) => {
          const progress2 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress2);
          mixAxisDelta(targetDelta.y, delta.y, progress2);
          this.setTargetDelta(targetDelta);
          if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
            calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
            mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
            if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
              this.isProjectionDirty = false;
            }
            if (!prevRelativeTarget)
              prevRelativeTarget = createBox();
            copyBoxInto(prevRelativeTarget, this.relativeTarget);
          }
          if (isSharedLayoutAnimation) {
            this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
          }
          this.root.scheduleUpdateProjection();
          this.scheduleRender();
          this.animationProgress = progress2;
        };
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
      }
      startAnimation(options) {
        this.notifyListeners("animationStart");
        this.currentAnimation && this.currentAnimation.stop();
        if (this.resumingFrom && this.resumingFrom.currentAnimation) {
          this.resumingFrom.currentAnimation.stop();
        }
        if (this.pendingAnimation) {
          cancelFrame(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = frame.update(() => {
          globalProjectionState.hasAnimatedSinceResize = true;
          this.currentAnimation = animateSingleValue(0, animationTarget, {
            ...options,
            onUpdate: (latest) => {
              this.mixTargetDelta(latest);
              options.onUpdate && options.onUpdate(latest);
            },
            onComplete: () => {
              options.onComplete && options.onComplete();
              this.completeAnimation();
            }
          });
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = this.currentAnimation;
          }
          this.pendingAnimation = void 0;
        });
      }
      completeAnimation() {
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        const stack = this.getStack();
        stack && stack.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      }
      finishAnimation() {
        if (this.currentAnimation) {
          this.mixTargetDelta && this.mixTargetDelta(animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      }
      applyTransformsToTarget() {
        const lead = this.getLead();
        let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
        if (!targetWithTransforms || !target || !layout2)
          return;
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min;
          target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min;
          target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
      registerSharedNode(layoutId, node) {
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        const stack = this.sharedNodes.get(layoutId);
        stack.add(node);
        const config = node.options.initialPromotionConfig;
        node.promote({
          transition: config ? config.transition : void 0,
          preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
        });
      }
      isLead() {
        const stack = this.getStack();
        return stack ? stack.lead === this : true;
      }
      getLead() {
        var _a;
        const { layoutId } = this.options;
        return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
      }
      getPrevLead() {
        var _a;
        const { layoutId } = this.options;
        return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
      }
      getStack() {
        const { layoutId } = this.options;
        if (layoutId)
          return this.root.sharedNodes.get(layoutId);
      }
      promote({ needsReset, transition, preserveFollowOpacity } = {}) {
        const stack = this.getStack();
        if (stack)
          stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition)
          this.setOptions({ transition });
      }
      relegate() {
        const stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      }
      resetSkewAndRotation() {
        const { visualElement } = this.options;
        if (!visualElement)
          return;
        let hasDistortingTransform = false;
        const { latestValues } = visualElement;
        if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
          hasDistortingTransform = true;
        }
        if (!hasDistortingTransform)
          return;
        const resetValues = {};
        if (latestValues.z) {
          resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
        }
        for (let i2 = 0; i2 < transformAxes.length; i2++) {
          resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
          resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
        }
        visualElement.render();
        for (const key in resetValues) {
          visualElement.setStaticValue(key, resetValues[key]);
          if (this.animationValues) {
            this.animationValues[key] = resetValues[key];
          }
        }
        visualElement.scheduleRender();
      }
      getProjectionStyles(styleProp) {
        var _a, _b;
        if (!this.instance || this.isSVG)
          return void 0;
        if (!this.isVisible) {
          return hiddenVisibility;
        }
        const styles = {
          visibility: ""
        };
        const transformTemplate = this.getTransformTemplate();
        if (this.needsReset) {
          this.needsReset = false;
          styles.opacity = "";
          styles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
          styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
          return styles;
        }
        const lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          const emptyStyles = {};
          if (this.options.layoutId) {
            emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
            emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
            this.hasProjected = false;
          }
          return emptyStyles;
        }
        const valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate) {
          styles.transform = transformTemplate(valuesToRender, styles.transform);
        }
        const { x: x2, y: y2 } = this.projectionDelta;
        styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
        if (lead.animationValues) {
          styles.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
        }
        for (const key in scaleCorrectors) {
          if (valuesToRender[key] === void 0)
            continue;
          const { correct, applyTo } = scaleCorrectors[key];
          const corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
          if (applyTo) {
            const num = applyTo.length;
            for (let i2 = 0; i2 < num; i2++) {
              styles[applyTo[i2]] = corrected;
            }
          } else {
            styles[key] = corrected;
          }
        }
        if (this.options.layoutId) {
          styles.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "" : "none";
        }
        return styles;
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0;
      }
      // Only run on root
      resetTree() {
        this.root.nodes.forEach((node) => {
          var _a;
          return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
        });
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      }
    };
  }
  function updateLayout(node) {
    node.updateLayout();
  }
  function notifyLayoutUpdate(node) {
    var _a;
    const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
    if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
      const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
      const { animationType } = node.options;
      const isShared = snapshot.source !== node.layout.source;
      if (animationType === "size") {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(axisSnapshot);
          axisSnapshot.min = layout2[axis].min;
          axisSnapshot.max = axisSnapshot.min + length;
        });
      } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(layout2[axis]);
          axisSnapshot.max = axisSnapshot.min + length;
          if (node.relativeTarget && !node.currentAnimation) {
            node.isProjectionDirty = true;
            node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
          }
        });
      }
      const layoutDelta = createDelta();
      calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
      const visualDelta = createDelta();
      if (isShared) {
        calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
      } else {
        calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
      }
      const hasLayoutChanged = !isDeltaZero(layoutDelta);
      let hasRelativeTargetChanged = false;
      if (!node.resumeFrom) {
        const relativeParent = node.getClosestProjectingParent();
        if (relativeParent && !relativeParent.resumeFrom) {
          const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
          if (parentSnapshot && parentLayout) {
            const relativeSnapshot = createBox();
            calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
            const relativeLayout = createBox();
            calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
            if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
              hasRelativeTargetChanged = true;
            }
            if (relativeParent.options.layoutRoot) {
              node.relativeTarget = relativeLayout;
              node.relativeTargetOrigin = relativeSnapshot;
              node.relativeParent = relativeParent;
            }
          }
        }
      }
      node.notifyListeners("didUpdate", {
        layout: layout2,
        snapshot,
        delta: visualDelta,
        layoutDelta,
        hasLayoutChanged,
        hasRelativeTargetChanged
      });
    } else if (node.isLead()) {
      const { onExitComplete } = node.options;
      onExitComplete && onExitComplete();
    }
    node.options.transition = void 0;
  }
  function propagateDirtyNodes(node) {
    projectionFrameData.totalNodes++;
    if (!node.parent)
      return;
    if (!node.isProjecting()) {
      node.isProjectionDirty = node.parent.isProjectionDirty;
    }
    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
  }
  function cleanDirtyNodes(node) {
    node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
  }
  function clearSnapshot(node) {
    node.clearSnapshot();
  }
  function clearMeasurements(node) {
    node.clearMeasurements();
  }
  function clearIsLayoutDirty(node) {
    node.isLayoutDirty = false;
  }
  function resetTransformStyle(node) {
    const { visualElement } = node.options;
    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
      visualElement.notify("BeforeLayoutMeasure");
    }
    node.resetTransform();
  }
  function finishAnimation(node) {
    node.finishAnimation();
    node.targetDelta = node.relativeTarget = node.target = void 0;
    node.isProjectionDirty = true;
  }
  function resolveTargetDelta(node) {
    node.resolveTargetDelta();
  }
  function calcProjection(node) {
    node.calcProjection();
  }
  function resetSkewAndRotation(node) {
    node.resetSkewAndRotation();
  }
  function removeLeadSnapshots(stack) {
    stack.removeLeadSnapshot();
  }
  function mixAxisDelta(output2, delta, p2) {
    output2.translate = mixNumber(delta.translate, 0, p2);
    output2.scale = mixNumber(delta.scale, 1, p2);
    output2.origin = delta.origin;
    output2.originPoint = delta.originPoint;
  }
  function mixAxis(output2, from6, to, p2) {
    output2.min = mixNumber(from6.min, to.min, p2);
    output2.max = mixNumber(from6.max, to.max, p2);
  }
  function mixBox(output2, from6, to, p2) {
    mixAxis(output2.x, from6.x, to.x, p2);
    mixAxis(output2.y, from6.y, to.y, p2);
  }
  function hasOpacityCrossfade(node) {
    return node.animationValues && node.animationValues.opacityExit !== void 0;
  }
  var defaultLayoutTransition = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1]
  };
  var userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
  var roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
  function roundAxis(axis) {
    axis.min = roundPoint(axis.min);
    axis.max = roundPoint(axis.max);
  }
  function roundBox(box) {
    roundAxis(box.x);
    roundAxis(box.y);
  }
  function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
    return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
  var DocumentProjectionNode = createProjectionNode2({
    attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => true
  });

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
  var rootProjectionNode = {
    current: void 0
  };
  var HTMLProjectionNode = createProjectionNode2({
    measureScroll: (instance) => ({
      x: instance.scrollLeft,
      y: instance.scrollTop
    }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const documentNode = new DocumentProjectionNode({});
        documentNode.mount(window);
        documentNode.setOptions({ layoutScroll: true });
        rootProjectionNode.current = documentNode;
      }
      return rootProjectionNode.current;
    },
    resetTransform: (instance, value) => {
      instance.style.transform = value !== void 0 ? value : "none";
    },
    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
  });

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/drag.mjs
  var drag = {
    pan: {
      Feature: PanGesture
    },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
  var import_react24 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs
  var prefersReducedMotion = { current: null };
  var hasReducedMotionListener = { current: false };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs
  function initPrefersReducedMotion() {
    hasReducedMotionListener.current = true;
    if (!isBrowser)
      return;
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
      const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addListener(setReducedMotionPreferences);
      setReducedMotionPreferences();
    } else {
      prefersReducedMotion.current = false;
    }
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
  function updateMotionValuesFromProps(element, next, prev) {
    const { willChange } = next;
    for (const key in next) {
      const nextValue = next[key];
      const prevValue = prev[key];
      if (isMotionValue(nextValue)) {
        element.addValue(key, nextValue);
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key);
        }
        if (false) {
          warnOnce(nextValue.version === "11.2.14", `Attempting to mix Framer Motion versions ${nextValue.version} with 11.2.14 may not work as expected.`);
        }
      } else if (isMotionValue(prevValue)) {
        element.addValue(key, motionValue(nextValue, { owner: element }));
        if (isWillChangeMotionValue(willChange)) {
          willChange.remove(key);
        }
      } else if (prevValue !== nextValue) {
        if (element.hasValue(key)) {
          const existingValue = element.getValue(key);
          if (existingValue.liveStyle === true) {
            existingValue.jump(nextValue);
          } else if (!existingValue.hasAnimated) {
            existingValue.set(nextValue);
          }
        } else {
          const latestValue = element.getStaticValue(key);
          element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
        }
      }
    }
    for (const key in prev) {
      if (next[key] === void 0)
        element.removeValue(key);
    }
    return next;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/store.mjs
  var visualElementStore = /* @__PURE__ */ new WeakMap();

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs
  var valueTypes = [...dimensionValueTypes, color, complex];
  var findValueType = (v2) => valueTypes.find(testValueType(v2));

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/VisualElement.mjs
  var propEventHandlers = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete"
  ];
  var numVariantProps = variantProps.length;
  var VisualElement = class {
    /**
     * This method takes React props and returns found MotionValues. For example, HTML
     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
     *
     * This isn't an abstract method as it needs calling in the constructor, but it is
     * intended to be one.
     */
    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
      return {};
    }
    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
      this.resolveKeyframes = (keyframes2, onComplete, name, value) => {
        return new this.KeyframeResolver(keyframes2, onComplete, name, value, this);
      };
      this.current = null;
      this.children = /* @__PURE__ */ new Set();
      this.isVariantNode = false;
      this.isControllingVariants = false;
      this.shouldReduceMotion = null;
      this.values = /* @__PURE__ */ new Map();
      this.KeyframeResolver = KeyframeResolver;
      this.features = {};
      this.valueSubscriptions = /* @__PURE__ */ new Map();
      this.prevMotionValues = {};
      this.events = {};
      this.propEventSubscriptions = {};
      this.notifyUpdate = () => this.notify("Update", this.latestValues);
      this.render = () => {
        if (!this.current)
          return;
        this.triggerBuild();
        this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
      };
      this.scheduleRender = () => frame.render(this.render, false, true);
      const { latestValues, renderState } = visualState;
      this.latestValues = latestValues;
      this.baseTarget = { ...latestValues };
      this.initialValues = props.initial ? { ...latestValues } : {};
      this.renderState = renderState;
      this.parent = parent;
      this.props = props;
      this.presenceContext = presenceContext;
      this.depth = parent ? parent.depth + 1 : 0;
      this.reducedMotionConfig = reducedMotionConfig;
      this.options = options;
      this.blockInitialAnimation = Boolean(blockInitialAnimation);
      this.isControllingVariants = isControllingVariants(props);
      this.isVariantNode = isVariantNode(props);
      if (this.isVariantNode) {
        this.variantChildren = /* @__PURE__ */ new Set();
      }
      this.manuallyAnimateOnMount = Boolean(parent && parent.current);
      const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
      for (const key in initialMotionValues) {
        const value = initialMotionValues[key];
        if (latestValues[key] !== void 0 && isMotionValue(value)) {
          value.set(latestValues[key], false);
          if (isWillChangeMotionValue(willChange)) {
            willChange.add(key);
          }
        }
      }
    }
    mount(instance) {
      this.current = instance;
      visualElementStore.set(instance, this);
      if (this.projection && !this.projection.instance) {
        this.projection.mount(instance);
      }
      if (this.parent && this.isVariantNode && !this.isControllingVariants) {
        this.removeFromVariantTree = this.parent.addVariantChild(this);
      }
      this.values.forEach((value, key) => this.bindToMotionValue(key, value));
      if (!hasReducedMotionListener.current) {
        initPrefersReducedMotion();
      }
      this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
      if (false) {
        warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
      }
      if (this.parent)
        this.parent.children.add(this);
      this.update(this.props, this.presenceContext);
    }
    unmount() {
      visualElementStore.delete(this.current);
      this.projection && this.projection.unmount();
      cancelFrame(this.notifyUpdate);
      cancelFrame(this.render);
      this.valueSubscriptions.forEach((remove) => remove());
      this.removeFromVariantTree && this.removeFromVariantTree();
      this.parent && this.parent.children.delete(this);
      for (const key in this.events) {
        this.events[key].clear();
      }
      for (const key in this.features) {
        const feature = this.features[key];
        if (feature) {
          feature.unmount();
          feature.isMounted = false;
        }
      }
      this.current = null;
    }
    bindToMotionValue(key, value) {
      const valueIsTransform = transformProps.has(key);
      const removeOnChange = value.on("change", (latestValue) => {
        this.latestValues[key] = latestValue;
        this.props.onUpdate && frame.preRender(this.notifyUpdate);
        if (valueIsTransform && this.projection) {
          this.projection.isTransformDirty = true;
        }
      });
      const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
      this.valueSubscriptions.set(key, () => {
        removeOnChange();
        removeOnRenderRequest();
        if (value.owner)
          value.stop();
      });
    }
    sortNodePosition(other) {
      if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
        return 0;
      }
      return this.sortInstanceNodePosition(this.current, other.current);
    }
    updateFeatures() {
      let key = "animation";
      for (key in featureDefinitions) {
        const featureDefinition = featureDefinitions[key];
        if (!featureDefinition)
          continue;
        const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
        if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
          this.features[key] = new FeatureConstructor(this);
        }
        if (this.features[key]) {
          const feature = this.features[key];
          if (feature.isMounted) {
            feature.update();
          } else {
            feature.mount();
            feature.isMounted = true;
          }
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.options, this.props);
    }
    /**
     * Measure the current viewport box with or without transforms.
     * Only measures axis-aligned boxes, rotate and skew must be manually
     * removed with a re-render to work.
     */
    measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
    }
    getStaticValue(key) {
      return this.latestValues[key];
    }
    setStaticValue(key, value) {
      this.latestValues[key] = value;
    }
    /**
     * Update the provided props. Ensure any newly-added motion values are
     * added to our map, old ones removed, and listeners updated.
     */
    update(props, presenceContext) {
      if (props.transformTemplate || this.props.transformTemplate) {
        this.scheduleRender();
      }
      this.prevProps = this.props;
      this.props = props;
      this.prevPresenceContext = this.presenceContext;
      this.presenceContext = presenceContext;
      for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
        const key = propEventHandlers[i2];
        if (this.propEventSubscriptions[key]) {
          this.propEventSubscriptions[key]();
          delete this.propEventSubscriptions[key];
        }
        const listenerName = "on" + key;
        const listener = props[listenerName];
        if (listener) {
          this.propEventSubscriptions[key] = this.on(key, listener);
        }
      }
      this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
      if (this.handleChildMotionValue) {
        this.handleChildMotionValue();
      }
    }
    getProps() {
      return this.props;
    }
    /**
     * Returns the variant definition with a given name.
     */
    getVariant(name) {
      return this.props.variants ? this.props.variants[name] : void 0;
    }
    /**
     * Returns the defined default transition on this component.
     */
    getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
    }
    getVariantContext(startAtParent = false) {
      if (startAtParent) {
        return this.parent ? this.parent.getVariantContext() : void 0;
      }
      if (!this.isControllingVariants) {
        const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
        if (this.props.initial !== void 0) {
          context2.initial = this.props.initial;
        }
        return context2;
      }
      const context = {};
      for (let i2 = 0; i2 < numVariantProps; i2++) {
        const name = variantProps[i2];
        const prop = this.props[name];
        if (isVariantLabel(prop) || prop === false) {
          context[name] = prop;
        }
      }
      return context;
    }
    /**
     * Add a child visual element to our set of children.
     */
    addVariantChild(child) {
      const closestVariantNode = this.getClosestVariantNode();
      if (closestVariantNode) {
        closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
        return () => closestVariantNode.variantChildren.delete(child);
      }
    }
    /**
     * Add a motion value and bind it to this visual element.
     */
    addValue(key, value) {
      const existingValue = this.values.get(key);
      if (value !== existingValue) {
        if (existingValue)
          this.removeValue(key);
        this.bindToMotionValue(key, value);
        this.values.set(key, value);
        this.latestValues[key] = value.get();
      }
    }
    /**
     * Remove a motion value and unbind any active subscriptions.
     */
    removeValue(key) {
      this.values.delete(key);
      const unsubscribe = this.valueSubscriptions.get(key);
      if (unsubscribe) {
        unsubscribe();
        this.valueSubscriptions.delete(key);
      }
      delete this.latestValues[key];
      this.removeValueFromRenderState(key, this.renderState);
    }
    /**
     * Check whether we have a motion value for this key
     */
    hasValue(key) {
      return this.values.has(key);
    }
    getValue(key, defaultValue) {
      if (this.props.values && this.props.values[key]) {
        return this.props.values[key];
      }
      let value = this.values.get(key);
      if (value === void 0 && defaultValue !== void 0) {
        value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
        this.addValue(key, value);
      }
      return value;
    }
    /**
     * If we're trying to animate to a previously unencountered value,
     * we need to check for it in our state and as a last resort read it
     * directly from the instance (which might have performance implications).
     */
    readValue(key, target) {
      var _a;
      let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);
      if (value !== void 0 && value !== null) {
        if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
          value = parseFloat(value);
        } else if (!findValueType(value) && complex.test(target)) {
          value = getAnimatableNone2(key, target);
        }
        this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
      }
      return isMotionValue(value) ? value.get() : value;
    }
    /**
     * Set the base target to later animate back to. This is currently
     * only hydrated on creation and when we first read a value.
     */
    setBaseTarget(key, value) {
      this.baseTarget[key] = value;
    }
    /**
     * Find the base target for a value thats been removed from all animation
     * props.
     */
    getBaseTarget(key) {
      var _a;
      const { initial } = this.props;
      let valueFromInitial;
      if (typeof initial === "string" || typeof initial === "object") {
        const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);
        if (variant) {
          valueFromInitial = variant[key];
        }
      }
      if (initial && valueFromInitial !== void 0) {
        return valueFromInitial;
      }
      const target = this.getBaseTargetFromProps(this.props, key);
      if (target !== void 0 && !isMotionValue(target))
        return target;
      return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      return this.events[eventName].add(callback);
    }
    notify(eventName, ...args) {
      if (this.events[eventName]) {
        this.events[eventName].notify(...args);
      }
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs
  var DOMVisualElement = class extends VisualElement {
    constructor() {
      super(...arguments);
      this.KeyframeResolver = DOMKeyframesResolver;
    }
    sortInstanceNodePosition(a2, b2) {
      return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(props, key) {
      return props.style ? props.style[key] : void 0;
    }
    removeValueFromRenderState(key, { vars, style }) {
      delete vars[key];
      delete style[key];
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs
  function getComputedStyle2(element) {
    return window.getComputedStyle(element);
  }
  var HTMLVisualElement = class extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "html";
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      } else {
        const computedStyle = getComputedStyle2(instance);
        const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
        return typeof value === "string" ? value.trim() : value;
      }
    }
    measureInstanceViewportBox(instance, { transformPagePoint }) {
      return measureViewportBox(instance, transformPagePoint);
    }
    build(renderState, latestValues, options, props) {
      buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps(props, prevProps, visualElement);
    }
    handleChildMotionValue() {
      if (this.childSubscription) {
        this.childSubscription();
        delete this.childSubscription;
      }
      const { children } = this.props;
      if (isMotionValue(children)) {
        this.childSubscription = children.on("change", (latest) => {
          if (this.current)
            this.current.textContent = `${latest}`;
        });
      }
    }
    renderInstance(instance, renderState, styleProp, projection) {
      renderHTML(instance, renderState, styleProp, projection);
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs
  var SVGVisualElement = class extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.isSVGTag = false;
    }
    getBaseTargetFromProps(props, key) {
      return props[key];
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      }
      key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
      return instance.getAttribute(key);
    }
    measureInstanceViewportBox() {
      return createBox();
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps2(props, prevProps, visualElement);
    }
    build(renderState, latestValues, options, props) {
      buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);
    }
    renderInstance(instance, renderState, styleProp, projection) {
      renderSVG(instance, renderState, styleProp, projection);
    }
    mount(instance) {
      this.isSVGTag = isSVGTag(instance.tagName);
      super.mount(instance);
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
  var createDomVisualElement = (Component3, options) => {
    return isSVGComponent(Component3) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, {
      allowProjection: Component3 !== import_react24.Fragment,
      enableHardwareAcceleration: true
    });
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/layout.mjs
  var layout = {
    layout: {
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/motion.mjs
  var preloadedFeatures = {
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout
  };
  var motion = /* @__PURE__ */ createMotionProxy((Component3, config) => createDomMotionConfig(Component3, config, preloadedFeatures, createDomVisualElement));

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
  var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
  var import_react30 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-force-update.mjs
  var import_react26 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs
  var import_react25 = __toESM(require_react(), 1);
  function useIsMounted() {
    const isMounted = (0, import_react25.useRef)(false);
    useIsomorphicLayoutEffect(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return isMounted;
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-force-update.mjs
  function useForceUpdate() {
    const isMounted = useIsMounted();
    const [forcedRenderCount, setForcedRenderCount] = (0, import_react26.useState)(0);
    const forceRender = (0, import_react26.useCallback)(() => {
      isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
    }, [forcedRenderCount]);
    const deferredForceRender = (0, import_react26.useCallback)(() => frame.postRender(forceRender), [forceRender]);
    return [deferredForceRender, forcedRenderCount];
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
  var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
  var React16 = __toESM(require_react(), 1);
  var import_react28 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
  var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
  var React15 = __toESM(require_react(), 1);
  var import_react27 = __toESM(require_react(), 1);
  var PopChildMeasure = class extends React15.Component {
    getSnapshotBeforeUpdate(prevProps) {
      const element = this.props.childRef.current;
      if (element && prevProps.isPresent && !this.props.isPresent) {
        const size3 = this.props.sizeRef.current;
        size3.height = element.offsetHeight || 0;
        size3.width = element.offsetWidth || 0;
        size3.top = element.offsetTop;
        size3.left = element.offsetLeft;
      }
      return null;
    }
    /**
     * Required with getSnapshotBeforeUpdate to stop React complaining.
     */
    componentDidUpdate() {
    }
    render() {
      return this.props.children;
    }
  };
  function PopChild({ children, isPresent }) {
    const id3 = (0, import_react27.useId)();
    const ref = (0, import_react27.useRef)(null);
    const size3 = (0, import_react27.useRef)({
      width: 0,
      height: 0,
      top: 0,
      left: 0
    });
    const { nonce } = (0, import_react27.useContext)(MotionConfigContext);
    (0, import_react27.useInsertionEffect)(() => {
      const { width, height, top, left } = size3.current;
      if (isPresent || !ref.current || !width || !height)
        return;
      ref.current.dataset.motionPopId = id3;
      const style = document.createElement("style");
      if (nonce)
        style.nonce = nonce;
      document.head.appendChild(style);
      if (style.sheet) {
        style.sheet.insertRule(`
          [data-motion-pop-id="${id3}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
      }
      return () => {
        document.head.removeChild(style);
      };
    }, [isPresent]);
    return (0, import_jsx_runtime12.jsx)(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size3, children: React15.cloneElement(children, { ref }) });
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
  var PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode }) => {
    const presenceChildren = useConstant(newChildrenMap);
    const id3 = (0, import_react28.useId)();
    const context = (0, import_react28.useMemo)(
      () => ({
        id: id3,
        initial,
        isPresent,
        custom,
        onExitComplete: (childId) => {
          presenceChildren.set(childId, true);
          for (const isComplete of presenceChildren.values()) {
            if (!isComplete)
              return;
          }
          onExitComplete && onExitComplete();
        },
        register: (childId) => {
          presenceChildren.set(childId, false);
          return () => presenceChildren.delete(childId);
        }
      }),
      /**
       * If the presence of a child affects the layout of the components around it,
       * we want to make a new context value to ensure they get re-rendered
       * so they can detect that layout change.
       */
      presenceAffectsLayout ? [Math.random()] : [isPresent]
    );
    (0, import_react28.useMemo)(() => {
      presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
    }, [isPresent]);
    React16.useEffect(() => {
      !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
    }, [isPresent]);
    if (mode === "popLayout") {
      children = (0, import_jsx_runtime13.jsx)(PopChild, { isPresent, children });
    }
    return (0, import_jsx_runtime13.jsx)(PresenceContext.Provider, { value: context, children });
  };
  function newChildrenMap() {
    return /* @__PURE__ */ new Map();
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs
  var import_react29 = __toESM(require_react(), 1);
  function useUnmountEffect(callback) {
    return (0, import_react29.useEffect)(() => () => callback(), []);
  }

  // ../../node_modules/.pnpm/framer-motion@11.2.14_@emotion+is-prop-valid@0.8.8_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
  var getChildKey = (child) => child.key || "";
  function updateChildLookup(children, allChildren) {
    children.forEach((child) => {
      const key = getChildKey(child);
      allChildren.set(key, child);
    });
  }
  function onlyElements(children) {
    const filtered = [];
    import_react30.Children.forEach(children, (child) => {
      if ((0, import_react30.isValidElement)(child))
        filtered.push(child);
    });
    return filtered;
  }
  var AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = "sync" }) => {
    invariant(!exitBeforeEnter, "Replace exitBeforeEnter with mode='wait'");
    const forceRender = (0, import_react30.useContext)(LayoutGroupContext).forceRender || useForceUpdate()[0];
    const isMounted = useIsMounted();
    const filteredChildren = onlyElements(children);
    let childrenToRender = filteredChildren;
    const exitingChildren = (0, import_react30.useRef)(/* @__PURE__ */ new Map()).current;
    const presentChildren = (0, import_react30.useRef)(childrenToRender);
    const allChildren = (0, import_react30.useRef)(/* @__PURE__ */ new Map()).current;
    const isInitialRender = (0, import_react30.useRef)(true);
    useIsomorphicLayoutEffect(() => {
      isInitialRender.current = false;
      updateChildLookup(filteredChildren, allChildren);
      presentChildren.current = childrenToRender;
    });
    useUnmountEffect(() => {
      isInitialRender.current = true;
      allChildren.clear();
      exitingChildren.clear();
    });
    if (isInitialRender.current) {
      return (0, import_jsx_runtime14.jsx)(import_jsx_runtime14.Fragment, { children: childrenToRender.map((child) => (0, import_jsx_runtime14.jsx)(PresenceChild, { isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode, children: child }, getChildKey(child))) });
    }
    childrenToRender = [...childrenToRender];
    const presentKeys = presentChildren.current.map(getChildKey);
    const targetKeys = filteredChildren.map(getChildKey);
    const numPresent = presentKeys.length;
    for (let i2 = 0; i2 < numPresent; i2++) {
      const key = presentKeys[i2];
      if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {
        exitingChildren.set(key, void 0);
      }
    }
    if (mode === "wait" && exitingChildren.size) {
      childrenToRender = [];
    }
    exitingChildren.forEach((component, key) => {
      if (targetKeys.indexOf(key) !== -1)
        return;
      const child = allChildren.get(key);
      if (!child)
        return;
      const insertionIndex = presentKeys.indexOf(key);
      let exitingComponent = component;
      if (!exitingComponent) {
        const onExit = () => {
          exitingChildren.delete(key);
          const leftOverKeys = Array.from(allChildren.keys()).filter((childKey) => !targetKeys.includes(childKey));
          leftOverKeys.forEach((leftOverKey) => allChildren.delete(leftOverKey));
          presentChildren.current = filteredChildren.filter((presentChild) => {
            const presentChildKey = getChildKey(presentChild);
            return (
              // filter out the node exiting
              presentChildKey === key || // filter out the leftover children
              leftOverKeys.includes(presentChildKey)
            );
          });
          if (!exitingChildren.size) {
            if (isMounted.current === false)
              return;
            forceRender();
            onExitComplete && onExitComplete();
          }
        };
        exitingComponent = (0, import_jsx_runtime14.jsx)(PresenceChild, { isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout, mode, children: child }, getChildKey(child));
        exitingChildren.set(key, exitingComponent);
      }
      childrenToRender.splice(insertionIndex, 0, exitingComponent);
    });
    childrenToRender = childrenToRender.map((child) => {
      const key = child.key;
      return exitingChildren.has(key) ? child : (0, import_jsx_runtime14.jsx)(PresenceChild, { isPresent: true, presenceAffectsLayout, mode, children: child }, getChildKey(child));
    });
    if (false) {
      console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
    }
    return (0, import_jsx_runtime14.jsx)(import_jsx_runtime14.Fragment, { children: exitingChildren.size ? childrenToRender : childrenToRender.map((child) => (0, import_react30.cloneElement)(child)) });
  };

  // ../react/build/index.js
  var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
  var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
  var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
  var import_react36 = __toESM(require_react(), 1);
  var import_react37 = __toESM(require_react(), 1);
  var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
  var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);

  // ../../node_modules/.pnpm/@radix-ui+react-dialog@1.1.1_@types+react-dom@18.0.9_@types+react@18.0.25_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@radix-ui/react-dialog/dist/index.mjs
  var React28 = __toESM(require_react(), 1);

  // ../../node_modules/.pnpm/@radix-ui+react-id@1.1.0_@types+react@18.0.25_react@18.2.0/node_modules/@radix-ui/react-id/dist/index.mjs
  var React17 = __toESM(require_react(), 1);
  var useReactId = React17["useId".toString()] || (() => void 0);
  var count = 0;
  function useId4(deterministicId) {
    const [id3, setId] = React17.useState(useReactId());
    useLayoutEffect2(() => {
      if (!deterministicId) setId((reactId) => reactId ?? String(count++));
    }, [deterministicId]);
    return deterministicId || (id3 ? `radix-${id3}` : "");
  }

  // ../../node_modules/.pnpm/@radix-ui+react-focus-scope@1.1.0_@types+react-dom@18.0.9_@types+react@18.0.25_react-dom@18.2_yb5ta65p5ctqidqoafabgamxby/node_modules/@radix-ui/react-focus-scope/dist/index.mjs
  var React18 = __toESM(require_react(), 1);
  var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
  var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
  var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
  var EVENT_OPTIONS = { bubbles: false, cancelable: true };
  var FOCUS_SCOPE_NAME = "FocusScope";
  var FocusScope = React18.forwardRef((props, forwardedRef) => {
    const {
      loop = false,
      trapped = false,
      onMountAutoFocus: onMountAutoFocusProp,
      onUnmountAutoFocus: onUnmountAutoFocusProp,
      ...scopeProps
    } = props;
    const [container, setContainer] = React18.useState(null);
    const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
    const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
    const lastFocusedElementRef = React18.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
    const focusScope = React18.useRef({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    }).current;
    React18.useEffect(() => {
      if (trapped) {
        let handleFocusIn2 = function(event) {
          if (focusScope.paused || !container) return;
          const target = event.target;
          if (container.contains(target)) {
            lastFocusedElementRef.current = target;
          } else {
            focus(lastFocusedElementRef.current, { select: true });
          }
        }, handleFocusOut2 = function(event) {
          if (focusScope.paused || !container) return;
          const relatedTarget = event.relatedTarget;
          if (relatedTarget === null) return;
          if (!container.contains(relatedTarget)) {
            focus(lastFocusedElementRef.current, { select: true });
          }
        }, handleMutations2 = function(mutations) {
          const focusedElement = document.activeElement;
          if (focusedElement !== document.body) return;
          for (const mutation of mutations) {
            if (mutation.removedNodes.length > 0) focus(container);
          }
        };
        var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
        document.addEventListener("focusin", handleFocusIn2);
        document.addEventListener("focusout", handleFocusOut2);
        const mutationObserver = new MutationObserver(handleMutations2);
        if (container) mutationObserver.observe(container, { childList: true, subtree: true });
        return () => {
          document.removeEventListener("focusin", handleFocusIn2);
          document.removeEventListener("focusout", handleFocusOut2);
          mutationObserver.disconnect();
        };
      }
    }, [trapped, container, focusScope.paused]);
    React18.useEffect(() => {
      if (container) {
        focusScopesStack.add(focusScope);
        const previouslyFocusedElement = document.activeElement;
        const hasFocusedCandidate = container.contains(previouslyFocusedElement);
        if (!hasFocusedCandidate) {
          const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          container.dispatchEvent(mountEvent);
          if (!mountEvent.defaultPrevented) {
            focusFirst2(removeLinks(getTabbableCandidates2(container)), { select: true });
            if (document.activeElement === previouslyFocusedElement) {
              focus(container);
            }
          }
        }
        return () => {
          container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          setTimeout(() => {
            const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
            container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            container.dispatchEvent(unmountEvent);
            if (!unmountEvent.defaultPrevented) {
              focus(previouslyFocusedElement ?? document.body, { select: true });
            }
            container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            focusScopesStack.remove(focusScope);
          }, 0);
        };
      }
    }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
    const handleKeyDown = React18.useCallback(
      (event) => {
        if (!loop && !trapped) return;
        if (focusScope.paused) return;
        const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
        const focusedElement = document.activeElement;
        if (isTabKey && focusedElement) {
          const container2 = event.currentTarget;
          const [first, last] = getTabbableEdges(container2);
          const hasTabbableElementsInside = first && last;
          if (!hasTabbableElementsInside) {
            if (focusedElement === container2) event.preventDefault();
          } else {
            if (!event.shiftKey && focusedElement === last) {
              event.preventDefault();
              if (loop) focus(first, { select: true });
            } else if (event.shiftKey && focusedElement === first) {
              event.preventDefault();
              if (loop) focus(last, { select: true });
            }
          }
        }
      },
      [loop, trapped, focusScope.paused]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
  });
  FocusScope.displayName = FOCUS_SCOPE_NAME;
  function focusFirst2(candidates, { select = false } = {}) {
    const previouslyFocusedElement = document.activeElement;
    for (const candidate of candidates) {
      focus(candidate, { select });
      if (document.activeElement !== previouslyFocusedElement) return;
    }
  }
  function getTabbableEdges(container) {
    const candidates = getTabbableCandidates2(container);
    const first = findVisible(candidates, container);
    const last = findVisible(candidates.reverse(), container);
    return [first, last];
  }
  function getTabbableCandidates2(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode()) nodes.push(walker.currentNode);
    return nodes;
  }
  function findVisible(elements, container) {
    for (const element of elements) {
      if (!isHidden(element, { upTo: container })) return element;
    }
  }
  function isHidden(node, { upTo }) {
    if (getComputedStyle(node).visibility === "hidden") return true;
    while (node) {
      if (upTo !== void 0 && node === upTo) return false;
      if (getComputedStyle(node).display === "none") return true;
      node = node.parentElement;
    }
    return false;
  }
  function isSelectableInput(element) {
    return element instanceof HTMLInputElement && "select" in element;
  }
  function focus(element, { select = false } = {}) {
    if (element && element.focus) {
      const previouslyFocusedElement = document.activeElement;
      element.focus({ preventScroll: true });
      if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
        element.select();
    }
  }
  var focusScopesStack = createFocusScopesStack();
  function createFocusScopesStack() {
    let stack = [];
    return {
      add(focusScope) {
        const activeFocusScope = stack[0];
        if (focusScope !== activeFocusScope) {
          activeFocusScope?.pause();
        }
        stack = arrayRemove(stack, focusScope);
        stack.unshift(focusScope);
      },
      remove(focusScope) {
        stack = arrayRemove(stack, focusScope);
        stack[0]?.resume();
      }
    };
  }
  function arrayRemove(array, item) {
    const updatedArray = [...array];
    const index2 = updatedArray.indexOf(item);
    if (index2 !== -1) {
      updatedArray.splice(index2, 1);
    }
    return updatedArray;
  }
  function removeLinks(items) {
    return items.filter((item) => item.tagName !== "A");
  }

  // ../../node_modules/.pnpm/@radix-ui+react-focus-guards@1.1.0_@types+react@18.0.25_react@18.2.0/node_modules/@radix-ui/react-focus-guards/dist/index.mjs
  var React19 = __toESM(require_react(), 1);
  var count2 = 0;
  function useFocusGuards() {
    React19.useEffect(() => {
      const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
      document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
      document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
      count2++;
      return () => {
        if (count2 === 1) {
          document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
        }
        count2--;
      };
    }, []);
  }
  function createFocusGuard() {
    const element = document.createElement("span");
    element.setAttribute("data-radix-focus-guard", "");
    element.tabIndex = 0;
    element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
    return element;
  }

  // ../../node_modules/.pnpm/tslib@2.6.3/node_modules/tslib/tslib.es6.mjs
  var __assign = function() {
    __assign = Object.assign || function __assign2(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  }
  function __spreadArray(to, from6, pack) {
    if (pack || arguments.length === 2) for (var i2 = 0, l2 = from6.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from6)) {
        if (!ar) ar = Array.prototype.slice.call(from6, 0, i2);
        ar[i2] = from6[i2];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from6));
  }

  // ../../node_modules/.pnpm/react-remove-scroll@2.5.7_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/Combination.js
  var React27 = __toESM(require_react());

  // ../../node_modules/.pnpm/react-remove-scroll@2.5.7_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/UI.js
  var React23 = __toESM(require_react());

  // ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.6_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll-bar/dist/es2015/constants.js
  var zeroRightClassName = "right-scroll-bar-position";
  var fullWidthClassName = "width-before-scroll-bar";
  var noScrollbarsClassName = "with-scroll-bars-hidden";
  var removedBarSizeVariable = "--removed-body-scroll-bar-size";

  // ../../node_modules/.pnpm/use-callback-ref@1.3.2_@types+react@18.0.25_react@18.2.0/node_modules/use-callback-ref/dist/es2015/assignRef.js
  function assignRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
    return ref;
  }

  // ../../node_modules/.pnpm/use-callback-ref@1.3.2_@types+react@18.0.25_react@18.2.0/node_modules/use-callback-ref/dist/es2015/useRef.js
  var import_react31 = __toESM(require_react());
  function useCallbackRef2(initialValue, callback) {
    var ref = (0, import_react31.useState)(function() {
      return {
        // value
        value: initialValue,
        // last callback
        callback,
        // "memoized" public interface
        facade: {
          get current() {
            return ref.value;
          },
          set current(value) {
            var last = ref.value;
            if (last !== value) {
              ref.value = value;
              ref.callback(value, last);
            }
          }
        }
      };
    })[0];
    ref.callback = callback;
    return ref.facade;
  }

  // ../../node_modules/.pnpm/use-callback-ref@1.3.2_@types+react@18.0.25_react@18.2.0/node_modules/use-callback-ref/dist/es2015/useMergeRef.js
  var React20 = __toESM(require_react());
  var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? React20.useLayoutEffect : React20.useEffect;
  var currentValues = /* @__PURE__ */ new WeakMap();
  function useMergeRefs(refs, defaultValue) {
    var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
      return refs.forEach(function(ref) {
        return assignRef(ref, newValue);
      });
    });
    useIsomorphicLayoutEffect2(function() {
      var oldValue = currentValues.get(callbackRef);
      if (oldValue) {
        var prevRefs_1 = new Set(oldValue);
        var nextRefs_1 = new Set(refs);
        var current_1 = callbackRef.current;
        prevRefs_1.forEach(function(ref) {
          if (!nextRefs_1.has(ref)) {
            assignRef(ref, null);
          }
        });
        nextRefs_1.forEach(function(ref) {
          if (!prevRefs_1.has(ref)) {
            assignRef(ref, current_1);
          }
        });
      }
      currentValues.set(callbackRef, refs);
    }, [refs]);
    return callbackRef;
  }

  // ../../node_modules/.pnpm/use-sidecar@1.1.2_@types+react@18.0.25_react@18.2.0/node_modules/use-sidecar/dist/es2015/medium.js
  function ItoI(a2) {
    return a2;
  }
  function innerCreateMedium(defaults, middleware) {
    if (middleware === void 0) {
      middleware = ItoI;
    }
    var buffer = [];
    var assigned = false;
    var medium = {
      read: function() {
        if (assigned) {
          throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        }
        if (buffer.length) {
          return buffer[buffer.length - 1];
        }
        return defaults;
      },
      useMedium: function(data) {
        var item = middleware(data, assigned);
        buffer.push(item);
        return function() {
          buffer = buffer.filter(function(x2) {
            return x2 !== item;
          });
        };
      },
      assignSyncMedium: function(cb) {
        assigned = true;
        while (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
        }
        buffer = {
          push: function(x2) {
            return cb(x2);
          },
          filter: function() {
            return buffer;
          }
        };
      },
      assignMedium: function(cb) {
        assigned = true;
        var pendingQueue = [];
        if (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
          pendingQueue = buffer;
        }
        var executeQueue = function() {
          var cbs2 = pendingQueue;
          pendingQueue = [];
          cbs2.forEach(cb);
        };
        var cycle = function() {
          return Promise.resolve().then(executeQueue);
        };
        cycle();
        buffer = {
          push: function(x2) {
            pendingQueue.push(x2);
            cycle();
          },
          filter: function(filter2) {
            pendingQueue = pendingQueue.filter(filter2);
            return buffer;
          }
        };
      }
    };
    return medium;
  }
  function createSidecarMedium(options) {
    if (options === void 0) {
      options = {};
    }
    var medium = innerCreateMedium(null);
    medium.options = __assign({ async: true, ssr: false }, options);
    return medium;
  }

  // ../../node_modules/.pnpm/use-sidecar@1.1.2_@types+react@18.0.25_react@18.2.0/node_modules/use-sidecar/dist/es2015/exports.js
  var React21 = __toESM(require_react());
  var SideCar = function(_a) {
    var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
    if (!sideCar) {
      throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    }
    var Target = sideCar.read();
    if (!Target) {
      throw new Error("Sidecar medium not found");
    }
    return React21.createElement(Target, __assign({}, rest));
  };
  SideCar.isSideCarExport = true;
  function exportSidecar(medium, exported) {
    medium.useMedium(exported);
    return SideCar;
  }

  // ../../node_modules/.pnpm/react-remove-scroll@2.5.7_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/medium.js
  var effectCar = createSidecarMedium();

  // ../../node_modules/.pnpm/react-remove-scroll@2.5.7_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/UI.js
  var nothing = function() {
    return;
  };
  var RemoveScroll = React23.forwardRef(function(props, parentRef) {
    var ref = React23.useRef(null);
    var _a = React23.useState({
      onScrollCapture: nothing,
      onWheelCapture: nothing,
      onTouchMoveCapture: nothing
    }), callbacks = _a[0], setCallbacks = _a[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
    var SideCar2 = sideCar;
    var containerRef = useMergeRefs([ref, parentRef]);
    var containerProps = __assign(__assign({}, rest), callbacks);
    return React23.createElement(
      React23.Fragment,
      null,
      enabled && React23.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
      forwardProps ? React23.cloneElement(React23.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React23.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
    );
  });
  RemoveScroll.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false
  };
  RemoveScroll.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
  };

  // ../../node_modules/.pnpm/react-remove-scroll@2.5.7_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
  var React26 = __toESM(require_react());

  // ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.6_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll-bar/dist/es2015/component.js
  var React25 = __toESM(require_react());

  // ../../node_modules/.pnpm/react-style-singleton@2.2.1_@types+react@18.0.25_react@18.2.0/node_modules/react-style-singleton/dist/es2015/hook.js
  var React24 = __toESM(require_react());

  // ../../node_modules/.pnpm/get-nonce@1.0.1/node_modules/get-nonce/dist/es2015/index.js
  var currentNonce;
  var getNonce = function() {
    if (currentNonce) {
      return currentNonce;
    }
    if (typeof __webpack_nonce__ !== "undefined") {
      return __webpack_nonce__;
    }
    return void 0;
  };

  // ../../node_modules/.pnpm/react-style-singleton@2.2.1_@types+react@18.0.25_react@18.2.0/node_modules/react-style-singleton/dist/es2015/singleton.js
  function makeStyleTag() {
    if (!document)
      return null;
    var tag = document.createElement("style");
    tag.type = "text/css";
    var nonce = getNonce();
    if (nonce) {
      tag.setAttribute("nonce", nonce);
    }
    return tag;
  }
  function injectStyles(tag, css) {
    if (tag.styleSheet) {
      tag.styleSheet.cssText = css;
    } else {
      tag.appendChild(document.createTextNode(css));
    }
  }
  function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName("head")[0];
    head.appendChild(tag);
  }
  var stylesheetSingleton = function() {
    var counter = 0;
    var stylesheet = null;
    return {
      add: function(style) {
        if (counter == 0) {
          if (stylesheet = makeStyleTag()) {
            injectStyles(stylesheet, style);
            insertStyleTag(stylesheet);
          }
        }
        counter++;
      },
      remove: function() {
        counter--;
        if (!counter && stylesheet) {
          stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
          stylesheet = null;
        }
      }
    };
  };

  // ../../node_modules/.pnpm/react-style-singleton@2.2.1_@types+react@18.0.25_react@18.2.0/node_modules/react-style-singleton/dist/es2015/hook.js
  var styleHookSingleton = function() {
    var sheet = stylesheetSingleton();
    return function(styles, isDynamic) {
      React24.useEffect(function() {
        sheet.add(styles);
        return function() {
          sheet.remove();
        };
      }, [styles && isDynamic]);
    };
  };

  // ../../node_modules/.pnpm/react-style-singleton@2.2.1_@types+react@18.0.25_react@18.2.0/node_modules/react-style-singleton/dist/es2015/component.js
  var styleSingleton = function() {
    var useStyle2 = styleHookSingleton();
    var Sheet = function(_a) {
      var styles = _a.styles, dynamic = _a.dynamic;
      useStyle2(styles, dynamic);
      return null;
    };
    return Sheet;
  };

  // ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.6_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll-bar/dist/es2015/utils.js
  var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  };
  var parse2 = function(x2) {
    return parseInt(x2 || "", 10) || 0;
  };
  var getOffset = function(gapMode) {
    var cs = window.getComputedStyle(document.body);
    var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
    var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
    var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
    return [parse2(left), parse2(top), parse2(right)];
  };
  var getGapWidth = function(gapMode) {
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    if (typeof window === "undefined") {
      return zeroGap;
    }
    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
      left: offsets[0],
      top: offsets[1],
      right: offsets[2],
      gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
    };
  };

  // ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.6_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll-bar/dist/es2015/component.js
  var Style = styleSingleton();
  var lockAttribute = "data-scroll-locked";
  var getStyles = function(_a, allowRelative, gapMode, important) {
    var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
      allowRelative && "position: relative ".concat(important, ";"),
      gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
      gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
    ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
  };
  var getCurrentUseCounter = function() {
    var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
    return isFinite(counter) ? counter : 0;
  };
  var useLockAttribute = function() {
    React25.useEffect(function() {
      document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
      return function() {
        var newCounter = getCurrentUseCounter() - 1;
        if (newCounter <= 0) {
          document.body.removeAttribute(lockAttribute);
        } else {
          document.body.setAttribute(lockAttribute, newCounter.toString());
        }
      };
    }, []);
  };
  var RemoveScrollBar = function(_a) {
    var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
    useLockAttribute();
    var gap = React25.useMemo(function() {
      return getGapWidth(gapMode);
    }, [gapMode]);
    return React25.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
  };

  // ../../node_modules/.pnpm/react-remove-scroll@2.5.7_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
  var passiveSupported = false;
  if (typeof window !== "undefined") {
    try {
      options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported = true;
          return true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveSupported = false;
    }
  }
  var options;
  var nonPassive = passiveSupported ? { passive: false } : false;

  // ../../node_modules/.pnpm/react-remove-scroll@2.5.7_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/handleScroll.js
  var alwaysContainsScroll = function(node) {
    return node.tagName === "TEXTAREA";
  };
  var elementCanBeScrolled = function(node, overflow) {
    var styles = window.getComputedStyle(node);
    return (
      // not-not-scrollable
      styles[overflow] !== "hidden" && // contains scroll inside self
      !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
    );
  };
  var elementCouldBeVScrolled = function(node) {
    return elementCanBeScrolled(node, "overflowY");
  };
  var elementCouldBeHScrolled = function(node) {
    return elementCanBeScrolled(node, "overflowX");
  };
  var locationCouldBeScrolled = function(axis, node) {
    var ownerDocument = node.ownerDocument;
    var current = node;
    do {
      if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
        current = current.host;
      }
      var isScrollable = elementCouldBeScrolled(axis, current);
      if (isScrollable) {
        var _a = getScrollVariables(axis, current), s2 = _a[1], d2 = _a[2];
        if (s2 > d2) {
          return true;
        }
      }
      current = current.parentNode;
    } while (current && current !== ownerDocument.body);
    return false;
  };
  var getVScrollVariables = function(_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
    return [
      scrollTop,
      scrollHeight,
      clientHeight
    ];
  };
  var getHScrollVariables = function(_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
    return [
      scrollLeft,
      scrollWidth,
      clientWidth
    ];
  };
  var elementCouldBeScrolled = function(axis, node) {
    return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
  };
  var getScrollVariables = function(axis, node) {
    return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
  };
  var getDirectionFactor = function(axis, direction) {
    return axis === "h" && direction === "rtl" ? -1 : 1;
  };
  var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
      var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
      var elementScroll = scroll_1 - capacity - directionFactor * position;
      if (position || elementScroll) {
        if (elementCouldBeScrolled(axis, target)) {
          availableScroll += elementScroll;
          availableScrollTop += position;
        }
      }
      if (target instanceof ShadowRoot) {
        target = target.host;
      } else {
        target = target.parentNode;
      }
    } while (
      // portaled content
      !targetInLock && target !== document.body || // self content
      targetInLock && (endTarget.contains(target) || endTarget === target)
    );
    if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
      shouldCancelScroll = true;
    } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
      shouldCancelScroll = true;
    }
    return shouldCancelScroll;
  };

  // ../../node_modules/.pnpm/react-remove-scroll@2.5.7_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
  var getTouchXY = function(event) {
    return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
  };
  var getDeltaXY = function(event) {
    return [event.deltaX, event.deltaY];
  };
  var extractRef = function(ref) {
    return ref && "current" in ref ? ref.current : ref;
  };
  var deltaCompare = function(x2, y2) {
    return x2[0] === y2[0] && x2[1] === y2[1];
  };
  var generateStyle = function(id3) {
    return "\n  .block-interactivity-".concat(id3, " {pointer-events: none;}\n  .allow-interactivity-").concat(id3, " {pointer-events: all;}\n");
  };
  var idCounter = 0;
  var lockStack = [];
  function RemoveScrollSideCar(props) {
    var shouldPreventQueue = React26.useRef([]);
    var touchStartRef = React26.useRef([0, 0]);
    var activeAxis = React26.useRef();
    var id3 = React26.useState(idCounter++)[0];
    var Style2 = React26.useState(styleSingleton)[0];
    var lastProps = React26.useRef(props);
    React26.useEffect(function() {
      lastProps.current = props;
    }, [props]);
    React26.useEffect(function() {
      if (props.inert) {
        document.body.classList.add("block-interactivity-".concat(id3));
        var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
        allow_1.forEach(function(el) {
          return el.classList.add("allow-interactivity-".concat(id3));
        });
        return function() {
          document.body.classList.remove("block-interactivity-".concat(id3));
          allow_1.forEach(function(el) {
            return el.classList.remove("allow-interactivity-".concat(id3));
          });
        };
      }
      return;
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = React26.useCallback(function(event, parent) {
      if ("touches" in event && event.touches.length === 2) {
        return !lastProps.current.allowPinchZoom;
      }
      var touch = getTouchXY(event);
      var touchStart = touchStartRef.current;
      var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
      var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
      var currentAxis;
      var target = event.target;
      var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
      if ("touches" in event && moveDirection === "h" && target.type === "range") {
        return false;
      }
      var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      if (!canBeScrolledInMainDirection) {
        return true;
      }
      if (canBeScrolledInMainDirection) {
        currentAxis = moveDirection;
      } else {
        currentAxis = moveDirection === "v" ? "h" : "v";
        canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      }
      if (!canBeScrolledInMainDirection) {
        return false;
      }
      if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
        activeAxis.current = currentAxis;
      }
      if (!currentAxis) {
        return true;
      }
      var cancelingAxis = activeAxis.current || currentAxis;
      return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
    }, []);
    var shouldPrevent = React26.useCallback(function(_event) {
      var event = _event;
      if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
        return;
      }
      var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
      var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
        return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
      })[0];
      if (sourceEvent && sourceEvent.should) {
        if (event.cancelable) {
          event.preventDefault();
        }
        return;
      }
      if (!sourceEvent) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
          return node.contains(event.target);
        });
        var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        if (shouldStop) {
          if (event.cancelable) {
            event.preventDefault();
          }
        }
      }
    }, []);
    var shouldCancel = React26.useCallback(function(name, delta, target, should) {
      var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
      shouldPreventQueue.current.push(event);
      setTimeout(function() {
        shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
          return e2 !== event;
        });
      }, 1);
    }, []);
    var scrollTouchStart = React26.useCallback(function(event) {
      touchStartRef.current = getTouchXY(event);
      activeAxis.current = void 0;
    }, []);
    var scrollWheel = React26.useCallback(function(event) {
      shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    var scrollTouchMove = React26.useCallback(function(event) {
      shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    React26.useEffect(function() {
      lockStack.push(Style2);
      props.setCallbacks({
        onScrollCapture: scrollWheel,
        onWheelCapture: scrollWheel,
        onTouchMoveCapture: scrollTouchMove
      });
      document.addEventListener("wheel", shouldPrevent, nonPassive);
      document.addEventListener("touchmove", shouldPrevent, nonPassive);
      document.addEventListener("touchstart", scrollTouchStart, nonPassive);
      return function() {
        lockStack = lockStack.filter(function(inst) {
          return inst !== Style2;
        });
        document.removeEventListener("wheel", shouldPrevent, nonPassive);
        document.removeEventListener("touchmove", shouldPrevent, nonPassive);
        document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
      };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return React26.createElement(
      React26.Fragment,
      null,
      inert ? React26.createElement(Style2, { styles: generateStyle(id3) }) : null,
      removeScrollBar ? React26.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
    );
  }
  function getOutermostShadowParent(node) {
    var shadowParent = null;
    while (node !== null) {
      if (node instanceof ShadowRoot) {
        shadowParent = node.host;
        node = node.host;
      }
      node = node.parentNode;
    }
    return shadowParent;
  }

  // ../../node_modules/.pnpm/react-remove-scroll@2.5.7_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/sidecar.js
  var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

  // ../../node_modules/.pnpm/react-remove-scroll@2.5.7_@types+react@18.0.25_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/Combination.js
  var ReactRemoveScroll = React27.forwardRef(function(props, ref) {
    return React27.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
  });
  ReactRemoveScroll.classNames = RemoveScroll.classNames;
  var Combination_default = ReactRemoveScroll;

  // ../../node_modules/.pnpm/aria-hidden@1.2.4/node_modules/aria-hidden/dist/es2015/index.js
  var getDefaultParent = function(originalTarget) {
    if (typeof document === "undefined") {
      return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
  };
  var counterMap = /* @__PURE__ */ new WeakMap();
  var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
  var markerMap = {};
  var lockCount = 0;
  var unwrapHost = function(node) {
    return node && (node.host || unwrapHost(node.parentNode));
  };
  var correctTargets = function(parent, targets) {
    return targets.map(function(target) {
      if (parent.contains(target)) {
        return target;
      }
      var correctedTarget = unwrapHost(target);
      if (correctedTarget && parent.contains(correctedTarget)) {
        return correctedTarget;
      }
      console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
      return null;
    }).filter(function(x2) {
      return Boolean(x2);
    });
  };
  var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    if (!markerMap[markerName]) {
      markerMap[markerName] = /* @__PURE__ */ new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = /* @__PURE__ */ new Set();
    var elementsToStop = new Set(targets);
    var keep = function(el) {
      if (!el || elementsToKeep.has(el)) {
        return;
      }
      elementsToKeep.add(el);
      keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function(parent) {
      if (!parent || elementsToStop.has(parent)) {
        return;
      }
      Array.prototype.forEach.call(parent.children, function(node) {
        if (elementsToKeep.has(node)) {
          deep(node);
        } else {
          try {
            var attr = node.getAttribute(controlAttribute);
            var alreadyHidden = attr !== null && attr !== "false";
            var counterValue = (counterMap.get(node) || 0) + 1;
            var markerValue = (markerCounter.get(node) || 0) + 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            hiddenNodes.push(node);
            if (counterValue === 1 && alreadyHidden) {
              uncontrolledNodes.set(node, true);
            }
            if (markerValue === 1) {
              node.setAttribute(markerName, "true");
            }
            if (!alreadyHidden) {
              node.setAttribute(controlAttribute, "true");
            }
          } catch (e2) {
            console.error("aria-hidden: cannot operate on ", node, e2);
          }
        }
      });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function() {
      hiddenNodes.forEach(function(node) {
        var counterValue = counterMap.get(node) - 1;
        var markerValue = markerCounter.get(node) - 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        if (!counterValue) {
          if (!uncontrolledNodes.has(node)) {
            node.removeAttribute(controlAttribute);
          }
          uncontrolledNodes.delete(node);
        }
        if (!markerValue) {
          node.removeAttribute(markerName);
        }
      });
      lockCount--;
      if (!lockCount) {
        counterMap = /* @__PURE__ */ new WeakMap();
        counterMap = /* @__PURE__ */ new WeakMap();
        uncontrolledNodes = /* @__PURE__ */ new WeakMap();
        markerMap = {};
      }
    };
  };
  var hideOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
      markerName = "data-aria-hidden";
    }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
      return function() {
        return null;
      };
    }
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
    return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
  };

  // ../../node_modules/.pnpm/@radix-ui+react-dialog@1.1.1_@types+react-dom@18.0.9_@types+react@18.0.25_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@radix-ui/react-dialog/dist/index.mjs
  var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
  var DIALOG_NAME = "Dialog";
  var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
  var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
  var Dialog = (props) => {
    const {
      __scopeDialog,
      children,
      open: openProp,
      defaultOpen,
      onOpenChange,
      modal = true
    } = props;
    const triggerRef = React28.useRef(null);
    const contentRef = React28.useRef(null);
    const [open2 = false, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
      DialogProvider,
      {
        scope: __scopeDialog,
        triggerRef,
        contentRef,
        contentId: useId4(),
        titleId: useId4(),
        descriptionId: useId4(),
        open: open2,
        onOpenChange: setOpen,
        onOpenToggle: React28.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        modal,
        children
      }
    );
  };
  Dialog.displayName = DIALOG_NAME;
  var TRIGGER_NAME = "DialogTrigger";
  var DialogTrigger = React28.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...triggerProps } = props;
      const context = useDialogContext(TRIGGER_NAME, __scopeDialog);
      const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
      return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        Primitive.button,
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": context.open,
          "aria-controls": context.contentId,
          "data-state": getState(context.open),
          ...triggerProps,
          ref: composedTriggerRef,
          onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
        }
      );
    }
  );
  DialogTrigger.displayName = TRIGGER_NAME;
  var PORTAL_NAME2 = "DialogPortal";
  var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME2, {
    forceMount: void 0
  });
  var DialogPortal = (props) => {
    const { __scopeDialog, forceMount, children, container } = props;
    const context = useDialogContext(PORTAL_NAME2, __scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: React28.Children.map(children, (child) => /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Portal, { asChild: true, container, children: child }) })) });
  };
  DialogPortal.displayName = PORTAL_NAME2;
  var OVERLAY_NAME = "DialogOverlay";
  var DialogOverlay = React28.forwardRef(
    (props, forwardedRef) => {
      const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
      const { forceMount = portalContext.forceMount, ...overlayProps } = props;
      const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
      return context.modal ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
    }
  );
  DialogOverlay.displayName = OVERLAY_NAME;
  var DialogOverlayImpl = React28.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...overlayProps } = props;
      const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
      return (
        // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
        // ie. when `Overlay` and `Content` are siblings
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
          Primitive.div,
          {
            "data-state": getState(context.open),
            ...overlayProps,
            ref: forwardedRef,
            style: { pointerEvents: "auto", ...overlayProps.style }
          }
        ) })
      );
    }
  );
  var CONTENT_NAME = "DialogContent";
  var DialogContent = React28.forwardRef(
    (props, forwardedRef) => {
      const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);
      const { forceMount = portalContext.forceMount, ...contentProps } = props;
      const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
      return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
    }
  );
  DialogContent.displayName = CONTENT_NAME;
  var DialogContentModal = React28.forwardRef(
    (props, forwardedRef) => {
      const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
      const contentRef = React28.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
      React28.useEffect(() => {
        const content = contentRef.current;
        if (content) return hideOthers(content);
      }, []);
      return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        DialogContentImpl,
        {
          ...props,
          ref: composedRefs,
          trapFocus: context.open,
          disableOutsidePointerEvents: true,
          onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
            event.preventDefault();
            context.triggerRef.current?.focus();
          }),
          onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            if (isRightClick) event.preventDefault();
          }),
          onFocusOutside: composeEventHandlers(
            props.onFocusOutside,
            (event) => event.preventDefault()
          )
        }
      );
    }
  );
  var DialogContentNonModal = React28.forwardRef(
    (props, forwardedRef) => {
      const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
      const hasInteractedOutsideRef = React28.useRef(false);
      const hasPointerDownOutsideRef = React28.useRef(false);
      return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        DialogContentImpl,
        {
          ...props,
          ref: forwardedRef,
          trapFocus: false,
          disableOutsidePointerEvents: false,
          onCloseAutoFocus: (event) => {
            props.onCloseAutoFocus?.(event);
            if (!event.defaultPrevented) {
              if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
              event.preventDefault();
            }
            hasInteractedOutsideRef.current = false;
            hasPointerDownOutsideRef.current = false;
          },
          onInteractOutside: (event) => {
            props.onInteractOutside?.(event);
            if (!event.defaultPrevented) {
              hasInteractedOutsideRef.current = true;
              if (event.detail.originalEvent.type === "pointerdown") {
                hasPointerDownOutsideRef.current = true;
              }
            }
            const target = event.target;
            const targetIsTrigger = context.triggerRef.current?.contains(target);
            if (targetIsTrigger) event.preventDefault();
            if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
              event.preventDefault();
            }
          }
        }
      );
    }
  );
  var DialogContentImpl = React28.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
      const context = useDialogContext(CONTENT_NAME, __scopeDialog);
      const contentRef = React28.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, contentRef);
      useFocusGuards();
      return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
          FocusScope,
          {
            asChild: true,
            loop: true,
            trapped: trapFocus,
            onMountAutoFocus: onOpenAutoFocus,
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
              DismissableLayer,
              {
                role: "dialog",
                id: context.contentId,
                "aria-describedby": context.descriptionId,
                "aria-labelledby": context.titleId,
                "data-state": getState(context.open),
                ...contentProps,
                ref: composedRefs,
                onDismiss: () => context.onOpenChange(false)
              }
            )
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(TitleWarning, { titleId: context.titleId }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
        ] })
      ] });
    }
  );
  var TITLE_NAME2 = "DialogTitle";
  var DialogTitle = React28.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...titleProps } = props;
      const context = useDialogContext(TITLE_NAME2, __scopeDialog);
      return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
    }
  );
  DialogTitle.displayName = TITLE_NAME2;
  var DESCRIPTION_NAME2 = "DialogDescription";
  var DialogDescription = React28.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...descriptionProps } = props;
      const context = useDialogContext(DESCRIPTION_NAME2, __scopeDialog);
      return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
    }
  );
  DialogDescription.displayName = DESCRIPTION_NAME2;
  var CLOSE_NAME2 = "DialogClose";
  var DialogClose = React28.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...closeProps } = props;
      const context = useDialogContext(CLOSE_NAME2, __scopeDialog);
      return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        Primitive.button,
        {
          type: "button",
          ...closeProps,
          ref: forwardedRef,
          onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
        }
      );
    }
  );
  DialogClose.displayName = CLOSE_NAME2;
  function getState(open2) {
    return open2 ? "open" : "closed";
  }
  var TITLE_WARNING_NAME = "DialogTitleWarning";
  var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
    contentName: CONTENT_NAME,
    titleName: TITLE_NAME2,
    docsSlug: "dialog"
  });
  var TitleWarning = ({ titleId }) => {
    const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
    const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
    React28.useEffect(() => {
      if (titleId) {
        const hasTitle = document.getElementById(titleId);
        if (!hasTitle) console.error(MESSAGE);
      }
    }, [MESSAGE, titleId]);
    return null;
  };
  var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
  var DescriptionWarning = ({ contentRef, descriptionId }) => {
    const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
    const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
    React28.useEffect(() => {
      const describedById = contentRef.current?.getAttribute("aria-describedby");
      if (descriptionId && describedById) {
        const hasDescription = document.getElementById(descriptionId);
        if (!hasDescription) console.warn(MESSAGE);
      }
    }, [MESSAGE, contentRef, descriptionId]);
    return null;
  };
  var Root2 = Dialog;
  var Portal2 = DialogPortal;
  var Overlay = DialogOverlay;
  var Content = DialogContent;
  var Close = DialogClose;

  // ../react/build/index.js
  var import_react38 = __toESM(require_react(), 1);
  var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
  var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);

  // ../../node_modules/.pnpm/browser-or-node@3.0.0-pre.0/node_modules/browser-or-node/dist/index.mjs
  var isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined";
  var isNode = (
    // @ts-expect-error
    typeof process !== "undefined" && // @ts-expect-error
    process.versions != null && // @ts-expect-error
    process.versions.node != null
  );
  var isWebWorker = typeof self === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
  var isJsDom = typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && "userAgent" in navigator && typeof navigator.userAgent === "string" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
  var isDeno = (
    // @ts-expect-error
    typeof Deno !== "undefined" && // @ts-expect-error
    typeof Deno.version !== "undefined" && // @ts-expect-error
    typeof Deno.version.deno !== "undefined"
  );

  // ../react/build/index.js
  var useMedia = () => {
    const getInitialState = () => {
      if (typeof window !== "undefined") {
        return window.matchMedia("(max-width: 768px)").matches ? "mobile" : "desktop";
      }
      return "desktop";
    };
    const [media, setMedia] = (0, import_react34.useState)(getInitialState());
    (0, import_react34.useEffect)(() => {
      const mql = window.matchMedia("(max-width: 768px)");
      const handleChange = (mql2) => setMedia(mql2.matches ? "mobile" : "desktop");
      handleChange(mql);
      mql.addEventListener("change", handleChange);
      return () => {
        mql.removeEventListener("change", handleChange);
      };
    }, []);
    return media;
  };
  var useMedia_default = useMedia;
  var styles_default = `/* TODO: Use an alternative to avoid the extra request to Google (e.g. hosting ourselves, or local file)  */
@import url('https://fonts.googleapis.com/css2?family=Rubik:wght@400;600;700&family=Sora:wght@600&display=swap');
/* ! tailwindcss v3.4.4 | MIT License | https://tailwindcss.com  */
/*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/
*,
::before,
::after {
  box-sizing: border-box; /* 1 */
  border-width: 0; /* 2 */
  border-style: solid; /* 2 */
  border-color: #e5e7eb; /* 2 */
}
::before,
::after {
  --tw-content: '';
}
/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured \`sans\` font-family by default.
5. Use the user's configured \`sans\` font-feature-settings by default.
6. Use the user's configured \`sans\` font-variation-settings by default.
7. Disable tap highlights on iOS
*/
html,
:host {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
  -moz-tab-size: 4; /* 3 */
  -o-tab-size: 4;
     tab-size: 4; /* 3 */
  font-family: Rubik, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
  font-feature-settings: normal; /* 5 */
  font-variation-settings: normal; /* 6 */
  -webkit-tap-highlight-color: transparent; /* 7 */
}
/*
1. Remove the margin in all browsers.
2. Inherit line-height from \`html\` so users can set them as a class directly on the \`html\` element.
*/
body {
  margin: 0; /* 1 */
  line-height: inherit; /* 2 */
}
/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/
hr {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}
/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/
abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}
/*
Remove the default font size and weight for headings.
*/
h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}
/*
Reset links to optimize for opt-in styling instead of opt-out.
*/
a {
  color: inherit;
  text-decoration: inherit;
}
/*
Add the correct font weight in Edge and Safari.
*/
b,
strong {
  font-weight: bolder;
}
/*
1. Use the user's configured \`mono\` font-family by default.
2. Use the user's configured \`mono\` font-feature-settings by default.
3. Use the user's configured \`mono\` font-variation-settings by default.
4. Correct the odd \`em\` font sizing in all browsers.
*/
code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
  font-feature-settings: normal; /* 2 */
  font-variation-settings: normal; /* 3 */
  font-size: 1em; /* 4 */
}
/*
Add the correct font size in all browsers.
*/
small {
  font-size: 80%;
}
/*
Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sub {
  bottom: -0.25em;
}
sup {
  top: -0.5em;
}
/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/
table {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}
/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/
button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-feature-settings: inherit; /* 1 */
  font-variation-settings: inherit; /* 1 */
  font-size: 100%; /* 1 */
  font-weight: inherit; /* 1 */
  line-height: inherit; /* 1 */
  letter-spacing: inherit; /* 1 */
  color: inherit; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 3 */
}
/*
Remove the inheritance of text transform in Edge and Firefox.
*/
button,
select {
  text-transform: none;
}
/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/
button,
input:where([type='button']),
input:where([type='reset']),
input:where([type='submit']) {
  -webkit-appearance: button; /* 1 */
  background-color: transparent; /* 2 */
  background-image: none; /* 2 */
}
/*
Use the modern Firefox focus style for all focusable elements.
*/
:-moz-focusring {
  outline: auto;
}
/*
Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/
:-moz-ui-invalid {
  box-shadow: none;
}
/*
Add the correct vertical alignment in Chrome and Firefox.
*/
progress {
  vertical-align: baseline;
}
/*
Correct the cursor style of increment and decrement buttons in Safari.
*/
::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}
/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/
[type='search'] {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}
/*
Remove the inner padding in Chrome and Safari on macOS.
*/
::-webkit-search-decoration {
  -webkit-appearance: none;
}
/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to \`inherit\` in Safari.
*/
::-webkit-file-upload-button {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}
/*
Add the correct display in Chrome and Safari.
*/
summary {
  display: list-item;
}
/*
Removes the default spacing and border for appropriate elements.
*/
blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}
fieldset {
  margin: 0;
  padding: 0;
}
legend {
  padding: 0;
}
ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}
/*
Reset default styling for dialogs.
*/
dialog {
  padding: 0;
}
/*
Prevent resizing textareas horizontally by default.
*/
textarea {
  resize: vertical;
}
/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/
input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}
input::placeholder,
textarea::placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}
/*
Set the default cursor for buttons.
*/
button,
[role="button"] {
  cursor: pointer;
}
/*
Make sure disabled buttons don't get the pointer cursor.
*/
:disabled {
  cursor: default;
}
/*
1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/
img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}
/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/
img,
video {
  max-width: 100%;
  height: auto;
}
/* Make elements with the HTML hidden attribute stay hidden by default */
[hidden] {
  display: none;
}
[type='text'],input:where(:not([type])),[type='email'],[type='url'],[type='password'],[type='number'],[type='date'],[type='datetime-local'],[type='month'],[type='search'],[type='tel'],[type='time'],[type='week'],[multiple],textarea,select{
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  background-color: #fff;
  border-color: #6b7280;
  border-width: 1px;
  border-radius: 0px;
  padding-top: 0.5rem;
  padding-right: 0.75rem;
  padding-bottom: 0.5rem;
  padding-left: 0.75rem;
  font-size: 1rem;
  line-height: 1.5rem;
  --tw-shadow: 0 0 #0000;
}
[type='text']:focus, input:where(:not([type])):focus, [type='email']:focus, [type='url']:focus, [type='password']:focus, [type='number']:focus, [type='date']:focus, [type='datetime-local']:focus, [type='month']:focus, [type='search']:focus, [type='tel']:focus, [type='time']:focus, [type='week']:focus, [multiple]:focus, textarea:focus, select:focus{
  outline: 2px solid transparent;
  outline-offset: 2px;
  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: #2563eb;
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  border-color: #2563eb;
}
input::-moz-placeholder, textarea::-moz-placeholder{
  color: #6b7280;
  opacity: 1;
}
input::placeholder,textarea::placeholder{
  color: #6b7280;
  opacity: 1;
}
::-webkit-datetime-edit-fields-wrapper{
  padding: 0;
}
::-webkit-date-and-time-value{
  min-height: 1.5em;
  text-align: inherit;
}
::-webkit-datetime-edit{
  display: inline-flex;
}
::-webkit-datetime-edit,::-webkit-datetime-edit-year-field,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute-field,::-webkit-datetime-edit-second-field,::-webkit-datetime-edit-millisecond-field,::-webkit-datetime-edit-meridiem-field{
  padding-top: 0;
  padding-bottom: 0;
}
select{
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
  background-position: right 0.5rem center;
  background-repeat: no-repeat;
  background-size: 1.5em 1.5em;
  padding-right: 2.5rem;
  -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
}
[multiple],[size]:where(select:not([size="1"])){
  background-image: initial;
  background-position: initial;
  background-repeat: unset;
  background-size: initial;
  padding-right: 0.75rem;
  -webkit-print-color-adjust: unset;
          print-color-adjust: unset;
}
[type='checkbox'],[type='radio']{
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  padding: 0;
  -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
  display: inline-block;
  vertical-align: middle;
  background-origin: border-box;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
  flex-shrink: 0;
  height: 1rem;
  width: 1rem;
  color: #2563eb;
  background-color: #fff;
  border-color: #6b7280;
  border-width: 1px;
  --tw-shadow: 0 0 #0000;
}
[type='checkbox']{
  border-radius: 0px;
}
[type='radio']{
  border-radius: 100%;
}
[type='checkbox']:focus,[type='radio']:focus{
  outline: 2px solid transparent;
  outline-offset: 2px;
  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);
  --tw-ring-offset-width: 2px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: #2563eb;
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
}
[type='checkbox']:checked,[type='radio']:checked{
  border-color: transparent;
  background-color: currentColor;
  background-size: 100% 100%;
  background-position: center;
  background-repeat: no-repeat;
}
[type='checkbox']:checked{
  background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e");
}
@media (forced-colors: active) {
  [type='checkbox']:checked{
    -webkit-appearance: auto;
       -moz-appearance: auto;
            appearance: auto;
  }
}
[type='radio']:checked{
  background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3ccircle cx='8' cy='8' r='3'/%3e%3c/svg%3e");
}
@media (forced-colors: active) {
  [type='radio']:checked{
    -webkit-appearance: auto;
       -moz-appearance: auto;
            appearance: auto;
  }
}
[type='checkbox']:checked:hover,[type='checkbox']:checked:focus,[type='radio']:checked:hover,[type='radio']:checked:focus{
  border-color: transparent;
  background-color: currentColor;
}
[type='checkbox']:indeterminate{
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 16 16'%3e%3cpath stroke='white' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M4 8h8'/%3e%3c/svg%3e");
  border-color: transparent;
  background-color: currentColor;
  background-size: 100% 100%;
  background-position: center;
  background-repeat: no-repeat;
}
@media (forced-colors: active) {
  [type='checkbox']:indeterminate{
    -webkit-appearance: auto;
       -moz-appearance: auto;
            appearance: auto;
  }
}
[type='checkbox']:indeterminate:hover,[type='checkbox']:indeterminate:focus{
  border-color: transparent;
  background-color: currentColor;
}
[type='file']{
  background: unset;
  border-color: inherit;
  border-width: 0;
  border-radius: 0;
  padding: 0;
  font-size: unset;
  line-height: inherit;
}
[type='file']:focus{
  outline: 1px solid ButtonText;
  outline: 1px auto -webkit-focus-ring-color;
}
*, ::before, ::after{
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}
::backdrop{
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}
.container{
  width: 100%;
}
@media (min-width: 414px){
  .container{
    max-width: 414px;
  }
}
@media (min-width: 640px){
  .container{
    max-width: 640px;
  }
}
@media (min-width: 768px){
  .container{
    max-width: 768px;
  }
}
@media (min-width: 1024px){
  .container{
    max-width: 1024px;
  }
}
@media (min-width: 1280px){
  .container{
    max-width: 1280px;
  }
}
@media (min-width: 1536px){
  .container{
    max-width: 1536px;
  }
}
.visible{
  visibility: visible;
}
.fixed{
  position: fixed;
}
.absolute{
  position: absolute;
}
.relative{
  position: relative;
}
.inset-0{
  inset: 0;
}
.z-50{
  z-index: 50;
}
.z-\\[9999\\]{
  z-index: 9999;
}
.mx-6{
  margin-left: 24px;
  margin-right: 24px;
}
.mx-auto{
  margin-left: auto;
  margin-right: auto;
}
.-mt-5{
  margin-top: -20px;
}
.-mt-6{
  margin-top: -24px;
}
.mb-10{
  margin-bottom: 40px;
}
.mb-12{
  margin-bottom: 48px;
}
.mb-3{
  margin-bottom: 12px;
}
.mb-4{
  margin-bottom: 16px;
}
.mb-6{
  margin-bottom: 24px;
}
.mr-1{
  margin-right: 4px;
}
.mr-1\\.5{
  margin-right: 6px;
}
.mt-2{
  margin-top: 8px;
}
.mt-3{
  margin-top: 12px;
}
.mt-4{
  margin-top: 16px;
}
.inline{
  display: inline;
}
.flex{
  display: flex;
}
.inline-flex{
  display: inline-flex;
}
.hidden{
  display: none;
}
.size-11{
  width: 44px;
  height: 44px;
}
.size-24{
  width: 96px;
  height: 96px;
}
.size-5{
  width: 20px;
  height: 20px;
}
.size-6{
  width: 24px;
  height: 24px;
}
.size-\\[244px\\]{
  width: 244px;
  height: 244px;
}
.h-10{
  height: 40px;
}
.min-h-full{
  min-height: 100%;
}
.min-h-screen{
  min-height: 100vh;
}
.w-24{
  width: 96px;
}
.w-full{
  width: 100%;
}
.max-w-\\[224px\\]{
  max-width: 224px;
}
.flex-1{
  flex: 1 1 0%;
}
@keyframes pulse{
  50%{
    opacity: .5;
  }
}
.animate-pulse{
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}
@keyframes spin{
  to{
    transform: rotate(360deg);
  }
}
.animate-spin{
  animation: spin 1s linear infinite;
}
.cursor-pointer{
  cursor: pointer;
}
.flex-col{
  flex-direction: column;
}
.items-end{
  align-items: flex-end;
}
.items-center{
  align-items: center;
}
.justify-center{
  justify-content: center;
}
.justify-between{
  justify-content: space-between;
}
.space-x-2 > :not([hidden]) ~ :not([hidden]){
  --tw-space-x-reverse: 0;
  margin-right: calc(8px * var(--tw-space-x-reverse));
  margin-left: calc(8px * calc(1 - var(--tw-space-x-reverse)));
}
.space-x-4 > :not([hidden]) ~ :not([hidden]){
  --tw-space-x-reverse: 0;
  margin-right: calc(16px * var(--tw-space-x-reverse));
  margin-left: calc(16px * calc(1 - var(--tw-space-x-reverse)));
}
.space-y-10 > :not([hidden]) ~ :not([hidden]){
  --tw-space-y-reverse: 0;
  margin-top: calc(40px * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(40px * var(--tw-space-y-reverse));
}
.space-y-4 > :not([hidden]) ~ :not([hidden]){
  --tw-space-y-reverse: 0;
  margin-top: calc(16px * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(16px * var(--tw-space-y-reverse));
}
.space-y-5 > :not([hidden]) ~ :not([hidden]){
  --tw-space-y-reverse: 0;
  margin-top: calc(20px * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(20px * var(--tw-space-y-reverse));
}
.space-y-6 > :not([hidden]) ~ :not([hidden]){
  --tw-space-y-reverse: 0;
  margin-top: calc(24px * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(24px * var(--tw-space-y-reverse));
}
.space-y-8 > :not([hidden]) ~ :not([hidden]){
  --tw-space-y-reverse: 0;
  margin-top: calc(32px * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(32px * var(--tw-space-y-reverse));
}
.overflow-y-hidden{
  overflow-y: hidden;
}
.rounded-2xl{
  border-radius: 1rem;
}
.rounded-full{
  border-radius: 9999px;
}
.rounded-lg{
  border-radius: 0.5rem;
}
.border{
  border-width: 1px;
}
.border-t{
  border-top-width: 1px;
}
.border-ebecef{
  --tw-border-opacity: 1;
  border-color: rgb(235 236 239 / var(--tw-border-opacity));
}
.border-f1f5f8{
  --tw-border-opacity: 1;
  border-color: rgb(241 245 248 / var(--tw-border-opacity));
}
.border-f5f5f7{
  --tw-border-opacity: 1;
  border-color: rgb(245 245 247 / var(--tw-border-opacity));
}
.border-transparent{
  border-color: transparent;
}
.bg-0d151d{
  --tw-bg-opacity: 1;
  background-color: rgb(13 21 29 / var(--tw-bg-opacity));
}
.bg-black\\/50{
  background-color: rgb(0 0 0 / 0.5);
}
.bg-transparent{
  background-color: transparent;
}
.bg-white{
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}
.p-2{
  padding: 8px;
}
.p-4{
  padding: 16px;
}
.p-7{
  padding: 28px;
}
.px-2{
  padding-left: 8px;
  padding-right: 8px;
}
.px-8{
  padding-left: 32px;
  padding-right: 32px;
}
.py-1{
  padding-top: 4px;
  padding-bottom: 4px;
}
.py-3{
  padding-top: 12px;
  padding-bottom: 12px;
}
.pt-6{
  padding-top: 24px;
}
.text-center{
  text-align: center;
}
.font-sans{
  font-family: Rubik, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.font-sora{
  font-family: Sora, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.text-2xl{
  font-size: 24px;
  line-height: 32px;
}
.text-lg{
  font-size: 18px;
  line-height: 28px;
}
.text-sm{
  font-size: 14px;
  line-height: 20px;
}
.text-xs{
  font-size: 12px;
  line-height: 16px;
}
.font-bold{
  font-weight: 700;
}
.font-medium{
  font-weight: 500;
}
.font-semibold{
  font-weight: 600;
}
.text-0d151d{
  --tw-text-opacity: 1;
  color: rgb(13 21 29 / var(--tw-text-opacity));
}
.text-29343f{
  --tw-text-opacity: 1;
  color: rgb(41 52 63 / var(--tw-text-opacity));
}
.text-3c424b{
  --tw-text-opacity: 1;
  color: rgb(60 66 75 / var(--tw-text-opacity));
}
.text-657080{
  --tw-text-opacity: 1;
  color: rgb(101 112 128 / var(--tw-text-opacity));
}
.text-70868f{
  --tw-text-opacity: 1;
  color: rgb(112 134 143 / var(--tw-text-opacity));
}
.text-9ba3ae{
  --tw-text-opacity: 1;
  color: rgb(155 163 174 / var(--tw-text-opacity));
}
.text-9eafc0{
  --tw-text-opacity: 1;
  color: rgb(158 175 192 / var(--tw-text-opacity));
}
.text-black{
  --tw-text-opacity: 1;
  color: rgb(0 0 0 / var(--tw-text-opacity));
}
.text-gray-900{
  --tw-text-opacity: 1;
  color: rgb(17 24 39 / var(--tw-text-opacity));
}
.text-red-500{
  --tw-text-opacity: 1;
  color: rgb(239 68 68 / var(--tw-text-opacity));
}
.text-white{
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}
.opacity-40{
  opacity: 0.4;
}
.shadow{
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.shadow-sm{
  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.blur-lg{
  --tw-blur: blur(16px);
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.filter{
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.backdrop-blur-lg{
  --tw-backdrop-blur: blur(16px);
  -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
          backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
}
.transition{
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.duration-300{
  transition-duration: 300ms;
}
.duration-500{
  transition-duration: 500ms;
}
.ease-in-out{
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}
input[type='number']::-webkit-inner-spin-button,
	input[type='number']::-webkit-outer-spin-button{
  -webkit-appearance: none;
          appearance: none;
}
.hover\\:underline:hover{
  text-decoration-line: underline;
}
.hover\\:shadow:hover{
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.focus\\:outline-none:focus{
  outline: 2px solid transparent;
  outline-offset: 2px;
}
.focus\\:ring-2:focus{
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus\\:ring-indigo-500:focus{
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(99 102 241 / var(--tw-ring-opacity));
}
.focus\\:ring-offset-2:focus{
  --tw-ring-offset-width: 2px;
}
.focus-visible\\:ring:focus-visible{
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus-visible\\:ring-purple-500\\/75:focus-visible{
  --tw-ring-color: rgb(168 85 247 / 0.75);
}
.disabled\\:cursor-not-allowed:disabled{
  cursor: not-allowed;
}
.disabled\\:opacity-40:disabled{
  opacity: 0.4;
}
@media (prefers-reduced-motion: reduce){
  @keyframes spin{
    to{
      transform: rotate(360deg);
    }
  }
  .motion-reduce\\:animate-\\[spin_1\\.5s_linear_infinite\\]{
    animation: spin 1.5s linear infinite;
  }
}
.dark\\:border-f1f5f8\\/10:is(.dark *){
  border-color: rgb(241 245 248 / 0.1);
}
.dark\\:bg-0d151d:is(.dark *){
  --tw-bg-opacity: 1;
  background-color: rgb(13 21 29 / var(--tw-bg-opacity));
}
.dark\\:bg-white:is(.dark *){
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}
.dark\\:text-0d151d:is(.dark *){
  --tw-text-opacity: 1;
  color: rgb(13 21 29 / var(--tw-text-opacity));
}
.dark\\:text-9eafc0:is(.dark *){
  --tw-text-opacity: 1;
  color: rgb(158 175 192 / var(--tw-text-opacity));
}
.dark\\:text-white:is(.dark *){
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}
@media (min-width: 768px){
  .md\\:mt-2{
    margin-top: 8px;
  }
  .md\\:hidden{
    display: none;
  }
  .md\\:min-h-\\[35rem\\]{
    min-height: 35rem;
  }
  .md\\:max-w-md{
    max-width: 448px;
  }
  .md\\:items-center{
    align-items: center;
  }
  .md\\:overflow-y-auto{
    overflow-y: auto;
  }
  .md\\:rounded-2xl{
    border-radius: 1rem;
  }
  .md\\:rounded-b-2xl{
    border-bottom-right-radius: 1rem;
    border-bottom-left-radius: 1rem;
  }
  .md\\:p-4{
    padding: 16px;
  }
}
`;
  var Styles = () => /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("style", { children: styles_default });
  var Styles_default = Styles;
  var XMarkIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("svg", { ...props, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
    "path",
    {
      strokeWidth: "1.5",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      d: "m16.243 7.758-8.485 8.485m8.485 0L7.758 7.758"
    }
  ) });
  var XMarkIcon_default = XMarkIcon;
  function r2(e2) {
    var t2, f3, n2 = "";
    if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
    else if ("object" == typeof e2) if (Array.isArray(e2)) {
      var o2 = e2.length;
      for (t2 = 0; t2 < o2; t2++) e2[t2] && (f3 = r2(e2[t2])) && (n2 && (n2 += " "), n2 += f3);
    } else for (f3 in e2) e2[f3] && (n2 && (n2 += " "), n2 += f3);
    return n2;
  }
  function clsx() {
    for (var e2, t2, f3 = 0, n2 = "", o2 = arguments.length; f3 < o2; f3++) (e2 = arguments[f3]) && (t2 = r2(e2)) && (n2 && (n2 += " "), n2 += t2);
    return n2;
  }
  var clsx_default = clsx;
  var ErrorIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("svg", { ...props, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 100 100", children: [
    /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("circle", { cx: "50", cy: "50", r: "49.375", fill: "url(#a)", fillOpacity: ".65", stroke: "url(#b)", strokeWidth: "1.25" }),
    /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("g", { filter: "url(#c)", children: [
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("circle", { cx: "50", cy: "50", r: "35", fill: "#fff" }),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("circle", { cx: "50", cy: "50", r: "34.432", stroke: "#FFC9AD", strokeWidth: "1.136" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
      "path",
      {
        stroke: "#FF4732",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: "3.75",
        d: "m57.5 42.5-15 14.999m15 .001-15-14.999"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("defs", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("linearGradient", { id: "a", x1: "50", x2: "50", y1: "0", y2: "100", gradientUnits: "userSpaceOnUse", children: [
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("stop", { stopColor: "#FFA483" }),
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("stop", { offset: "1", stopColor: "#FFA483", stopOpacity: "0" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("linearGradient", { id: "b", x1: "50", x2: "50", y1: "0", y2: "100", gradientUnits: "userSpaceOnUse", children: [
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("stop", { stopColor: "#FFA483" }),
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("stop", { offset: ".713", stopColor: "#FFA483", stopOpacity: "0" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(
        "filter",
        {
          id: "c",
          width: "77.5",
          height: "77.5",
          x: "11.25",
          y: "13.125",
          colorInterpolationFilters: "sRGB",
          filterUnits: "userSpaceOnUse",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
            /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("feColorMatrix", { in: "SourceAlpha", result: "hardAlpha", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" }),
            /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("feOffset", { dy: "1.875" }),
            /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("feGaussianBlur", { stdDeviation: "1.875" }),
            /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("feColorMatrix", { values: "0 0 0 0 1 0 0 0 0 0.788235 0 0 0 0 0.678431 0 0 0 0.45 0" }),
            /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("feBlend", { in2: "BackgroundImageFix", result: "effect1_dropShadow_39_740" }),
            /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("feBlend", { in: "SourceGraphic", in2: "effect1_dropShadow_39_740", result: "shape" })
          ]
        }
      )
    ] })
  ] });
  var ErrorIcon_default = ErrorIcon;
  var ReloadIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
    "path",
    {
      d: "M12.3809 1.6665L13.3626 4.24214C12.3754 3.66434 11.2263 3.33317 9.99992 3.33317C6.31802 3.33317 3.33325 6.31794 3.33325 9.99984C3.33325 11.2141 3.6579 12.3526 4.22513 13.3332M7.61897 18.3332L6.63719 15.7575C7.62438 16.3353 8.77348 16.6665 9.99992 16.6665C13.6818 16.6665 16.6666 13.6817 16.6666 9.99984C16.6666 8.78555 16.3419 7.64708 15.7747 6.6665",
      stroke: "#3C424B",
      strokeWidth: "1.5",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ) });
  var ReloadIcon_default = ReloadIcon;
  var WarningIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 100 100", ...props, children: [
    /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
      "circle",
      {
        cx: "50",
        cy: "50",
        r: "49.375",
        fill: "url(#warning-a)",
        fillOpacity: ".65",
        stroke: "url(#warning-b)",
        strokeWidth: "1.25"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("g", { filter: "url(#warning-c)", children: [
      /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("circle", { cx: "50", cy: "50", r: "35", fill: "#fff" }),
      /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("circle", { cx: "50", cy: "50", r: "34.432", stroke: "#FFE999", strokeWidth: "1.136" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
      "path",
      {
        fill: "#FFB200",
        fillRule: "evenodd",
        d: "M47.46 40.207c1.107-1.943 3.973-1.943 5.08 0l9.59 16.834c1.076 1.888-.324 4.209-2.54 4.209H40.41c-2.216 0-3.616-2.32-2.54-4.21l9.59-16.833Zm3.79 16.043a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0Zm-.313-10a.937.937 0 1 0-1.875 0v6.25a.938.938 0 0 0 1.875 0v-6.25Z",
        clipRule: "evenodd"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("defs", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("linearGradient", { id: "warning-a", x1: "50", x2: "50", y1: "0", y2: "100", gradientUnits: "userSpaceOnUse", children: [
        /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("stop", { stopColor: "#FFDA66" }),
        /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("stop", { offset: "1", stopColor: "#FFDA66", stopOpacity: "0" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("linearGradient", { id: "warning-b", x1: "50", x2: "50", y1: "0", y2: "100", gradientUnits: "userSpaceOnUse", children: [
        /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("stop", { stopColor: "#FFDA66" }),
        /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("stop", { offset: ".713", stopColor: "#FFDA66", stopOpacity: "0" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)(
        "filter",
        {
          id: "warning-c",
          width: "77.5",
          height: "77.5",
          x: "11.25",
          y: "13.125",
          colorInterpolationFilters: "sRGB",
          filterUnits: "userSpaceOnUse",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("feColorMatrix", { in: "SourceAlpha", result: "hardAlpha", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" }),
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("feOffset", { dy: "1.875" }),
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("feGaussianBlur", { stdDeviation: "1.875" }),
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("feColorMatrix", { values: "0 0 0 0 1 0 0 0 0 0.913725 0 0 0 0 0.6 0 0 0 0.45 0" }),
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("feBlend", { in2: "BackgroundImageFix", result: "effect1_dropShadow_39_758" }),
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("feBlend", { in: "SourceGraphic", in2: "effect1_dropShadow_39_758", result: "shape" })
          ]
        }
      )
    ] })
  ] });
  var WarningIcon_default = WarningIcon;
  var getParams = ({ retryFlow, errorState }) => ({ retryFlow, errorState });
  var ERROR_TITLES = {
    [AppErrorCodes.GenericError]: __("Something went wrong"),
    [AppErrorCodes.FailedByHostApp]: __("Verification Declined"),
    [AppErrorCodes.VerificationRejected]: __("Request cancelled")
  };
  var ERROR_MESSAGES = {
    [AppErrorCodes.ConnectionFailed]: __("Connection to your wallet failed. Please try again."),
    [AppErrorCodes.VerificationRejected]: __("You\u2019ve cancelled the request in World App."),
    [AppErrorCodes.MaxVerificationsReached]: __(
      "You have already verified the maximum number of times for this action."
    ),
    [AppErrorCodes.CredentialUnavailable]: __("It seems you do not have the verification level required by this app."),
    [AppErrorCodes.MalformedRequest]: __(
      "There was a problem with this request. Please try again or contact the app owner."
    ),
    [AppErrorCodes.InvalidNetwork]: __(
      "Invalid network. If you are the app owner, visit docs.world.org/test for details."
    ),
    [AppErrorCodes.InclusionProofFailed]: __("There was an issue fetching your credential. Please try again."),
    [AppErrorCodes.InclusionProofPending]: __(
      "Your identity is still being registered. Please wait a few minutes and try again."
    ),
    [AppErrorCodes.GenericError]: __("Something unexpected went wrong. Please try again."),
    [AppErrorCodes.UnexpectedResponse]: __("Unexpected response from your wallet. Please try again."),
    [AppErrorCodes.FailedByHostApp]: __("Verification failed by the app. Please contact the app owner for details.")
  };
  var ErrorState = (props) => {
    const { retryFlow, errorState } = idkit_default(getParams);
    const { show_modal } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("div", { className: "space-y-8", children: [
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { className: clsx_default("flex items-center justify-center", show_modal ? "-mt-5" : ""), children: errorState?.code == AppErrorCodes.VerificationRejected ? /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(WarningIcon_default, { className: "w-24" }) : /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ErrorIcon_default, { className: "w-24" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("p", { className: "text-center text-2xl font-semibold text-gray-900 dark:text-white", children: (errorState?.code && ERROR_TITLES[errorState.code]) ?? ERROR_TITLES[AppErrorCodes.GenericError] }),
        /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("p", { className: "mx-auto mt-2 max-w-[224px] text-center text-657080", children: errorState?.message ?? ERROR_MESSAGES[errorState?.code ?? AppErrorCodes.GenericError] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { className: "flex justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)(
        "button",
        {
          type: "button",
          onClick: retryFlow,
          className: "inline-flex items-center rounded-lg border border-ebecef bg-transparent px-8 py-3 font-medium text-3c424b shadow-sm transition duration-300 hover:shadow focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-40",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ReloadIcon_default, { className: "mr-1.5 size-5" }),
            __("Try Again")
          ]
        }
      ) })
    ] });
  };
  var ErrorState_default = ErrorState;
  var CheckIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 100 100", ...props, children: [
    /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
      "circle",
      {
        cx: "50",
        cy: "50",
        r: "49.375",
        fill: "url(#success-a)",
        fillOpacity: ".65",
        stroke: "url(#success-b)",
        strokeWidth: "1.25"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("g", { filter: "url(#success-c)", children: [
      /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("circle", { cx: "50", cy: "50", r: "35", fill: "#fff" }),
      /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("circle", { cx: "50", cy: "50", r: "34.432", stroke: "#CCEBCC", strokeWidth: "1.136" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
      "path",
      {
        stroke: "#090",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: "3.75",
        d: "m41.25 52.5 4.375 4.375 13.125-13.75"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("defs", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("linearGradient", { id: "success-a", x1: "50", x2: "50", y1: "0", y2: "100", gradientUnits: "userSpaceOnUse", children: [
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("stop", { stopColor: "#99D699" }),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("stop", { offset: "1", stopColor: "#99D699", stopOpacity: "0" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("linearGradient", { id: "success-b", x1: "50", x2: "50", y1: "0", y2: "100", gradientUnits: "userSpaceOnUse", children: [
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("stop", { stopColor: "#99D699" }),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("stop", { offset: ".713", stopColor: "#99D699", stopOpacity: "0" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(
        "filter",
        {
          id: "success-c",
          width: "77.5",
          height: "77.5",
          x: "11.25",
          y: "13.125",
          colorInterpolationFilters: "sRGB",
          filterUnits: "userSpaceOnUse",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
            /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("feColorMatrix", { in: "SourceAlpha", result: "hardAlpha", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" }),
            /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("feOffset", { dy: "1.875" }),
            /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("feGaussianBlur", { stdDeviation: "1.875" }),
            /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("feColorMatrix", { values: "0 0 0 0 0.8 0 0 0 0 0.921569 0 0 0 0 0.8 0 0 0 0.45 0" }),
            /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("feBlend", { in2: "BackgroundImageFix", result: "effect1_dropShadow_39_712" }),
            /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("feBlend", { in: "SourceGraphic", in2: "effect1_dropShadow_39_712", result: "shape" })
          ]
        }
      )
    ] })
  ] });
  var CheckIcon_default = CheckIcon;
  var SuccessState = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("div", { className: "space-y-6", children: [
      /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("div", { className: clsx_default("flex items-center justify-center", props.show_modal ? "-mt-5" : ""), children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(CheckIcon_default, { className: "w-24 text-white" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("p", { className: "text-center text-2xl font-semibold text-gray-900 dark:text-white", children: __("Successfully verified") }),
        /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("p", { className: "mx-auto mt-2 max-w-[224px] text-center text-lg text-657080", children: __("Your World ID verification was successful") })
      ] })
    ] });
  };
  var SuccessState_default = SuccessState;
  var WorldcoinIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("svg", { ...props, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 33 32", children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M30.7195 9.77312C29.9097 7.87434 28.7647 6.17103 27.2845 4.6911C25.8044 3.21117 24.1288 2.06632 22.2298 1.25654C20.247 0.418848 18.1525 0 16.0021 0C13.8238 0 11.7293 0.418848 9.7744 1.25654C7.87537 2.06632 6.17184 3.21117 4.69171 4.6911C3.21159 6.17103 2.06659 7.87434 1.25671 9.77312C0.418903 11.7277 0 13.822 0 16C0 18.1501 0.418903 20.2443 1.25671 22.2269C2.06659 24.1257 3.21159 25.829 4.69171 27.3089C6.17184 28.7888 7.87537 29.9337 9.7744 30.7155C11.7572 31.5532 13.8517 31.9721 16.0021 31.9721C18.1525 31.9721 20.247 31.5532 22.2298 30.7155C24.1288 29.9058 25.8323 28.7609 27.3125 27.281C28.7926 25.801 29.9376 24.0977 30.7475 22.1989C31.5853 20.2164 32.0042 18.1222 32.0042 15.9721C32.0042 13.822 31.5574 11.7277 30.7195 9.77312ZM10.696 14.4921C11.3383 11.9232 13.6842 10.0524 16.4489 10.0524H27.5638C28.2899 11.4206 28.7367 12.9284 28.9043 14.4921H10.696ZM28.9043 17.5079C28.7367 19.0716 28.262 20.5794 27.5638 21.9476H16.4489C13.6842 21.9476 11.3662 20.0489 10.696 17.5079H28.9043ZM6.81415 6.81326C9.27172 4.35602 12.5392 3.01571 16.0021 3.01571C19.465 3.01571 22.7325 4.35602 25.19 6.81326C25.2738 6.89703 25.3297 6.95288 25.4134 7.03665H16.4489C14.0472 7.03665 11.8131 7.95811 10.1095 9.66143C8.76903 11.0017 7.9033 12.6771 7.62403 14.4921H3.09988C3.435 11.5881 4.71964 8.9075 6.81415 6.81326ZM16.0021 28.9843C12.5392 28.9843 9.27172 27.644 6.81415 25.1867C4.71964 23.0925 3.435 20.3839 3.09988 17.5079H7.62403C7.93123 19.3229 8.79696 20.9983 10.1095 22.3386C11.8131 24.0419 14.0472 24.9633 16.4489 24.9633H25.4134C25.3297 25.0471 25.2738 25.103 25.19 25.1867C22.7325 27.644 19.465 28.9843 16.0021 28.9843Z"
    }
  ) });
  var WorldcoinIcon_default = WorldcoinIcon;
  var QRPlaceholderIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("svg", { ...props, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 200 200", children: [
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "#EBECEF",
        fillRule: "evenodd",
        d: "M12.1 0C5.417 0 0 5.417 0 12.1v18.505c0 6.682 5.417 12.1 12.1 12.1h18.505c6.682 0 12.1-5.418 12.1-12.1V12.1c0-6.683-5.418-12.1-12.1-12.1H12.1Zm18.505 11.388H12.1a.712.712 0 0 0-.712.712v18.505c0 .393.319.712.712.712h18.505a.712.712 0 0 0 .712-.712V12.1a.712.712 0 0 0-.712-.712Z",
        clipRule: "evenodd"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "#EBECEF",
        d: "M197.026 200c.789 0 1.545-.309 2.103-.86.558-.55.871-1.297.871-2.076v-17.616c0-.778-.313-1.525-.871-2.076a2.996 2.996 0 0 0-2.103-.86h-5.948c-.789 0-1.545.31-2.103.86a2.918 2.918 0 0 0-.871 2.076v8.808h-11.897v-11.744h-11.896v-23.487h11.896v8.808c0 .778.314 1.525.872 2.076.557.55 1.314.86 2.102.86h5.949c.788 0 1.545-.31 2.103-.86a2.922 2.922 0 0 0 .871-2.076v-8.808h8.922c.789 0 1.545-.309 2.103-.86a2.916 2.916 0 0 0 .871-2.076v-5.872c0-.779-.313-1.525-.871-2.076a2.992 2.992 0 0 0-2.103-.86h-29.741c-.789 0-1.545.309-2.103.86a2.916 2.916 0 0 0-.871 2.076v8.808h-23.792v-11.744h8.922c.789 0 1.545-.309 2.103-.86.558-.55.871-1.297.871-2.076v-5.872c0-.778-.313-1.525-.871-2.076a2.996 2.996 0 0 0-2.103-.86h-5.948c-.789 0-1.546.31-2.103.86a2.918 2.918 0 0 0-.871 2.076v8.808H119.7c-.789 0-1.545.309-2.103.86a2.916 2.916 0 0 0-.871 2.076v5.872c0 .779.313 1.525.871 2.076.558.551 1.314.86 2.103.86h20.819v8.808c0 .778.313 1.525.871 2.076.557.55 1.314.86 2.103.86h8.922v8.808c0 .778.313 1.525.871 2.076.558.55 1.314.859 2.103.859h8.922v11.744h-20.818c-.789 0-1.546.31-2.103.86a2.916 2.916 0 0 0-.871 2.076v5.872c0 .779.313 1.526.871 2.076a2.99 2.99 0 0 0 2.103.86h17.844c.789 0 1.545-.309 2.103-.86.558-.55.871-1.297.871-2.076v-8.808h11.896v8.808c0 .779.314 1.526.872 2.076a2.99 2.99 0 0 0 2.102.86h17.845Z"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "#EBECEF",
        fillRule: "evenodd",
        d: "M157.295 12.1c0-6.683 5.418-12.1 12.1-12.1H187.9c6.683 0 12.1 5.417 12.1 12.1v18.505c0 6.682-5.417 12.1-12.1 12.1h-18.505c-6.682 0-12.1-5.418-12.1-12.1V12.1Zm12.1-.712H187.9c.393 0 .712.319.712.712v18.505a.712.712 0 0 1-.712.712h-18.505a.712.712 0 0 1-.712-.712V12.1c0-.393.319-.712.712-.712ZM12.1 157.295c-6.683 0-12.1 5.418-12.1 12.1V187.9c0 6.683 5.417 12.1 12.1 12.1h18.505c6.682 0 12.1-5.417 12.1-12.1v-18.505c0-6.682-5.418-12.1-12.1-12.1H12.1Zm19.217 12.1a.712.712 0 0 0-.712-.712H12.1a.712.712 0 0 0-.712.712V187.9c0 .393.319.712.712.712h18.505a.712.712 0 0 0 .712-.712v-18.505Z",
        clipRule: "evenodd"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "#EBECEF",
        d: "M6.05 89.68A6.05 6.05 0 0 0 0 95.73v9.252a6.05 6.05 0 0 0 6.05 6.05h9.253a6.05 6.05 0 0 0 6.05-6.05V95.73c0-.678-.112-1.33-.318-1.94.445.105.908.16 1.385.16h27.758a6.05 6.05 0 0 0 6.05-6.05v-9.252a6.05 6.05 0 0 0-6.05-6.05H22.42a6.05 6.05 0 0 0-6.05 6.05V87.9c0 .678.112 1.33.317 1.939a6.065 6.065 0 0 0-1.385-.16H6.05Zm102.135-40.926a6.05 6.05 0 0 1 6.05-6.05h9.253a6.05 6.05 0 0 1 6.049 6.05v9.253a6.05 6.05 0 0 1-6.049 6.05h-9.253a6.05 6.05 0 0 1-6.05-6.05v-9.253ZM67.616 184.698a6.05 6.05 0 0 1 6.05-6.05h9.252c.678 0 1.33.111 1.939.317a6.064 6.064 0 0 1-.16-1.385v-9.253a6.05 6.05 0 0 1 6.05-6.049H100a6.05 6.05 0 0 1 6.05 6.049v9.253a6.05 6.05 0 0 1-6.05 6.05h-9.253c-.678 0-1.33-.112-1.938-.317.104.444.159.908.159 1.385v9.252a6.05 6.05 0 0 1-6.05 6.05h-9.253a6.05 6.05 0 0 1-6.05-6.05v-9.252Zm78.291-120.285a6.05 6.05 0 0 1 6.05-6.05h41.993a6.05 6.05 0 0 1 6.05 6.05v9.252a6.05 6.05 0 0 1-6.05 6.05h-41.993a6.05 6.05 0 0 1-6.05-6.05v-9.252ZM95.018 0a6.05 6.05 0 0 0-6.05 6.05v17.082a6.05 6.05 0 0 0 6.05 6.05h9.252a6.05 6.05 0 0 0 6.05-6.05V6.05A6.05 6.05 0 0 0 104.27 0h-9.252Z"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "url(#a)",
        fillRule: "evenodd",
        d: "M12.1 0C5.417 0 0 5.417 0 12.1v18.505c0 6.682 5.417 12.1 12.1 12.1h18.505c6.682 0 12.1-5.418 12.1-12.1V12.1c0-6.683-5.418-12.1-12.1-12.1H12.1Zm18.505 11.388H12.1a.712.712 0 0 0-.712.712v18.505c0 .393.319.712.712.712h18.505a.712.712 0 0 0 .712-.712V12.1a.712.712 0 0 0-.712-.712Z",
        clipRule: "evenodd"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "url(#a)",
        d: "M197.026 200c.789 0 1.545-.309 2.103-.86.558-.55.871-1.297.871-2.076v-17.616c0-.778-.313-1.525-.871-2.076a2.996 2.996 0 0 0-2.103-.86h-5.948c-.789 0-1.545.31-2.103.86a2.918 2.918 0 0 0-.871 2.076v8.808h-11.897v-11.744h-11.896v-23.487h11.896v8.808c0 .778.314 1.525.872 2.076.557.55 1.314.86 2.102.86h5.949c.788 0 1.545-.31 2.103-.86a2.922 2.922 0 0 0 .871-2.076v-8.808h8.922c.789 0 1.545-.309 2.103-.86a2.916 2.916 0 0 0 .871-2.076v-5.872c0-.779-.313-1.525-.871-2.076a2.992 2.992 0 0 0-2.103-.86h-29.741c-.789 0-1.545.309-2.103.86a2.916 2.916 0 0 0-.871 2.076v8.808h-23.792v-11.744h8.922c.789 0 1.545-.309 2.103-.86.558-.55.871-1.297.871-2.076v-5.872c0-.778-.313-1.525-.871-2.076a2.996 2.996 0 0 0-2.103-.86h-5.948c-.789 0-1.546.31-2.103.86a2.918 2.918 0 0 0-.871 2.076v8.808H119.7c-.789 0-1.545.309-2.103.86a2.916 2.916 0 0 0-.871 2.076v5.872c0 .779.313 1.525.871 2.076.558.551 1.314.86 2.103.86h20.819v8.808c0 .778.313 1.525.871 2.076.557.55 1.314.86 2.103.86h8.922v8.808c0 .778.313 1.525.871 2.076.558.55 1.314.859 2.103.859h8.922v11.744h-20.818c-.789 0-1.546.31-2.103.86a2.916 2.916 0 0 0-.871 2.076v5.872c0 .779.313 1.526.871 2.076a2.99 2.99 0 0 0 2.103.86h17.844c.789 0 1.545-.309 2.103-.86.558-.55.871-1.297.871-2.076v-8.808h11.896v8.808c0 .779.314 1.526.872 2.076a2.99 2.99 0 0 0 2.102.86h17.845Z"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "url(#a)",
        fillRule: "evenodd",
        d: "M157.295 12.1c0-6.683 5.418-12.1 12.1-12.1H187.9c6.683 0 12.1 5.417 12.1 12.1v18.505c0 6.682-5.417 12.1-12.1 12.1h-18.505c-6.682 0-12.1-5.418-12.1-12.1V12.1Zm12.1-.712H187.9c.393 0 .712.319.712.712v18.505a.712.712 0 0 1-.712.712h-18.505a.712.712 0 0 1-.712-.712V12.1c0-.393.319-.712.712-.712Z",
        clipRule: "evenodd"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "url(#a)",
        fillRule: "evenodd",
        d: "M12.1 157.295c-6.683 0-12.1 5.418-12.1 12.1V187.9c0 6.683 5.417 12.1 12.1 12.1h18.505c6.682 0 12.1-5.417 12.1-12.1v-18.505c0-6.682-5.418-12.1-12.1-12.1H12.1Zm19.217 12.1a.712.712 0 0 0-.712-.712H12.1a.712.712 0 0 0-.712.712V187.9c0 .393.319.712.712.712h18.505a.712.712 0 0 0 .712-.712v-18.505Z",
        clipRule: "evenodd"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "url(#a)",
        d: "M6.05 89.68A6.05 6.05 0 0 0 0 95.73v9.252a6.05 6.05 0 0 0 6.05 6.05h9.253a6.05 6.05 0 0 0 6.05-6.05V95.73c0-.678-.112-1.33-.318-1.94.445.105.908.16 1.385.16h27.758a6.05 6.05 0 0 0 6.05-6.05v-9.252a6.05 6.05 0 0 0-6.05-6.05H22.42a6.05 6.05 0 0 0-6.05 6.05V87.9c0 .678.112 1.33.317 1.939a6.065 6.065 0 0 0-1.385-.16H6.05Z"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "url(#a)",
        d: "M108.185 48.754a6.05 6.05 0 0 1 6.05-6.05h9.253a6.05 6.05 0 0 1 6.049 6.05v9.253a6.05 6.05 0 0 1-6.049 6.05h-9.253a6.05 6.05 0 0 1-6.05-6.05v-9.253Z"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "url(#a)",
        d: "M67.616 184.698a6.05 6.05 0 0 1 6.05-6.05h9.252c.678 0 1.33.111 1.939.317a6.064 6.064 0 0 1-.16-1.385v-9.253a6.05 6.05 0 0 1 6.05-6.049H100a6.05 6.05 0 0 1 6.05 6.049v9.253a6.05 6.05 0 0 1-6.05 6.05h-9.253c-.678 0-1.33-.112-1.938-.317.104.444.159.908.159 1.385v9.252a6.05 6.05 0 0 1-6.05 6.05h-9.253a6.05 6.05 0 0 1-6.05-6.05v-9.252Z"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "url(#a)",
        d: "M145.907 64.413a6.05 6.05 0 0 1 6.05-6.05h41.993a6.05 6.05 0 0 1 6.05 6.05v9.252a6.05 6.05 0 0 1-6.05 6.05h-41.993a6.05 6.05 0 0 1-6.05-6.05v-9.252Z"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "url(#a)",
        d: "M95.018 0a6.05 6.05 0 0 0-6.05 6.05v17.082a6.05 6.05 0 0 0 6.05 6.05h9.252a6.05 6.05 0 0 0 6.05-6.05V6.05A6.05 6.05 0 0 0 104.27 0h-9.252Z"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("linearGradient", { id: "a", x1: "0", x2: "200", y1: "0", y2: "200", gradientUnits: "userSpaceOnUse", children: [
      /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("stop", { offset: ".37", stopColor: "#fff", stopOpacity: "0" }),
      /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("stop", { offset: ".5", stopColor: "#fff", stopOpacity: ".85" }),
      /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("stop", { offset: ".63", stopColor: "#fff", stopOpacity: "0" })
    ] }) })
  ] });
  var QRPlaceholderIcon_default = QRPlaceholderIcon;
  var QRState = ({ qrData, showQR, setShowQR }) => {
    const media = useMedia_default();
    const [copiedLink, setCopiedLink] = (0, import_react35.useState)(false);
    const copyLink = (0, import_react35.useCallback)(() => {
      (0, import_copy_to_clipboard.default)(qrData ?? "");
      setCopiedLink(true);
      setTimeout(() => setCopiedLink(false), 2e3);
    }, [qrData]);
    return /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("div", { className: clsx_default("md:hidden", { "mb-10 space-y-4": !showQR }), children: [
        /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)(
          motion.a,
          {
            href: qrData ?? "",
            whileTap: { scale: 0.95 },
            whileHover: { scale: 1.05 },
            transition: { layout: { duration: 0.15 } },
            layoutId: media == "desktop" ? void 0 : "worldid-button",
            className: clsx_default(
              "flex w-full items-center space-x-2 rounded-2xl border border-transparent p-4 font-medium shadow-sm",
              "bg-0d151d text-white dark:bg-white dark:text-0d151d",
              { hidden: showQR }
            ),
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(WorldcoinIcon_default, { className: "size-5" }),
              /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
                motion.span,
                {
                  className: "flex-1 text-center",
                  transition: { layout: { duration: 0.15 } },
                  layoutId: media == "desktop" ? void 0 : "worldid-text",
                  children: __("Open World App")
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("div", { className: clsx_default("mb-3", { "space-y-4": !showQR, hidden: media === "mobile" }), children: [
          /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("div", { className: clsx_default("flex items-center space-x-4 ", { hidden: showQR }), children: [
            /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("hr", { className: "flex-1" }),
            /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("span", { className: "text-xs font-medium text-9ba3ae", children: "or" }),
            /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("hr", { className: "flex-1" })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
            motion.button,
            {
              className: "w-full rounded-2xl border border-ebecef p-4 text-lg font-medium text-3c424b",
              onClick: () => setShowQR((state) => !state),
              children: showQR ? __("Hide QR Code") : __("Display QR Code")
            }
          )
        ] })
      ] }),
      (media == "desktop" || showQR) && /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(AnimatePresence, { children: copiedLink && /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
          motion.div,
          {
            className: "text-sm text-9eafc0",
            initial: "hidden",
            animate: "visible",
            exit: "exit",
            variants: {
              hidden: { opacity: 0, height: 0, marginTop: 0, y: 0 },
              visible: {
                opacity: 1,
                height: "auto",
                marginTop: 8,
                y: -20,
                transition: {
                  duration: 0.25,
                  opacity: { delay: 0.05, duration: 0.2 },
                  ease: "easeInOut"
                }
              },
              exit: {
                opacity: 0,
                height: 0,
                marginTop: 0,
                y: 0,
                transition: {
                  duration: 0.4,
                  delay: 0.1,
                  opacity: { duration: 0.25, delay: 0 },
                  ease: "easeInOut"
                }
              }
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("span", { className: "rounded-lg border border-f1f5f8 px-2 py-1 text-sm", children: __("QR Code copied") })
          },
          "copied"
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("div", { className: "relative inline-flex items-center justify-center rounded-2xl border border-f1f5f8 p-2 dark:border-f1f5f8/10", children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("div", { className: "text-29343f dark:text-white", children: qrData ? (
          // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
          /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("div", { onClick: copyLink, className: "cursor-pointer", children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(QRCode_default, { data: qrData, size: 244 }) })
        ) : /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("div", { className: "flex size-[244px] items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(QRPlaceholderIcon_default, { className: "size-[244px] animate-pulse" }) }) }) })
      ] })
    ] });
  };
  var QRState_default = QRState;
  var useWorldBridge = (app_id, action, signal, bridge_url, verification_level, action_description, partner) => {
    const ref_verification_level = (0, import_react37.useRef)(verification_level);
    const { reset: reset2, result, connectorURI, createClient, pollForUpdates, verificationState, errorCode } = useWorldBridgeStore();
    (0, import_react37.useEffect)(() => {
      if (!connectorURI) {
        void createClient({
          app_id,
          action,
          signal,
          bridge_url,
          action_description,
          verification_level: ref_verification_level.current,
          partner
        });
      }
    }, [
      app_id,
      action,
      signal,
      action_description,
      createClient,
      ref_verification_level,
      bridge_url,
      connectorURI,
      partner
    ]);
    (0, import_react37.useEffect)(() => {
      if (!connectorURI || result || errorCode) return;
      const interval = setInterval(() => void pollForUpdates(), 3e3);
      return () => clearInterval(interval);
    }, [connectorURI, pollForUpdates, errorCode, result]);
    return { connectorURI, reset: reset2, result, verificationState, errorCode };
  };
  var LoadingIcon = ({ className, ...props }) => /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      className: `animate-spin motion-reduce:animate-[spin_1.5s_linear_infinite] ${className}`,
      ...props,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("circle", { cx: "12", cy: "12", r: "10.75", stroke: "#191C20", strokeOpacity: ".16", strokeWidth: "2.5" }),
        /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
          "path",
          {
            fill: "#191C20",
            d: "M17.28 2.633c.338-.6.127-1.368-.505-1.642A12 12 0 0 0 7.459.892c-.638.261-.864 1.024-.539 1.632.326.607 1.08.827 1.725.584a9.504 9.504 0 0 1 6.897.073c.64.257 1.399.053 1.737-.548Z"
          }
        )
      ]
    }
  );
  var LoadingIcon_default = LoadingIcon;
  var getOptions = (store) => ({
    signal: store.signal,
    app_id: store.app_id,
    action: store.action,
    setStage: store.setStage,
    bridge_url: store.bridge_url,
    handleVerify: store.handleVerify,
    setErrorState: store.setErrorState,
    verification_level: store.verification_level,
    action_description: store.action_description,
    partner: store.partner
  });
  var WorldIDState = (props) => {
    const media = useMedia_default();
    const [showQR, setShowQR] = (0, import_react36.useState)(false);
    const {
      app_id,
      action,
      signal,
      setStage,
      handleVerify,
      bridge_url,
      action_description,
      verification_level,
      setErrorState,
      partner
    } = idkit_default(getOptions, shallow$1);
    const { connectorURI, reset: reset2, errorCode, result, verificationState } = useWorldBridge(
      app_id,
      action,
      signal,
      bridge_url,
      verification_level,
      action_description,
      partner
    );
    (0, import_react36.useEffect)(() => reset2, [reset2]);
    (0, import_react36.useEffect)(() => {
      if (verificationState === VerificationState.Failed) {
        setStage(
          "ERROR"
          /* ERROR */
        );
        setErrorState({ code: errorCode ?? AppErrorCodes.GenericError });
      }
      if (result) {
        if (verification_level === VerificationLevel.Orb && result.verification_level === VerificationLevel.Device) {
          console.error("Credential type received from wallet does not match configured credential_types.");
          setStage(
            "ERROR"
            /* ERROR */
          );
          setErrorState({ code: AppErrorCodes.CredentialUnavailable });
          return;
        }
        return handleVerify(result);
      }
    }, [result, handleVerify, verificationState, setStage, errorCode, setErrorState, verification_level]);
    const { show_modal } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)(
      "div",
      {
        className: clsx_default(
          "flex flex-col items-center text-center",
          show_modal ? showQR ? "-mt-6 space-y-5 " : "-mt-6 space-y-10 " : ""
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: clsx_default(!show_modal ? "hidden" : ""), children: [
            /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: "mb-4 flex items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(WorldcoinIcon_default, { className: "h-10 text-0d151d dark:text-white" }) }),
            /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("p", { className: "font-sora text-2xl font-semibold text-gray-900 dark:text-white", children: __("Verify with World ID") }),
            /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("p", { className: clsx_default("mt-3 text-657080 dark:text-9eafc0 md:mt-2", { hidden: media === "mobile" }), children: [
              "Use your camera to scan the QR code. ",
              /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("br", {}),
              " ",
              /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("span", { className: "text-red-500", children: "Keep this window open after scanning." })
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: "relative w-full", children: [
            verificationState === VerificationState.WaitingForApp && /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: "absolute inset-0 flex flex-col items-center justify-center space-y-6", children: [
              /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(LoadingIcon_default, { className: "size-6" }),
              /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("p", { className: "font-bold text-657080", children: "Verifying" }),
                /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("p", { className: "text-sm text-657080", children: "Please continue in app" }),
                /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("p", { className: clsx_default(show_modal ? "" : "hidden", "mt-2 text-sm font-bold text-red-500"), children: "Don't close this window" })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
              "div",
              {
                className: clsx_default(
                  "transition duration-500 ease-in-out",
                  verificationState === VerificationState.WaitingForApp && "opacity-40 blur-lg"
                ),
                children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: "mx-auto", children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(QRState_default, { showQR, setShowQR, qrData: connectorURI }) })
              }
            )
          ] })
        ]
      }
    );
  };
  var WorldIDState_default = WorldIDState;
  var HostAppVerificationState = () => {
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)("div", { className: "space-y-6", children: [
      /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("div", { className: "flex justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(LoadingIcon_default, { className: "size-24" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("div", { className: "mt-4 text-70868f", children: __("Transmitting verification to host app. Please wait...") })
    ] });
  };
  var HostAppVerificationState_default = HostAppVerificationState;
  var getParams2 = ({ open: open2, processing, onOpenChange, stage, setStage, setOptions }) => ({
    stage,
    setStage,
    processing,
    setOptions,
    isOpen: open2,
    onOpenChange
  });
  var IDKitWidget = ({
    children,
    show_modal = true,
    container_id,
    disable_default_modal_behavior = false,
    ...config
  }) => {
    const media = useMedia_default();
    const { isOpen, onOpenChange, stage, setOptions } = idkit_default(getParams2, shallow$1);
    (0, import_react38.useEffect)(() => {
      if (config.action === "") {
        throw new Error(__("Action cannot be an empty string."));
      }
      setOptions(
        config,
        "props"
        /* PROPS */
      );
    }, [config, setOptions]);
    const StageContent = (0, import_react38.useMemo)(() => {
      switch (stage) {
        case "WORLD_ID":
          return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(WorldIDState_default, { show_modal });
        case "SUCCESS":
          return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SuccessState_default, {});
        case "ERROR":
          return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(ErrorState_default, {});
        case "HOST_APP_VERIFICATION":
          return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(HostAppVerificationState_default, {});
        default:
          throw new Error(__("Invalid IDKitStage :stage.", { stage }));
      }
    }, [stage, show_modal]);
    const widgetContent = /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(react_shadow_esm_default.div, { mode: "open", id: "idkit-widget", children: [
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Styles_default, {}),
      /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Provider, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Viewport, { className: "flex justify-center" }),
        /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
          "div",
          {
            id: "widget-content-inline",
            className: "relative flex flex-col bg-white p-4 focus:outline-none dark:bg-0d151d",
            children: StageContent
          }
        )
      ] })
    ] });
    if (!show_modal && container_id) {
      const containerElement = document.getElementById(container_id);
      if (containerElement) {
        return (0, import_react_dom3.createPortal)(widgetContent, containerElement);
      }
      console.warn(`Container element with id "${container_id}" not found. Rendering widget inline.`);
    }
    const avoidDefaultDomBehavior = (e2) => {
      if (disable_default_modal_behavior) {
        e2.preventDefault();
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Root2, { open: isOpen, onOpenChange, children: [
      children?.({ open: () => onOpenChange(true) }),
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Portal2, { forceMount: true, children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(import_react38.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(AnimatePresence, { children: isOpen && /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(react_shadow_esm_default.div, { mode: "open", id: "idkit-widget", children: [
        /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Styles_default, {}),
        /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)("div", { id: "modal", className: "fixed z-[9999] font-sans", children: [
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Overlay, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
            motion.div,
            {
              initial: { opacity: 0 },
              animate: { opacity: 1 },
              exit: { opacity: 0 },
              className: "fixed inset-0 bg-black/50 backdrop-blur-lg"
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", { className: "fixed inset-0 z-[9999] overflow-y-hidden md:overflow-y-auto", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", { className: "flex min-h-full items-end justify-center text-center md:items-center md:p-4", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
            Content,
            {
              asChild: true,
              onPointerDownOutside: avoidDefaultDomBehavior,
              onInteractOutside: avoidDefaultDomBehavior,
              children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
                motion.div,
                {
                  layout: media == "mobile" ? "position" : true,
                  exit: media == "mobile" ? "initMob" : "init",
                  initial: media == "mobile" ? "initMob" : "init",
                  animate: media == "mobile" ? "animateMob" : "animate",
                  variants: {
                    init: { opacity: 0, scale: 0.9 },
                    initMob: { translateY: "100%" },
                    animate: { opacity: 1, scale: 1 },
                    animateMob: { translateY: 0 }
                  },
                  transition: { layout: { duration: 0.15 } },
                  className: "relative z-50 flex min-h-screen w-full flex-col bg-white pt-6 shadow focus:outline-none focus-visible:ring focus-visible:ring-purple-500/75 dark:bg-0d151d md:min-h-[35rem] md:max-w-md md:rounded-2xl",
                  children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Provider, { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Viewport, { className: "flex justify-center" }),
                    /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", { className: "mx-6 mb-12 flex items-center justify-between", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Close, { className: "flex size-11 items-center justify-center rounded-full text-black dark:text-white", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(XMarkIcon_default, { className: "size-5" }) }) }),
                    /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", { className: "relative mx-6 mb-6 flex flex-1 flex-col items-center justify-center", children: StageContent }),
                    /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", { className: "flex items-center justify-center border-t border-f5f5f7 p-7 md:rounded-b-2xl", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
                      "a",
                      {
                        href: "https://developer.worldcoin.org/privacy-statement",
                        target: "_blank",
                        rel: "noreferrer",
                        className: "text-sm text-657080 hover:underline",
                        children: __("Terms & Privacy")
                      }
                    ) })
                  ] })
                }
              )
            }
          ) }) })
        ] })
      ] }) }) }) })
    ] });
  };
  var BaseWidget_default = IDKitWidget;
  var IDKitWidget_default = (0, import_react33.memo)(BaseWidget_default);

  // src/index.tsx
  var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
  var root;
  var isInitialized = false;
  var init = (config) => {
    if (isInitialized) throw new Error(__("IDKit is already initialized"));
    const startApp = () => {
      try {
        if (!isInitialized) {
          const node = document.createElement("div");
          document.body.appendChild(node);
          root = (0, import_client.createRoot)(node);
          root.render(/* @__PURE__ */ (0, import_jsx_runtime32.jsx)(IDKitWidget_default, { ...config }));
          isInitialized = true;
        }
      } catch (error) {
        console.error(__("Error while rendering IDKit"), error);
      }
    };
    if (/complete|interactive|loaded/.test(document.readyState)) {
      startApp();
    } else {
      document.addEventListener("DOMContentLoaded", startApp, false);
    }
  };
  var update = (config) => {
    if (!isInitialized) throw new Error(__("IDKit is not initialized"));
    idkit_default.getState().setOptions(config, ConfigSource.PROPS);
  };
  var open = () => {
    return new Promise((resolve, reject) => {
      if (!isInitialized) return reject(__("IDKitWidget is not initialized"));
      idkit_default.getState().addErrorCallback(reject, ConfigSource.MANUAL);
      idkit_default.getState().addSuccessCallback(resolve, ConfigSource.MANUAL);
      idkit_default.setState({ open: true });
    });
  };
  var close = () => {
    return new Promise((_, reject) => {
      if (!isInitialized) return reject(__("IDKitWidget is not initialized"));
      idkit_default.setState({ open: false });
    });
  };
  var reset = () => {
    console.warn(__("Advanced method intended for internal use! Avoid calling this method directly."));
    root.unmount();
    isInitialized = false;
    idkit_default.destroy();
  };
  var IDKit = {
    init,
    update,
    open,
    close,
    reset,
    get isInitialized() {
      return isInitialized;
    }
  };
  window.IDKit = IDKit;
})();
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
